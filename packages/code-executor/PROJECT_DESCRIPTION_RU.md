# Подробное описание проекта Code Executor

## Обзор проекта

**Code Executor** — это высокопроизводительный микросервис для безопасного выполнения пользовательского кода на множестве языков программирования. Проект представляет собой HTTP API-сервис, написанный на Go, который использует платформу **Piston** для изолированного выполнения кода в Docker-контейнерах.

## Архитектура и принцип работы

### Компоненты системы

Проект состоит из следующих основных компонентов:

#### 1. **HTTP API Сервер (Go)**
- **Фреймворк**: Gin (высокопроизводительный HTTP веб-фреймворк для Go)
- **Логирование**: Zap (структурированное логирование)
- **Порт**: 8080 (по умолчанию), автоматически выбирает свободный порт при занятости
- **CORS**: Настроен для работы с любыми источниками

#### 2. **Worker Pool (Пул воркеров)**
- **Назначение**: Управление параллельным выполнением задач
- **Реализация**: Канал-ориентированный пул горутин
- **Настройка**: Количество воркеров настраивается через параметр `--workers` (по умолчанию: 10)
- **Функции**:
  - Синхронное выполнение (`Execute`) — для одиночных запросов
  - Асинхронное выполнение (`ExecuteAsync`) — для параллельной обработки тестов
  - Автоматическое управление жизненным циклом воркеров

#### 3. **Piston Client (Клиент Piston API)**
- **Назначение**: Взаимодействие с Piston API для выполнения кода
- **Особенности**:
  - Кэширование списка доступных runtime'ов
  - Автоматическое маппинг языков программирования
  - Поддержка версий языков
  - Обработка ошибок и таймаутов

#### 4. **Piston (Движок выполнения кода)**
- **Что это**: Платформа для изолированного выполнения кода
- **Изоляция**: Docker-контейнеры
- **Безопасность**: 
  - Ограничение ресурсов (CPU, память)
  - Таймауты выполнения
  - Ограничение системных вызовов
  - Изоляция файловой системы
- **API**: REST API на порту 2000

#### 5. **Автоматическая установка языков**
- **Скрипт**: `install-all-languages.sh`
- **Функция**: Автоматическая установка всех доступных языков программирования в Piston
- **Процесс**:
  1. Ожидание готовности Piston API
  2. Получение списка доступных пакетов
  3. Фильтрация неустановленных пакетов
  4. Установка всех пакетов последовательно

### Поток выполнения запроса

#### Эндпоинт `/execute` (одиночное выполнение)

```
1. Клиент → HTTP POST /execute
   {
     "lang": "python",
     "code": "print('Hello, World!')",
     "timeout": 10
   }

2. Handler.Execute()
   ├─ Валидация запроса
   ├─ Создание контекста с таймаутом
   └─ Отправка задачи в Worker Pool

3. Worker Pool
   ├─ Получение свободного воркера
   └─ Выполнение функции executeCode()

4. executeCode()
   ├─ Определение имени файла по языку
   ├─ Формирование запроса к Piston
   └─ Вызов PistonClient.Execute()

5. PistonClient.Execute()
   ├─ Маппинг языка (например, "javascript" → "node")
   ├─ Получение версии языка из кэша runtime'ов
   ├─ HTTP POST к Piston API /api/v2/execute
   └─ Парсинг ответа

6. Piston
   ├─ Создание изолированного контейнера
   ├─ Компиляция (для компилируемых языков)
   ├─ Выполнение кода
   ├─ Ограничение ресурсов
   └─ Возврат результата

7. Обработка результата
   ├─ Проверка ошибок компиляции
   ├─ Проверка таймаутов
   ├─ Обработка stdout/stderr
   └─ Возврат ответа клиенту
```

#### Эндпоинт `/tests` (параллельное выполнение тестов)

```
1. Клиент → HTTP POST /tests
   {
     "lang": "python",
     "code": "import sys\nprint(sys.stdin.read())",
     "timeout": 10,
     "tests": [
       {"id": 0, "input": "test1"},
       {"id": 1, "input": "test2"}
     ]
   }

2. Handler.Tests()
   ├─ Валидация запроса
   ├─ Создание контекста с таймаутом
   └─ Параллельная обработка тестов

3. Для каждого теста:
   ├─ ExecuteAsync() → Worker Pool
   ├─ Асинхронное выполнение executeCode()
   └─ Callback для сохранения результата

4. WaitGroup ожидает завершения всех тестов

5. Возврат массива результатов
```

### Обработка языков программирования

#### Определение имени файла
- **Динамическое определение**: Запрос к Piston API для получения информации о runtime
- **Fallback маппинг**: Статический словарь расширений для 70+ языков
- **Примеры**:
  - `python` → `main.py`
  - `javascript` → `main.js`
  - `java` → `Main.java`
  - `go` → `main.go`

#### Маппинг языков
- **Автоматический**: Использует API Piston для получения актуальных имен языков
- **Fallback**: Статический маппинг для популярных языков:
  - `javascript` → `node`
  - `cpp` → `gcc`
  - `c` → `gcc`

#### Поддержка компилируемых языков
- **Определение**: Статический список компилируемых языков (C, C++, Java, Go, Rust, и др.)
- **Обработка**: 
  - Проверка стадии компиляции
  - Фильтрация логов компиляции из stdout
  - Проверка успешности выполнения программы

## Используемые сервисы и технологии

### Основной стек

1. **Go 1.24.7**
   - Язык программирования для основного сервиса
   - Преимущества: высокая производительность, статическая компиляция, отличная поддержка конкурентности

2. **Gin Framework**
   - HTTP веб-фреймворк
   - Используется для: роутинга, middleware, обработки запросов

3. **Zap Logger**
   - Структурированное логирование
   - Поддержка уровней логирования (debug/production)

4. **Piston**
   - Платформа выполнения кода
   - Docker-based изоляция
   - Поддержка 70+ языков программирования

### Инфраструктура

1. **Docker & Docker Compose**
   - Контейнеризация сервисов
   - Оркестрация: Piston + Code Executor + установка языков
   - Изоляция и управление ресурсами

2. **Alpine Linux**
   - Базовый образ для контейнеров
   - Минимальный размер образа

3. **Bash скрипты**
   - Автоматизация установки языков
   - CI/CD проверки

### Сетевые протоколы

1. **HTTP/REST API**
   - Основной протокол взаимодействия
   - JSON для обмена данными

2. **Docker Networking**
   - Изолированная сеть для контейнеров
   - Внутренняя коммуникация между сервисами

## Преимущества проекта

### 1. **Безопасность**

- **Изоляция выполнения**: Каждый запрос выполняется в отдельном Docker-контейнере
- **Ограничение ресурсов**: 
  - Ограничение CPU через cgroups
  - Ограничение памяти
  - Ограничение времени выполнения (таймауты)
- **Ограничение системных вызовов**: Piston использует seccomp для фильтрации системных вызовов
- **Изоляция файловой системы**: Временные файловые системы для каждого выполнения

### 2. **Производительность**

- **Параллельная обработка**: Worker Pool позволяет обрабатывать несколько запросов одновременно
- **Асинхронное выполнение тестов**: Эндпоинт `/tests` выполняет все тесты параллельно
- **Кэширование**: Кэширование списка runtime'ов в Piston Client
- **Эффективное использование ресурсов**: Настраиваемое количество воркеров

### 3. **Масштабируемость**

- **Горизонтальное масштабирование**: Можно запустить несколько экземпляров сервиса
- **Настраиваемый пул воркеров**: Количество воркеров настраивается под нагрузку
- **Статeless архитектура**: Сервис не хранит состояние, что упрощает масштабирование

### 4. **Универсальность**

- **Поддержка 70+ языков**: Python, JavaScript, Java, C/C++, Go, Rust, Ruby, PHP и многие другие
- **Автоматическая установка языков**: При первом запуске все языки устанавливаются автоматически
- **Гибкая конфигурация**: Настройка через параметры командной строки и переменные окружения

### 5. **Надежность**

- **Graceful shutdown**: Корректное завершение работы с ожиданием завершения активных задач
- **Обработка ошибок**: Детальная обработка ошибок на всех уровнях
- **Health check**: Эндпоинт `/health` для проверки работоспособности
- **Таймауты**: Защита от зависших запросов

### 6. **Удобство использования**

- **Простой API**: Два основных эндпоинта (`/execute` и `/tests`)
- **JSON формат**: Стандартный формат обмена данными
- **Автоматический выбор порта**: Если указанный порт занят, сервис автоматически найдет свободный
- **Docker Compose**: Простой запуск всей инфраструктуры одной командой

### 7. **Разработка и тестирование**

- **CI/CD скрипты**: Автоматическая проверка поддержки языков
- **Логирование**: Детальные логи для отладки
- **Режим отладки**: Флаг `--debug` для детального логирования
- **Тестовые скрипты**: Скрипты для проверки работы сервисов

### 8. **Производственная готовность**

- **Multi-stage Docker build**: Оптимизированные образы
- **Health checks**: Встроенные проверки здоровья для Docker Compose
- **Restart policies**: Автоматический перезапуск при сбоях
- **Structured logging**: Структурированное логирование для интеграции с системами мониторинга

### 9. **Экономия ресурсов**

- **Эффективное использование памяти**: Worker Pool ограничивает количество одновременных выполнений
- **Переиспользование контейнеров**: Piston оптимизирует использование Docker-контейнеров
- **Минимальные образы**: Использование Alpine Linux для уменьшения размера образов

### 10. **Гибкость конфигурации**

- **Параметры командной строки**: Настройка порта, количества воркеров, URL Piston
- **Переменные окружения**: Поддержка конфигурации через ENV
- **Автоматическая адаптация**: Автоматический выбор порта, маппинг языков

## Примеры использования

### Образовательные платформы
- Онлайн-компиляторы и IDE
- Системы автоматической проверки заданий
- Интерактивные учебные курсы

### Системы тестирования кода
- Автоматическое тестирование решений
- Проверка домашних заданий
- Технические интервью

### Платформы для соревнований
- Онлайн-соревнования по программированию
- Hackathons
- Code challenges

### Интеграции
- CI/CD системы
- Системы code review
- Инструменты для анализа кода

## Заключение

Code Executor представляет собой современное, безопасное и производительное решение для выполнения пользовательского кода. Проект сочетает в себе простоту использования, высокую производительность и надежность, что делает его идеальным выбором для различных сценариев использования, от образовательных платформ до систем автоматического тестирования.


