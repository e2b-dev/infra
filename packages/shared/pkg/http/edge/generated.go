// Package edge provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package edge

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for ClusterNodeStatus.
const (
	Draining  ClusterNodeStatus = "draining"
	Healthy   ClusterNodeStatus = "healthy"
	Unhealthy ClusterNodeStatus = "unhealthy"
)

// Defines values for ClusterOrchestratorRole.
const (
	Orchestrator    ClusterOrchestratorRole = "orchestrator"
	TemplateBuilder ClusterOrchestratorRole = "template-builder"
)

// Defines values for LogLevel.
const (
	LogLevelDebug LogLevel = "debug"
	LogLevelError LogLevel = "error"
	LogLevelInfo  LogLevel = "info"
	LogLevelWarn  LogLevel = "warn"
)

// Defines values for V1SandboxLogsParamsDirection.
const (
	V1SandboxLogsParamsDirectionBackward V1SandboxLogsParamsDirection = "backward"
	V1SandboxLogsParamsDirectionForward  V1SandboxLogsParamsDirection = "forward"
)

// Defines values for V1TemplateBuildLogsParamsDirection.
const (
	V1TemplateBuildLogsParamsDirectionBackward V1TemplateBuildLogsParamsDirection = "backward"
	V1TemplateBuildLogsParamsDirectionForward  V1TemplateBuildLogsParamsDirection = "forward"
)

// BuildLogEntry defines model for BuildLogEntry.
type BuildLogEntry struct {
	Fields map[string]string `json:"fields"`

	// Level State of the sandbox
	Level LogLevel `json:"level"`

	// Message Log message content
	Message string `json:"message"`

	// Timestamp Timestamp of the log entry
	Timestamp time.Time `json:"timestamp"`
}

// ClusterNodeInfo defines model for ClusterNodeInfo.
type ClusterNodeInfo struct {
	// NodeID Node ID
	NodeID string `json:"nodeID"`

	// ServiceInstanceID Service ID
	ServiceInstanceID string `json:"serviceInstanceID"`

	// ServiceStartup Time when the node started
	ServiceStartup time.Time `json:"serviceStartup"`

	// ServiceStatus State of the cluster node
	ServiceStatus ClusterNodeStatus `json:"serviceStatus"`

	// ServiceVersion Version of the service
	ServiceVersion string `json:"serviceVersion"`

	// ServiceVersionCommit Version of the service
	ServiceVersionCommit string `json:"serviceVersionCommit"`
}

// ClusterNodeStatus State of the cluster node
type ClusterNodeStatus string

// ClusterOrchestratorNode defines model for ClusterOrchestratorNode.
type ClusterOrchestratorNode struct {
	// NodeID Node ID
	NodeID string                    `json:"nodeID"`
	Roles  []ClusterOrchestratorRole `json:"roles"`

	// ServiceHost Node private host address and service port
	ServiceHost string `json:"serviceHost"`

	// ServiceInstanceID Service instance ID
	ServiceInstanceID string `json:"serviceInstanceID"`

	// ServiceStartedAt Time when the node was registered
	ServiceStartedAt time.Time `json:"serviceStartedAt"`

	// ServiceStatus State of the cluster node
	ServiceStatus ClusterNodeStatus `json:"serviceStatus"`

	// ServiceVersion Service Version
	ServiceVersion string `json:"serviceVersion"`

	// ServiceVersionCommit Service Version
	ServiceVersionCommit string `json:"serviceVersionCommit"`
}

// ClusterOrchestratorRole Capability of the orchestrator
type ClusterOrchestratorRole string

// ClusterServiceDiscovery defines model for ClusterServiceDiscovery.
type ClusterServiceDiscovery struct {
	Orchestrators []ClusterOrchestratorNode `json:"orchestrators"`
}

// Error defines model for Error.
type Error struct {
	// Code Error code
	Code int32 `json:"code"`

	// Message Error
	Message string `json:"message"`
}

// LogLevel State of the sandbox
type LogLevel string

// SandboxLog Log entry with timestamp and line
type SandboxLog struct {
	// Line Log line content
	Line string `json:"line"`

	// Timestamp Timestamp of the log entry
	Timestamp time.Time `json:"timestamp"`
}

// SandboxLogEntry defines model for SandboxLogEntry.
type SandboxLogEntry struct {
	Fields map[string]string `json:"fields"`

	// Level State of the sandbox
	Level LogLevel `json:"level"`

	// Message Log message content
	Message string `json:"message"`

	// Timestamp Timestamp of the log entry
	Timestamp time.Time `json:"timestamp"`
}

// SandboxLogsResponse defines model for SandboxLogsResponse.
type SandboxLogsResponse struct {
	// LogEntries Structured logs of the sandbox
	LogEntries []SandboxLogEntry `json:"logEntries"`

	// Logs Sandbox logs
	Logs []SandboxLog `json:"logs"`
}

// SandboxMetric defines model for SandboxMetric.
type SandboxMetric struct {
	// CpuCount Number of CPUs
	CpuCount int32 `json:"cpu_count"`

	// CpuUsedPct CPU usage percentage
	CpuUsedPct float32 `json:"cpu_used_pct"`

	// DiskTotal Total disk space in bytes
	DiskTotal int64 `json:"disk_total"`

	// DiskUsed Used disk space in bytes
	DiskUsed int64 `json:"disk_used"`

	// MemTotal Total memory in bytes
	MemTotal int64 `json:"mem_total"`

	// MemUsed Used memory in bytes
	MemUsed int64 `json:"mem_used"`

	// Timestamp Timestamp of the metric
	Timestamp time.Time `json:"timestamp"`

	// TimestampUnix Unix timestamp in seconds
	TimestampUnix int64 `json:"timestamp_unix"`
}

// SandboxesWithMetrics defines model for SandboxesWithMetrics.
type SandboxesWithMetrics struct {
	// Sandboxes Map of sandbox IDs to their latest metrics
	Sandboxes map[string]SandboxMetric `json:"sandboxes"`
}

// TemplateBuildLogsResponse defines model for TemplateBuildLogsResponse.
type TemplateBuildLogsResponse struct {
	// LogEntries Build logs structured
	LogEntries []BuildLogEntry `json:"logEntries"`
}

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N500 defines model for 500.
type N500 = Error

// V1SandboxesMetricsParams defines parameters for V1SandboxesMetrics.
type V1SandboxesMetricsParams struct {
	// TeamID Team ID that owns the sandboxes
	TeamID string `form:"teamID" json:"teamID"`

	// SandboxIds List of sandbox IDs (max 100)
	SandboxIds []string `form:"sandbox_ids" json:"sandbox_ids"`
}

// V1SandboxLogsParams defines parameters for V1SandboxLogs.
type V1SandboxLogsParams struct {
	TeamID string `form:"teamID" json:"teamID"`

	// Start Starting timestamp of the logs that should be returned in milliseconds
	Start *int64 `form:"start,omitempty" json:"start,omitempty"`

	// End Ending timestamp of the logs that should be returned in milliseconds
	End *int64 `form:"end,omitempty" json:"end,omitempty"`

	// Limit Maximum number of logs that should be returned
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction Direction of the logs that should be returned. Defaults to forward
	Direction *V1SandboxLogsParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`
}

// V1SandboxLogsParamsDirection defines parameters for V1SandboxLogs.
type V1SandboxLogsParamsDirection string

// V1SandboxMetricsParams defines parameters for V1SandboxMetrics.
type V1SandboxMetricsParams struct {
	// TeamID Team ID that owns the sandbox
	TeamID string `form:"teamID" json:"teamID"`

	// Start Start time in Unix seconds
	Start *int64 `form:"start,omitempty" json:"start,omitempty"`

	// End End time in Unix seconds
	End *int64 `form:"end,omitempty" json:"end,omitempty"`
}

// V1TemplateBuildLogsParams defines parameters for V1TemplateBuildLogs.
type V1TemplateBuildLogsParams struct {
	OrchestratorID *string `form:"orchestratorID,omitempty" json:"orchestratorID,omitempty"`
	TemplateID     string  `form:"templateID" json:"templateID"`

	// Offset Index of the starting build log that should be returned with the template
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Start Starting timestamp of the logs that should be returned in milliseconds
	Start *int64 `form:"start,omitempty" json:"start,omitempty"`

	// End Ending timestamp of the logs that should be returned in milliseconds
	End *int64 `form:"end,omitempty" json:"end,omitempty"`

	// Limit Maximum number of logs that should be returned
	Limit     *int32                              `form:"limit,omitempty" json:"limit,omitempty"`
	Direction *V1TemplateBuildLogsParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`
	Level     *LogLevel                           `form:"level,omitempty" json:"level,omitempty"`
}

// V1TemplateBuildLogsParamsDirection defines parameters for V1TemplateBuildLogs.
type V1TemplateBuildLogsParamsDirection string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheckMachine request
	HealthCheckMachine(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1Info request
	V1Info(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1SandboxesMetrics request
	V1SandboxesMetrics(ctx context.Context, params *V1SandboxesMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1SandboxLogs request
	V1SandboxLogs(ctx context.Context, sandboxID string, params *V1SandboxLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1SandboxMetrics request
	V1SandboxMetrics(ctx context.Context, sandboxID string, params *V1SandboxMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1ServiceDiscovery request
	V1ServiceDiscovery(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1ServiceDiscoveryGetOrchestrators request
	V1ServiceDiscoveryGetOrchestrators(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1TemplateBuildLogs request
	V1TemplateBuildLogs(ctx context.Context, buildID string, params *V1TemplateBuildLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheckMachine(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckMachineRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1Info(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1InfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1SandboxesMetrics(ctx context.Context, params *V1SandboxesMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1SandboxesMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1SandboxLogs(ctx context.Context, sandboxID string, params *V1SandboxLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1SandboxLogsRequest(c.Server, sandboxID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1SandboxMetrics(ctx context.Context, sandboxID string, params *V1SandboxMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1SandboxMetricsRequest(c.Server, sandboxID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1ServiceDiscovery(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1ServiceDiscoveryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1ServiceDiscoveryGetOrchestrators(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1ServiceDiscoveryGetOrchestratorsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1TemplateBuildLogs(ctx context.Context, buildID string, params *V1TemplateBuildLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1TemplateBuildLogsRequest(c.Server, buildID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthCheckMachineRequest generates requests for HealthCheckMachine
func NewHealthCheckMachineRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health/machine")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1InfoRequest generates requests for V1Info
func NewV1InfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1SandboxesMetricsRequest generates requests for V1SandboxesMetrics
func NewV1SandboxesMetricsRequest(server string, params *V1SandboxesMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sandboxes/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamID", runtime.ParamLocationQuery, params.TeamID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sandbox_ids", runtime.ParamLocationQuery, params.SandboxIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1SandboxLogsRequest generates requests for V1SandboxLogs
func NewV1SandboxLogsRequest(server string, sandboxID string, params *V1SandboxLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sandboxes/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamID", runtime.ParamLocationQuery, params.TeamID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1SandboxMetricsRequest generates requests for V1SandboxMetrics
func NewV1SandboxMetricsRequest(server string, sandboxID string, params *V1SandboxMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sandboxes/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamID", runtime.ParamLocationQuery, params.TeamID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1ServiceDiscoveryRequest generates requests for V1ServiceDiscovery
func NewV1ServiceDiscoveryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/service-discovery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1ServiceDiscoveryGetOrchestratorsRequest generates requests for V1ServiceDiscoveryGetOrchestrators
func NewV1ServiceDiscoveryGetOrchestratorsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/service-discovery/nodes/orchestrators")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1TemplateBuildLogsRequest generates requests for V1TemplateBuildLogs
func NewV1TemplateBuildLogsRequest(server string, buildID string, params *V1TemplateBuildLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/templates/builds/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrchestratorID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orchestratorID", runtime.ParamLocationQuery, *params.OrchestratorID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "templateID", runtime.ParamLocationQuery, params.TemplateID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// HealthCheckWithResponse request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// HealthCheckMachineWithResponse request
	HealthCheckMachineWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckMachineResponse, error)

	// V1InfoWithResponse request
	V1InfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*V1InfoResponse, error)

	// V1SandboxesMetricsWithResponse request
	V1SandboxesMetricsWithResponse(ctx context.Context, params *V1SandboxesMetricsParams, reqEditors ...RequestEditorFn) (*V1SandboxesMetricsResponse, error)

	// V1SandboxLogsWithResponse request
	V1SandboxLogsWithResponse(ctx context.Context, sandboxID string, params *V1SandboxLogsParams, reqEditors ...RequestEditorFn) (*V1SandboxLogsResponse, error)

	// V1SandboxMetricsWithResponse request
	V1SandboxMetricsWithResponse(ctx context.Context, sandboxID string, params *V1SandboxMetricsParams, reqEditors ...RequestEditorFn) (*V1SandboxMetricsResponse, error)

	// V1ServiceDiscoveryWithResponse request
	V1ServiceDiscoveryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*V1ServiceDiscoveryResponse, error)

	// V1ServiceDiscoveryGetOrchestratorsWithResponse request
	V1ServiceDiscoveryGetOrchestratorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*V1ServiceDiscoveryGetOrchestratorsResponse, error)

	// V1TemplateBuildLogsWithResponse request
	V1TemplateBuildLogsWithResponse(ctx context.Context, buildID string, params *V1TemplateBuildLogsParams, reqEditors ...RequestEditorFn) (*V1TemplateBuildLogsResponse, error)
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HealthCheckMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1InfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterNodeInfo
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r V1InfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1InfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1SandboxesMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxesWithMetrics
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r V1SandboxesMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1SandboxesMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1SandboxLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxLogsResponse
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r V1SandboxLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1SandboxLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1SandboxMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SandboxMetric
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r V1SandboxMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1SandboxMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1ServiceDiscoveryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterServiceDiscovery
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r V1ServiceDiscoveryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1ServiceDiscoveryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1ServiceDiscoveryGetOrchestratorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClusterOrchestratorNode
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r V1ServiceDiscoveryGetOrchestratorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1ServiceDiscoveryGetOrchestratorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1TemplateBuildLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateBuildLogsResponse
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r V1TemplateBuildLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1TemplateBuildLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// HealthCheckMachineWithResponse request returning *HealthCheckMachineResponse
func (c *ClientWithResponses) HealthCheckMachineWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckMachineResponse, error) {
	rsp, err := c.HealthCheckMachine(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckMachineResponse(rsp)
}

// V1InfoWithResponse request returning *V1InfoResponse
func (c *ClientWithResponses) V1InfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*V1InfoResponse, error) {
	rsp, err := c.V1Info(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1InfoResponse(rsp)
}

// V1SandboxesMetricsWithResponse request returning *V1SandboxesMetricsResponse
func (c *ClientWithResponses) V1SandboxesMetricsWithResponse(ctx context.Context, params *V1SandboxesMetricsParams, reqEditors ...RequestEditorFn) (*V1SandboxesMetricsResponse, error) {
	rsp, err := c.V1SandboxesMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1SandboxesMetricsResponse(rsp)
}

// V1SandboxLogsWithResponse request returning *V1SandboxLogsResponse
func (c *ClientWithResponses) V1SandboxLogsWithResponse(ctx context.Context, sandboxID string, params *V1SandboxLogsParams, reqEditors ...RequestEditorFn) (*V1SandboxLogsResponse, error) {
	rsp, err := c.V1SandboxLogs(ctx, sandboxID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1SandboxLogsResponse(rsp)
}

// V1SandboxMetricsWithResponse request returning *V1SandboxMetricsResponse
func (c *ClientWithResponses) V1SandboxMetricsWithResponse(ctx context.Context, sandboxID string, params *V1SandboxMetricsParams, reqEditors ...RequestEditorFn) (*V1SandboxMetricsResponse, error) {
	rsp, err := c.V1SandboxMetrics(ctx, sandboxID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1SandboxMetricsResponse(rsp)
}

// V1ServiceDiscoveryWithResponse request returning *V1ServiceDiscoveryResponse
func (c *ClientWithResponses) V1ServiceDiscoveryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*V1ServiceDiscoveryResponse, error) {
	rsp, err := c.V1ServiceDiscovery(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1ServiceDiscoveryResponse(rsp)
}

// V1ServiceDiscoveryGetOrchestratorsWithResponse request returning *V1ServiceDiscoveryGetOrchestratorsResponse
func (c *ClientWithResponses) V1ServiceDiscoveryGetOrchestratorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*V1ServiceDiscoveryGetOrchestratorsResponse, error) {
	rsp, err := c.V1ServiceDiscoveryGetOrchestrators(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1ServiceDiscoveryGetOrchestratorsResponse(rsp)
}

// V1TemplateBuildLogsWithResponse request returning *V1TemplateBuildLogsResponse
func (c *ClientWithResponses) V1TemplateBuildLogsWithResponse(ctx context.Context, buildID string, params *V1TemplateBuildLogsParams, reqEditors ...RequestEditorFn) (*V1TemplateBuildLogsResponse, error) {
	rsp, err := c.V1TemplateBuildLogs(ctx, buildID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1TemplateBuildLogsResponse(rsp)
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHealthCheckMachineResponse parses an HTTP response from a HealthCheckMachineWithResponse call
func ParseHealthCheckMachineResponse(rsp *http.Response) (*HealthCheckMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseV1InfoResponse parses an HTTP response from a V1InfoWithResponse call
func ParseV1InfoResponse(rsp *http.Response) (*V1InfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1InfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterNodeInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseV1SandboxesMetricsResponse parses an HTTP response from a V1SandboxesMetricsWithResponse call
func ParseV1SandboxesMetricsResponse(rsp *http.Response) (*V1SandboxesMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1SandboxesMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxesWithMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseV1SandboxLogsResponse parses an HTTP response from a V1SandboxLogsWithResponse call
func ParseV1SandboxLogsResponse(rsp *http.Response) (*V1SandboxLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1SandboxLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxLogsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseV1SandboxMetricsResponse parses an HTTP response from a V1SandboxMetricsWithResponse call
func ParseV1SandboxMetricsResponse(rsp *http.Response) (*V1SandboxMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1SandboxMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SandboxMetric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseV1ServiceDiscoveryResponse parses an HTTP response from a V1ServiceDiscoveryWithResponse call
func ParseV1ServiceDiscoveryResponse(rsp *http.Response) (*V1ServiceDiscoveryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1ServiceDiscoveryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterServiceDiscovery
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseV1ServiceDiscoveryGetOrchestratorsResponse parses an HTTP response from a V1ServiceDiscoveryGetOrchestratorsWithResponse call
func ParseV1ServiceDiscoveryGetOrchestratorsResponse(rsp *http.Response) (*V1ServiceDiscoveryGetOrchestratorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1ServiceDiscoveryGetOrchestratorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClusterOrchestratorNode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseV1TemplateBuildLogsResponse parses an HTTP response from a V1TemplateBuildLogsWithResponse call
func ParseV1TemplateBuildLogsResponse(rsp *http.Response) (*V1TemplateBuildLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1TemplateBuildLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateBuildLogsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
