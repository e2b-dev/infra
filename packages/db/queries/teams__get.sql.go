// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: teams__get.sql

package queries

import (
	"context"

	"github.com/google/uuid"
)

const getTeamWithTierByAPIKeyWithUpdateLastUsed = `-- name: GetTeamWithTierByAPIKeyWithUpdateLastUsed :one
UPDATE "public"."team_api_keys" tak
SET last_used = now()
FROM "public"."teams" t
         JOIN "public"."tiers" tier ON t.tier = tier.id
         LEFT JOIN LATERAL (
    SELECT COALESCE(SUM(extra_concurrent_sandboxes),0)::bigint           as extra_concurrent_sandboxes,
           COALESCE(SUM(extra_concurrent_template_builds),0)::bigint     as extra_concurrent_template_builds,
           COALESCE(SUM(extra_max_vcpu),0)::bigint                       as extra_max_vcpu,
           COALESCE(SUM(extra_max_ram_mb),0)::bigint                     as extra_max_ram_mb,
           COALESCE(SUM(extra_disk_mb),0)::bigint                        as extra_disk_mb
    FROM "public"."addons" addon
    WHERE addon.team_id = t.id
      AND addon.valid_from <= now()
      AND (addon.valid_to IS NULL OR addon.valid_to > now())
    ) a ON true
WHERE tak.team_id = t.id
  AND tak.api_key_hash = $1
RETURNING t.id, t.created_at, t.is_blocked, t.name, t.tier, t.email, t.is_banned, t.blocked_reason, t.cluster_id, tier.id, tier.name, tier.disk_mb, tier.concurrent_instances, tier.max_length_hours, tier.max_vcpu, tier.max_ram_mb, tier.concurrent_template_builds, a.extra_concurrent_sandboxes, a.extra_concurrent_template_builds, a.extra_max_vcpu, a.extra_max_ram_mb, a.extra_disk_mb
`

type GetTeamWithTierByAPIKeyWithUpdateLastUsedRow struct {
	Team                          Team
	Tier                          Tier
	ExtraConcurrentSandboxes      int64
	ExtraConcurrentTemplateBuilds int64
	ExtraMaxVcpu                  int64
	ExtraMaxRamMb                 int64
	ExtraDiskMb                   int64
}

func (q *Queries) GetTeamWithTierByAPIKeyWithUpdateLastUsed(ctx context.Context, apiKeyHash string) (GetTeamWithTierByAPIKeyWithUpdateLastUsedRow, error) {
	row := q.db.QueryRow(ctx, getTeamWithTierByAPIKeyWithUpdateLastUsed, apiKeyHash)
	var i GetTeamWithTierByAPIKeyWithUpdateLastUsedRow
	err := row.Scan(
		&i.Team.ID,
		&i.Team.CreatedAt,
		&i.Team.IsBlocked,
		&i.Team.Name,
		&i.Team.Tier,
		&i.Team.Email,
		&i.Team.IsBanned,
		&i.Team.BlockedReason,
		&i.Team.ClusterID,
		&i.Tier.ID,
		&i.Tier.Name,
		&i.Tier.DiskMb,
		&i.Tier.ConcurrentInstances,
		&i.Tier.MaxLengthHours,
		&i.Tier.MaxVcpu,
		&i.Tier.MaxRamMb,
		&i.Tier.ConcurrentTemplateBuilds,
		&i.ExtraConcurrentSandboxes,
		&i.ExtraConcurrentTemplateBuilds,
		&i.ExtraMaxVcpu,
		&i.ExtraMaxRamMb,
		&i.ExtraDiskMb,
	)
	return i, err
}

const getTeamWithTierByTeamAndUser = `-- name: GetTeamWithTierByTeamAndUser :one
SELECT t.id, t.created_at, t.is_blocked, t.name, t.tier, t.email, t.is_banned, t.blocked_reason, t.cluster_id, tier.id, tier.name, tier.disk_mb, tier.concurrent_instances, tier.max_length_hours, tier.max_vcpu, tier.max_ram_mb, tier.concurrent_template_builds, a.extra_concurrent_sandboxes, a.extra_concurrent_template_builds, a.extra_max_vcpu, a.extra_max_ram_mb, a.extra_disk_mb
FROM "public"."teams" t
JOIN "public"."tiers" tier ON t.tier = tier.id
JOIN "public"."users_teams" ut ON ut.team_id = t.id
LEFT JOIN LATERAL (
    SELECT COALESCE(SUM(extra_concurrent_sandboxes),0)::bigint           as extra_concurrent_sandboxes,
           COALESCE(SUM(extra_concurrent_template_builds),0)::bigint     as extra_concurrent_template_builds,
           COALESCE(SUM(extra_max_vcpu),0)::bigint                       as extra_max_vcpu,
           COALESCE(SUM(extra_max_ram_mb),0)::bigint                     as extra_max_ram_mb,
           COALESCE(SUM(extra_disk_mb),0)::bigint                        as extra_disk_mb
    FROM "public"."addons" addon
    WHERE addon.team_id = t.id
      AND addon.valid_from <= now()
      AND (addon.valid_to IS NULL OR addon.valid_to > now())
    ) a ON true
WHERE ut.user_id = $1 AND t.id = $2
`

type GetTeamWithTierByTeamAndUserParams struct {
	UserID uuid.UUID
	ID     uuid.UUID
}

type GetTeamWithTierByTeamAndUserRow struct {
	Team                          Team
	Tier                          Tier
	ExtraConcurrentSandboxes      int64
	ExtraConcurrentTemplateBuilds int64
	ExtraMaxVcpu                  int64
	ExtraMaxRamMb                 int64
	ExtraDiskMb                   int64
}

func (q *Queries) GetTeamWithTierByTeamAndUser(ctx context.Context, arg GetTeamWithTierByTeamAndUserParams) (GetTeamWithTierByTeamAndUserRow, error) {
	row := q.db.QueryRow(ctx, getTeamWithTierByTeamAndUser, arg.UserID, arg.ID)
	var i GetTeamWithTierByTeamAndUserRow
	err := row.Scan(
		&i.Team.ID,
		&i.Team.CreatedAt,
		&i.Team.IsBlocked,
		&i.Team.Name,
		&i.Team.Tier,
		&i.Team.Email,
		&i.Team.IsBanned,
		&i.Team.BlockedReason,
		&i.Team.ClusterID,
		&i.Tier.ID,
		&i.Tier.Name,
		&i.Tier.DiskMb,
		&i.Tier.ConcurrentInstances,
		&i.Tier.MaxLengthHours,
		&i.Tier.MaxVcpu,
		&i.Tier.MaxRamMb,
		&i.Tier.ConcurrentTemplateBuilds,
		&i.ExtraConcurrentSandboxes,
		&i.ExtraConcurrentTemplateBuilds,
		&i.ExtraMaxVcpu,
		&i.ExtraMaxRamMb,
		&i.ExtraDiskMb,
	)
	return i, err
}

const getTeamsWithUsersTeamsWithTier = `-- name: GetTeamsWithUsersTeamsWithTier :many
SELECT t.id, t.created_at, t.is_blocked, t.name, t.tier, t.email, t.is_banned, t.blocked_reason, t.cluster_id, ut.id, ut.user_id, ut.team_id, ut.is_default, ut.added_by, ut.created_at, tier.id, tier.name, tier.disk_mb, tier.concurrent_instances, tier.max_length_hours, tier.max_vcpu, tier.max_ram_mb, tier.concurrent_template_builds, a.extra_concurrent_sandboxes, a.extra_concurrent_template_builds, a.extra_max_vcpu, a.extra_max_ram_mb, a.extra_disk_mb
FROM "public"."teams" t
         JOIN "public"."tiers" tier ON t.tier = tier.id
         JOIN "public"."users_teams" ut ON ut.team_id = t.id
         LEFT JOIN LATERAL (
    SELECT COALESCE(SUM(extra_concurrent_sandboxes),0)::bigint           as extra_concurrent_sandboxes,
           COALESCE(SUM(extra_concurrent_template_builds),0)::bigint     as extra_concurrent_template_builds,
           COALESCE(SUM(extra_max_vcpu),0)::bigint                       as extra_max_vcpu,
           COALESCE(SUM(extra_max_ram_mb),0)::bigint                     as extra_max_ram_mb,
           COALESCE(SUM(extra_disk_mb),0)::bigint                        as extra_disk_mb
    FROM "public"."addons" addon
    WHERE addon.team_id = t.id
      AND addon.valid_from <= now()
      AND (addon.valid_to IS NULL OR addon.valid_to > now())
    ) a ON true
WHERE ut.user_id = $1
`

type GetTeamsWithUsersTeamsWithTierRow struct {
	Team                          Team
	UsersTeam                     UsersTeam
	Tier                          Tier
	ExtraConcurrentSandboxes      int64
	ExtraConcurrentTemplateBuilds int64
	ExtraMaxVcpu                  int64
	ExtraMaxRamMb                 int64
	ExtraDiskMb                   int64
}

func (q *Queries) GetTeamsWithUsersTeamsWithTier(ctx context.Context, userID uuid.UUID) ([]GetTeamsWithUsersTeamsWithTierRow, error) {
	rows, err := q.db.Query(ctx, getTeamsWithUsersTeamsWithTier, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamsWithUsersTeamsWithTierRow
	for rows.Next() {
		var i GetTeamsWithUsersTeamsWithTierRow
		if err := rows.Scan(
			&i.Team.ID,
			&i.Team.CreatedAt,
			&i.Team.IsBlocked,
			&i.Team.Name,
			&i.Team.Tier,
			&i.Team.Email,
			&i.Team.IsBanned,
			&i.Team.BlockedReason,
			&i.Team.ClusterID,
			&i.UsersTeam.ID,
			&i.UsersTeam.UserID,
			&i.UsersTeam.TeamID,
			&i.UsersTeam.IsDefault,
			&i.UsersTeam.AddedBy,
			&i.UsersTeam.CreatedAt,
			&i.Tier.ID,
			&i.Tier.Name,
			&i.Tier.DiskMb,
			&i.Tier.ConcurrentInstances,
			&i.Tier.MaxLengthHours,
			&i.Tier.MaxVcpu,
			&i.Tier.MaxRamMb,
			&i.Tier.ConcurrentTemplateBuilds,
			&i.ExtraConcurrentSandboxes,
			&i.ExtraConcurrentTemplateBuilds,
			&i.ExtraMaxVcpu,
			&i.ExtraMaxRamMb,
			&i.ExtraDiskMb,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
