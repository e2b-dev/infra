// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: create_new_snapshot.sql

package queries

import (
	"context"

	"github.com/e2b-dev/infra/packages/db/types"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const upsertSnapshotEnvAndBuild = `-- name: UpsertSnapshotEnvAndBuild :one
WITH updated_snapshot AS (
    UPDATE "public"."snapshots" s
        SET
            metadata           = $9,
            sandbox_started_at = $10,
            origin_node_id     = $7,
            auto_pause         = $11,
            config             = $12
        FROM "public"."envs" e
        WHERE
            s.sandbox_id = $13
                AND e.id      = s.env_id
                AND e.team_id = $14
        RETURNING s.env_id
),
 inserted_env AS (
     INSERT INTO "public"."envs" (id, public, created_by, team_id, updated_at)
         SELECT $15, FALSE, NULL, $14, now()
         WHERE NOT EXISTS (SELECT 1 FROM updated_snapshot)
         ON CONFLICT (id) DO NOTHING
         RETURNING id AS env_id
 ),
 inserted_snapshot AS (
     INSERT INTO "public"."snapshots" (
                                       sandbox_id,
                                       base_env_id,
                                       team_id,
                                       env_id,
                                       metadata,
                                       sandbox_started_at,
                                       env_secure,
                                       allow_internet_access,
                                       origin_node_id,
                                       auto_pause,
                                       config
         )
         SELECT
             $13,
             $16,
             $14,
             COALESCE(
                     (SELECT env_id FROM inserted_env LIMIT 1),
                     $15      -- env already existed
             ) AS env_id,
             $9,
             $10,
             $17,
             $18,
             $7,
             $11,
             $12
         WHERE NOT EXISTS (SELECT 1 FROM updated_snapshot)
         RETURNING env_id
 ),
 -- If we updated an existing snapshot, use that env_id.
 -- Otherwise use env_id from the newly inserted snapshot.
 final_env AS (
     SELECT env_id FROM updated_snapshot
     UNION ALL
     SELECT env_id FROM inserted_snapshot
 )

INSERT INTO "public"."env_builds" (
    env_id,
    vcpu,
    ram_mb,
    free_disk_size_mb,
    kernel_version,
    firecracker_version,
    envd_version,
    status,
    cluster_node_id,
    total_disk_size_mb,
    updated_at
)
SELECT
    (SELECT env_id FROM final_env LIMIT 1),
    $1,
    $2,
    0,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    now()
RETURNING id as build_id, env_id as template_id
`

type UpsertSnapshotEnvAndBuildParams struct {
	Vcpu                int64
	RamMb               int64
	KernelVersion       string
	FirecrackerVersion  string
	EnvdVersion         *string
	Status              string
	OriginNodeID        string
	TotalDiskSizeMb     *int64
	Metadata            types.JSONBStringMap
	StartedAt           pgtype.Timestamptz
	AutoPause           bool
	Config              *types.PausedSandboxConfig
	SandboxID           string
	TeamID              uuid.UUID
	TemplateID          string
	BaseTemplateID      string
	Secure              bool
	AllowInternetAccess *bool
}

type UpsertSnapshotEnvAndBuildRow struct {
	BuildID    uuid.UUID
	TemplateID string
}

// Try to update an existing snapshot
// otherwise insert a new one with a new env
// Create a new build for the snapshot
func (q *Queries) UpsertSnapshotEnvAndBuild(ctx context.Context, arg UpsertSnapshotEnvAndBuildParams) (UpsertSnapshotEnvAndBuildRow, error) {
	row := q.db.QueryRow(ctx, upsertSnapshotEnvAndBuild,
		arg.Vcpu,
		arg.RamMb,
		arg.KernelVersion,
		arg.FirecrackerVersion,
		arg.EnvdVersion,
		arg.Status,
		arg.OriginNodeID,
		arg.TotalDiskSizeMb,
		arg.Metadata,
		arg.StartedAt,
		arg.AutoPause,
		arg.Config,
		arg.SandboxID,
		arg.TeamID,
		arg.TemplateID,
		arg.BaseTemplateID,
		arg.Secure,
		arg.AllowInternetAccess,
	)
	var i UpsertSnapshotEnvAndBuildRow
	err := row.Scan(&i.BuildID, &i.TemplateID)
	return i, err
}
