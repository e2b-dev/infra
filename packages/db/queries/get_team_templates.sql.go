// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: get_team_templates.sql

package queries

import (
	"context"

	"github.com/google/uuid"
)

const getTeamTemplates = `-- name: GetTeamTemplates :many
SELECT e.id, e.created_at, e.updated_at, e.public, e.build_count, e.spawn_count, e.last_spawned_at, e.team_id, e.created_by, e.cluster_id,
       COALESCE(eb.id, '00000000-0000-0000-0000-000000000000'::uuid) as build_id,
       COALESCE(eb.vcpu, 0) as build_vcpu,
       COALESCE(eb.ram_mb, 0) as build_ram_mb,
       eb.total_disk_size_mb as build_total_disk_size_mb,
       eb.envd_version as build_envd_version,
       COALESCE(eb.firecracker_version, 'N/A') as build_firecracker_version,
       COALESCE(latest_build.status, 'waiting') as build_status,
       u.id as creator_id, u.email as creator_email,
       COALESCE(ea.aliases, ARRAY[]::text[])::text[] AS aliases,
       COALESCE(ea.names, ARRAY[]::text[])::text[] AS names
FROM public.envs AS e
LEFT JOIN auth.users AS u ON u.id = e.created_by
LEFT JOIN LATERAL (
    SELECT 
        ARRAY_AGG(alias ORDER BY alias) AS aliases,
        ARRAY_AGG(CASE WHEN namespace IS NOT NULL THEN namespace || '/' || alias ELSE alias END ORDER BY alias) AS names
    FROM public.env_aliases
    WHERE env_id = e.id
) ea ON TRUE
LEFT JOIN LATERAL (
    SELECT b.id, b.created_at, b.updated_at, b.finished_at, b.status, b.dockerfile, b.start_cmd, b.vcpu, b.ram_mb, b.free_disk_size_mb, b.total_disk_size_mb, b.kernel_version, b.firecracker_version, b.env_id, b.envd_version, b.ready_cmd, b.cluster_node_id, b.reason, b.version, b.cpu_architecture, b.cpu_family, b.cpu_model, b.cpu_model_name, b.cpu_flags
    FROM public.env_build_assignments AS ba
    JOIN public.env_builds AS b ON b.id = ba.build_id
    WHERE ba.env_id = e.id AND ba.tag = 'default'
    ORDER BY ba.created_at DESC
    LIMIT 1
) latest_build ON TRUE
LEFT JOIN LATERAL (
    SELECT b.id, b.created_at, b.updated_at, b.finished_at, b.status, b.dockerfile, b.start_cmd, b.vcpu, b.ram_mb, b.free_disk_size_mb, b.total_disk_size_mb, b.kernel_version, b.firecracker_version, b.env_id, b.envd_version, b.ready_cmd, b.cluster_node_id, b.reason, b.version, b.cpu_architecture, b.cpu_family, b.cpu_model, b.cpu_model_name, b.cpu_flags
    FROM public.env_build_assignments AS ba
    JOIN public.env_builds AS b ON b.id = ba.build_id
    WHERE ba.env_id = e.id AND ba.tag = 'default' AND b.status = 'uploaded'
    ORDER BY ba.created_at DESC
    LIMIT 1
) eb ON TRUE
WHERE
  e.team_id = $1
  AND NOT EXISTS (
    SELECT 1
    FROM public.snapshots AS s
    WHERE s.env_id = e.id
  )
ORDER BY e.created_at ASC
`

type GetTeamTemplatesRow struct {
	Env                     Env
	BuildID                 uuid.UUID
	BuildVcpu               int64
	BuildRamMb              int64
	BuildTotalDiskSizeMb    *int64
	BuildEnvdVersion        *string
	BuildFirecrackerVersion string
	BuildStatus             string
	CreatorID               *uuid.UUID
	CreatorEmail            *string
	Aliases                 []string
	Names                   []string
}

func (q *Queries) GetTeamTemplates(ctx context.Context, teamID uuid.UUID) ([]GetTeamTemplatesRow, error) {
	rows, err := q.db.Query(ctx, getTeamTemplates, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamTemplatesRow
	for rows.Next() {
		var i GetTeamTemplatesRow
		if err := rows.Scan(
			&i.Env.ID,
			&i.Env.CreatedAt,
			&i.Env.UpdatedAt,
			&i.Env.Public,
			&i.Env.BuildCount,
			&i.Env.SpawnCount,
			&i.Env.LastSpawnedAt,
			&i.Env.TeamID,
			&i.Env.CreatedBy,
			&i.Env.ClusterID,
			&i.BuildID,
			&i.BuildVcpu,
			&i.BuildRamMb,
			&i.BuildTotalDiskSizeMb,
			&i.BuildEnvdVersion,
			&i.BuildFirecrackerVersion,
			&i.BuildStatus,
			&i.CreatorID,
			&i.CreatorEmail,
			&i.Aliases,
			&i.Names,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
