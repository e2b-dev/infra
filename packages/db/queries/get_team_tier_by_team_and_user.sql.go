// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: get_team_tier_by_team_and_user.sql

package queries

import (
	"context"

	"github.com/google/uuid"
)

const getTeamWithTierByTeamAndUser = `-- name: GetTeamWithTierByTeamAndUser :one
SELECT t.id, t.created_at, t.is_blocked, t.name, t.tier, t.email, t.is_banned, t.blocked_reason, t.cluster_id, tier.id, tier.name, tier.disk_mb, tier.concurrent_instances, tier.max_length_hours, tier.max_vcpu, tier.max_ram_mb
FROM "public"."teams" t
JOIN "public"."tiers" tier ON t.tier = tier.id
JOIN "public"."users_teams" ut ON ut.team_id = t.id
WHERE ut.user_id = $1 AND t.id = $2
`

type GetTeamWithTierByTeamAndUserParams struct {
	UserID uuid.UUID
	ID     uuid.UUID
}

type GetTeamWithTierByTeamAndUserRow struct {
	Team Team
	Tier Tier
}

func (q *Queries) GetTeamWithTierByTeamAndUser(ctx context.Context, arg GetTeamWithTierByTeamAndUserParams) (GetTeamWithTierByTeamAndUserRow, error) {
	row := q.db.QueryRow(ctx, getTeamWithTierByTeamAndUser, arg.UserID, arg.ID)
	var i GetTeamWithTierByTeamAndUserRow
	err := row.Scan(
		&i.Team.ID,
		&i.Team.CreatedAt,
		&i.Team.IsBlocked,
		&i.Team.Name,
		&i.Team.Tier,
		&i.Team.Email,
		&i.Team.IsBanned,
		&i.Team.BlockedReason,
		&i.Team.ClusterID,
		&i.Tier.ID,
		&i.Tier.Name,
		&i.Tier.DiskMb,
		&i.Tier.ConcurrentInstances,
		&i.Tier.MaxLengthHours,
		&i.Tier.MaxVcpu,
		&i.Tier.MaxRamMb,
	)
	return i, err
}
