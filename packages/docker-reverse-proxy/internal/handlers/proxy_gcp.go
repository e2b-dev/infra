package handlers

import (
	"fmt"
	"log"
	"net/http"
	"strings"

	"github.com/e2b-dev/infra/packages/docker-reverse-proxy/internal/constants"
	"github.com/e2b-dev/infra/packages/docker-reverse-proxy/internal/utils"
	"github.com/e2b-dev/infra/packages/shared/pkg/consts"
)

type GCPProxyHandler struct {
	apiStore *APIStore
}

func NewGCPProxyHandler(apiStore *APIStore) *GCPProxyHandler {
	return &GCPProxyHandler{
		apiStore: apiStore,
	}
}

func (g *GCPProxyHandler) ValidatePath(path string) bool {
	repoPrefix := "/v2/e2b/custom-envs/"
	realRepoPrefix := fmt.Sprintf("/v2/%s/%s/", consts.GCPProject, consts.DockerRegistry)
	
	return strings.HasPrefix(path, repoPrefix) || strings.HasPrefix(path, realRepoPrefix)
}

func (g *GCPProxyHandler) TransformPath(originalPath string, templateID string) string {
	repoPrefix := "/v2/e2b/custom-envs/"
	realRepoPrefix := fmt.Sprintf("/v2/%s/%s/", consts.GCPProject, consts.DockerRegistry)
	
	return strings.Replace(originalPath, repoPrefix, realRepoPrefix, 1)
}

func (g *GCPProxyHandler) GetExpectedTagFormat(templateID string, buildID string) string {
	return fmt.Sprintf("%s:%s", templateID, buildID)
}

func (g *GCPProxyHandler) HandleProxy(w http.ResponseWriter, req *http.Request, token *AuthToken) error {
	path := req.URL.String()
	
	// Allow access to the GCP artifact uploads.
	// The url is generated by repository and sent as a Location header from the /blobs/upload request
	// https://distribution.github.io/distribution/spec/api/#starting-an-upload
	// Other methods than PATCH require the Authorization header
	if strings.HasPrefix(path, constants.GCPArtifactUploadPrefix) {
		g.apiStore.ServeHTTP(w, req)
		return nil
	}

	repoPrefix := "/v2/e2b/custom-envs/"
	realRepoPrefix := fmt.Sprintf("/v2/%s/%s/", consts.GCPProject, consts.DockerRegistry)
	
	if !g.ValidatePath(path) {
		// The request shouldn't need any other endpoints, we deny access
		log.Printf("No matching route found for path: %s\n", path)
		w.WriteHeader(http.StatusForbidden)
		return fmt.Errorf("no matching route found for path: %s", path)
	}

	templateID := token.TemplateID

	// Uploading blobs doesn't have the template ID in the path
	if strings.HasPrefix(path, fmt.Sprintf("%spkg/blobs/uploads/", realRepoPrefix)) {
		g.apiStore.ServeHTTP(w, req)
		return nil
	}

	pathInRepo := strings.TrimPrefix(path, repoPrefix)
	templateWithBuildID := strings.Split(strings.Split(pathInRepo, "/")[0], ":")

	// If the template ID in the path is different from the token template ID, deny access
	if templateWithBuildID[0] != templateID {
		w.WriteHeader(http.StatusForbidden)
		log.Printf("Access denied for template: %s\n", templateID)
		return fmt.Errorf("access denied for template: %s", templateID)
	}

	// Set the host and access token for the real docker registry
	req.URL.Path = g.TransformPath(req.URL.Path, templateID)

	// Set the Authorization header for the request to the real docker registry
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token.DockerToken))

	g.apiStore.ServeHTTP(w, req)
	return nil
}
