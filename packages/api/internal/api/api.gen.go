// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AccessTokenAuthScopes    = "AccessTokenAuth.Scopes"
	AdminTokenAuthScopes     = "AdminTokenAuth.Scopes"
	ApiKeyAuthScopes         = "ApiKeyAuth.Scopes"
	Supabase1TokenAuthScopes = "Supabase1TokenAuth.Scopes"
	Supabase2TeamAuthScopes  = "Supabase2TeamAuth.Scopes"
)

// Defines values for AWSRegistryType.
const (
	Aws AWSRegistryType = "aws"
)

// Defines values for GCPRegistryType.
const (
	Gcp GCPRegistryType = "gcp"
)

// Defines values for GeneralRegistryType.
const (
	Registry GeneralRegistryType = "registry"
)

// Defines values for LogLevel.
const (
	LogLevelDebug LogLevel = "debug"
	LogLevelError LogLevel = "error"
	LogLevelInfo  LogLevel = "info"
	LogLevelWarn  LogLevel = "warn"
)

// Defines values for LogsDirection.
const (
	LogsDirectionBackward LogsDirection = "backward"
	LogsDirectionForward  LogsDirection = "forward"
)

// Defines values for LogsSource.
const (
	LogsSourcePersistent LogsSource = "persistent"
	LogsSourceTemporary  LogsSource = "temporary"
)

// Defines values for NodeStatus.
const (
	NodeStatusConnecting NodeStatus = "connecting"
	NodeStatusDraining   NodeStatus = "draining"
	NodeStatusReady      NodeStatus = "ready"
	NodeStatusUnhealthy  NodeStatus = "unhealthy"
)

// Defines values for SandboxAutoResumePolicy.
const (
	Any SandboxAutoResumePolicy = "any"
	Off SandboxAutoResumePolicy = "off"
)

// Defines values for SandboxState.
const (
	Paused  SandboxState = "paused"
	Running SandboxState = "running"
)

// Defines values for TemplateBuildStatus.
const (
	TemplateBuildStatusBuilding TemplateBuildStatus = "building"
	TemplateBuildStatusError    TemplateBuildStatus = "error"
	TemplateBuildStatusReady    TemplateBuildStatus = "ready"
	TemplateBuildStatusWaiting  TemplateBuildStatus = "waiting"
)

// Defines values for GetTeamsTeamIDMetricsMaxParamsMetric.
const (
	ConcurrentSandboxes GetTeamsTeamIDMetricsMaxParamsMetric = "concurrent_sandboxes"
	SandboxStartRate    GetTeamsTeamIDMetricsMaxParamsMetric = "sandbox_start_rate"
)

// AWSRegistry defines model for AWSRegistry.
type AWSRegistry struct {
	// AwsAccessKeyId AWS Access Key ID for ECR authentication
	AwsAccessKeyId string `json:"awsAccessKeyId"`

	// AwsRegion AWS Region where the ECR registry is located
	AwsRegion string `json:"awsRegion"`

	// AwsSecretAccessKey AWS Secret Access Key for ECR authentication
	AwsSecretAccessKey string `json:"awsSecretAccessKey"`

	// Type Type of registry authentication
	Type AWSRegistryType `json:"type"`
}

// AWSRegistryType Type of registry authentication
type AWSRegistryType string

// AdminSandboxKillResult defines model for AdminSandboxKillResult.
type AdminSandboxKillResult struct {
	// FailedCount Number of sandboxes that failed to kill
	FailedCount int `json:"failedCount"`

	// KilledCount Number of sandboxes successfully killed
	KilledCount int `json:"killedCount"`
}

// AssignTemplateTagsRequest defines model for AssignTemplateTagsRequest.
type AssignTemplateTagsRequest struct {
	// Tags Tags to assign to the template
	Tags []string `json:"tags"`

	// Target Target template in "name:tag" format
	Target string `json:"target"`
}

// AssignedTemplateTags defines model for AssignedTemplateTags.
type AssignedTemplateTags struct {
	// BuildID Identifier of the build associated with these tags
	BuildID openapi_types.UUID `json:"buildID"`

	// Tags Assigned tags of the template
	Tags []string `json:"tags"`
}

// BuildLogEntry defines model for BuildLogEntry.
type BuildLogEntry struct {
	// Level State of the sandbox
	Level LogLevel `json:"level"`

	// Message Log message content
	Message string `json:"message"`

	// Step Step in the build process related to the log entry
	Step *string `json:"step,omitempty"`

	// Timestamp Timestamp of the log entry
	Timestamp time.Time `json:"timestamp"`
}

// BuildStatusReason defines model for BuildStatusReason.
type BuildStatusReason struct {
	// LogEntries Log entries related to the status reason
	LogEntries *[]BuildLogEntry `json:"logEntries,omitempty"`

	// Message Message with the status reason, currently reporting only for error status
	Message string `json:"message"`

	// Step Step that failed
	Step *string `json:"step,omitempty"`
}

// CPUCount CPU cores for the sandbox
type CPUCount = int32

// ConnectSandbox defines model for ConnectSandbox.
type ConnectSandbox struct {
	// Timeout Timeout in seconds from the current time after which the sandbox should expire
	Timeout int32 `json:"timeout"`
}

// CreatedAccessToken defines model for CreatedAccessToken.
type CreatedAccessToken struct {
	// CreatedAt Timestamp of access token creation
	CreatedAt time.Time `json:"createdAt"`

	// Id Identifier of the access token
	Id   openapi_types.UUID       `json:"id"`
	Mask IdentifierMaskingDetails `json:"mask"`

	// Name Name of the access token
	Name string `json:"name"`

	// Token The fully created access token
	Token string `json:"token"`
}

// CreatedTeamAPIKey defines model for CreatedTeamAPIKey.
type CreatedTeamAPIKey struct {
	// CreatedAt Timestamp of API key creation
	CreatedAt time.Time `json:"createdAt"`
	CreatedBy *TeamUser `json:"createdBy"`

	// Id Identifier of the API key
	Id openapi_types.UUID `json:"id"`

	// Key Raw value of the API key
	Key string `json:"key"`

	// LastUsed Last time this API key was used
	LastUsed *time.Time               `json:"lastUsed"`
	Mask     IdentifierMaskingDetails `json:"mask"`

	// Name Name of the API key
	Name string `json:"name"`
}

// DeleteTemplateTagsRequest defines model for DeleteTemplateTagsRequest.
type DeleteTemplateTagsRequest struct {
	// Name Name of the template
	Name string `json:"name"`

	// Tags Tags to delete
	Tags []string `json:"tags"`
}

// DiskMetrics defines model for DiskMetrics.
type DiskMetrics struct {
	// Device Device name
	Device string `json:"device"`

	// FilesystemType Filesystem type (e.g., ext4, xfs)
	FilesystemType string `json:"filesystemType"`

	// MountPoint Mount point of the disk
	MountPoint string `json:"mountPoint"`

	// TotalBytes Total space in bytes
	TotalBytes uint64 `json:"totalBytes"`

	// UsedBytes Used space in bytes
	UsedBytes uint64 `json:"usedBytes"`
}

// DiskSizeMB Disk size for the sandbox in MiB
type DiskSizeMB = int32

// EnvVars defines model for EnvVars.
type EnvVars map[string]string

// EnvdVersion Version of the envd running in the sandbox
type EnvdVersion = string

// Error defines model for Error.
type Error struct {
	// Code Error code
	Code int32 `json:"code"`

	// Message Error
	Message string `json:"message"`
}

// FromImageRegistry defines model for FromImageRegistry.
type FromImageRegistry struct {
	union json.RawMessage
}

// GCPRegistry defines model for GCPRegistry.
type GCPRegistry struct {
	// ServiceAccountJson Service Account JSON for GCP authentication
	ServiceAccountJson string `json:"serviceAccountJson"`

	// Type Type of registry authentication
	Type GCPRegistryType `json:"type"`
}

// GCPRegistryType Type of registry authentication
type GCPRegistryType string

// GeneralRegistry defines model for GeneralRegistry.
type GeneralRegistry struct {
	// Password Password to use for the registry
	Password string `json:"password"`

	// Type Type of registry authentication
	Type GeneralRegistryType `json:"type"`

	// Username Username to use for the registry
	Username string `json:"username"`
}

// GeneralRegistryType Type of registry authentication
type GeneralRegistryType string

// IdentifierMaskingDetails defines model for IdentifierMaskingDetails.
type IdentifierMaskingDetails struct {
	// MaskedValuePrefix Prefix used in masked version of the token or key
	MaskedValuePrefix string `json:"maskedValuePrefix"`

	// MaskedValueSuffix Suffix used in masked version of the token or key
	MaskedValueSuffix string `json:"maskedValueSuffix"`

	// Prefix Prefix that identifies the token or key type
	Prefix string `json:"prefix"`

	// ValueLength Length of the token or key
	ValueLength int `json:"valueLength"`
}

// ListedSandbox defines model for ListedSandbox.
type ListedSandbox struct {
	// Alias Alias of the template
	Alias *string `json:"alias,omitempty"`

	// ClientID Identifier of the client
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	ClientID string `json:"clientID"`

	// CpuCount CPU cores for the sandbox
	CpuCount CPUCount `json:"cpuCount"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB DiskSizeMB `json:"diskSizeMB"`

	// EndAt Time when the sandbox will expire
	EndAt time.Time `json:"endAt"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB         `json:"memoryMB"`
	Metadata *SandboxMetadata `json:"metadata,omitempty"`

	// SandboxID Identifier of the sandbox
	SandboxID string `json:"sandboxID"`

	// StartedAt Time when the sandbox was started
	StartedAt time.Time `json:"startedAt"`

	// State State of the sandbox
	State SandboxState `json:"state"`

	// TemplateID Identifier of the template from which is the sandbox created
	TemplateID string `json:"templateID"`
}

// LogLevel State of the sandbox
type LogLevel string

// LogsDirection Direction of the logs that should be returned
type LogsDirection string

// LogsSource Source of the logs that should be returned
type LogsSource string

// MachineInfo defines model for MachineInfo.
type MachineInfo struct {
	// CpuArchitecture CPU architecture of the node
	CpuArchitecture string `json:"cpuArchitecture"`

	// CpuFamily CPU family of the node
	CpuFamily string `json:"cpuFamily"`

	// CpuModel CPU model of the node
	CpuModel string `json:"cpuModel"`

	// CpuModelName CPU model name of the node
	CpuModelName string `json:"cpuModelName"`
}

// MaxTeamMetric Team metric with timestamp
type MaxTeamMetric struct {
	// Timestamp Timestamp of the metric entry
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Timestamp time.Time `json:"timestamp"`

	// TimestampUnix Timestamp of the metric entry in Unix time (seconds since epoch)
	TimestampUnix int64 `json:"timestampUnix"`

	// Value The maximum value of the requested metric in the given interval
	Value float32 `json:"value"`
}

// Mcp MCP configuration for the sandbox
type Mcp map[string]interface{}

// MemoryMB Memory for the sandbox in MiB
type MemoryMB = int32

// NewAccessToken defines model for NewAccessToken.
type NewAccessToken struct {
	// Name Name of the access token
	Name string `json:"name"`
}

// NewSandbox defines model for NewSandbox.
type NewSandbox struct {
	// AllowInternetAccess Allow sandbox to access the internet. When set to false, it behaves the same as specifying denyOut to 0.0.0.0/0 in the network config.
	AllowInternetAccess *bool `json:"allow_internet_access,omitempty"`

	// AutoPause Automatically pauses the sandbox after the timeout
	AutoPause *bool `json:"autoPause,omitempty"`

	// AutoResume Auto-resume policy for paused sandboxes. Default is off.
	AutoResume *SandboxAutoResumePolicy `json:"autoResume,omitempty"`
	EnvVars    *EnvVars                 `json:"envVars,omitempty"`

	// Mcp MCP configuration for the sandbox
	Mcp      *Mcp                  `json:"mcp"`
	Metadata *SandboxMetadata      `json:"metadata,omitempty"`
	Network  *SandboxNetworkConfig `json:"network,omitempty"`

	// Secure Secure all system communication with sandbox
	Secure *bool `json:"secure,omitempty"`

	// TemplateID Identifier of the required template
	TemplateID string `json:"templateID"`

	// Timeout Time to live for the sandbox in seconds.
	Timeout *int32 `json:"timeout,omitempty"`
}

// NewTeamAPIKey defines model for NewTeamAPIKey.
type NewTeamAPIKey struct {
	// Name Name of the API key
	Name string `json:"name"`
}

// Node defines model for Node.
type Node struct {
	// ClusterID Identifier of the cluster
	ClusterID string `json:"clusterID"`

	// Commit Commit of the orchestrator
	Commit string `json:"commit"`

	// CreateFails Number of sandbox create fails
	CreateFails uint64 `json:"createFails"`

	// CreateSuccesses Number of sandbox create successes
	CreateSuccesses uint64 `json:"createSuccesses"`

	// Id Identifier of the node
	Id          string      `json:"id"`
	MachineInfo MachineInfo `json:"machineInfo"`

	// Metrics Node metrics
	Metrics NodeMetrics `json:"metrics"`

	// NodeID Identifier of the nomad node
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	NodeID string `json:"nodeID"`

	// SandboxCount Number of sandboxes running on the node
	SandboxCount uint32 `json:"sandboxCount"`

	// SandboxStartingCount Number of starting Sandboxes
	SandboxStartingCount int `json:"sandboxStartingCount"`

	// ServiceInstanceID Service instance identifier of the node
	ServiceInstanceID string `json:"serviceInstanceID"`

	// Status Status of the node
	Status NodeStatus `json:"status"`

	// Version Version of the orchestrator
	Version string `json:"version"`
}

// NodeDetail defines model for NodeDetail.
type NodeDetail struct {
	// CachedBuilds List of cached builds id on the node
	CachedBuilds []string `json:"cachedBuilds"`

	// ClusterID Identifier of the cluster
	ClusterID string `json:"clusterID"`

	// Commit Commit of the orchestrator
	Commit string `json:"commit"`

	// CreateFails Number of sandbox create fails
	CreateFails uint64 `json:"createFails"`

	// CreateSuccesses Number of sandbox create successes
	CreateSuccesses uint64 `json:"createSuccesses"`

	// Id Identifier of the node
	Id          string      `json:"id"`
	MachineInfo MachineInfo `json:"machineInfo"`

	// Metrics Node metrics
	Metrics NodeMetrics `json:"metrics"`

	// NodeID Identifier of the nomad node
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	NodeID string `json:"nodeID"`

	// Sandboxes List of sandboxes running on the node
	Sandboxes []ListedSandbox `json:"sandboxes"`

	// ServiceInstanceID Service instance identifier of the node
	ServiceInstanceID string `json:"serviceInstanceID"`

	// Status Status of the node
	Status NodeStatus `json:"status"`

	// Version Version of the orchestrator
	Version string `json:"version"`
}

// NodeMetrics Node metrics
type NodeMetrics struct {
	// AllocatedCPU Number of allocated CPU cores
	AllocatedCPU uint32 `json:"allocatedCPU"`

	// AllocatedMemoryBytes Amount of allocated memory in bytes
	AllocatedMemoryBytes uint64 `json:"allocatedMemoryBytes"`

	// CpuCount Total number of CPU cores on the node
	CpuCount uint32 `json:"cpuCount"`

	// CpuPercent Node CPU usage percentage
	CpuPercent uint32 `json:"cpuPercent"`

	// Disks Detailed metrics for each disk/mount point
	Disks []DiskMetrics `json:"disks"`

	// MemoryTotalBytes Total node memory in bytes
	MemoryTotalBytes uint64 `json:"memoryTotalBytes"`

	// MemoryUsedBytes Node memory used in bytes
	MemoryUsedBytes uint64 `json:"memoryUsedBytes"`
}

// NodeStatus Status of the node
type NodeStatus string

// NodeStatusChange defines model for NodeStatusChange.
type NodeStatusChange struct {
	// ClusterID Identifier of the cluster
	ClusterID *openapi_types.UUID `json:"clusterID,omitempty"`

	// Status Status of the node
	Status NodeStatus `json:"status"`
}

// ResumedSandbox defines model for ResumedSandbox.
type ResumedSandbox struct {
	// AutoPause Automatically pauses the sandbox after the timeout
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	AutoPause *bool `json:"autoPause,omitempty"`

	// Timeout Time to live for the sandbox in seconds.
	Timeout *int32 `json:"timeout,omitempty"`
}

// Sandbox defines model for Sandbox.
type Sandbox struct {
	// Alias Alias of the template
	Alias *string `json:"alias,omitempty"`

	// ClientID Identifier of the client
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	ClientID string `json:"clientID"`

	// Domain Base domain where the sandbox traffic is accessible
	Domain *string `json:"domain"`

	// EnvdAccessToken Access token used for envd communication
	EnvdAccessToken *string `json:"envdAccessToken,omitempty"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// SandboxID Identifier of the sandbox
	SandboxID string `json:"sandboxID"`

	// TemplateID Identifier of the template from which is the sandbox created
	TemplateID string `json:"templateID"`

	// TrafficAccessToken Token required for accessing sandbox via proxy.
	TrafficAccessToken *string `json:"trafficAccessToken"`
}

// SandboxAutoResumePolicy Auto-resume policy for paused sandboxes. Default is off.
type SandboxAutoResumePolicy string

// SandboxDetail defines model for SandboxDetail.
type SandboxDetail struct {
	// Alias Alias of the template
	Alias *string `json:"alias,omitempty"`

	// ClientID Identifier of the client
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	ClientID string `json:"clientID"`

	// CpuCount CPU cores for the sandbox
	CpuCount CPUCount `json:"cpuCount"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB DiskSizeMB `json:"diskSizeMB"`

	// Domain Base domain where the sandbox traffic is accessible
	Domain *string `json:"domain"`

	// EndAt Time when the sandbox will expire
	EndAt time.Time `json:"endAt"`

	// EnvdAccessToken Access token used for envd communication
	EnvdAccessToken *string `json:"envdAccessToken,omitempty"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB         `json:"memoryMB"`
	Metadata *SandboxMetadata `json:"metadata,omitempty"`

	// SandboxID Identifier of the sandbox
	SandboxID string `json:"sandboxID"`

	// StartedAt Time when the sandbox was started
	StartedAt time.Time `json:"startedAt"`

	// State State of the sandbox
	State SandboxState `json:"state"`

	// TemplateID Identifier of the template from which is the sandbox created
	TemplateID string `json:"templateID"`
}

// SandboxLog Log entry with timestamp and line
type SandboxLog struct {
	// Line Log line content
	Line string `json:"line"`

	// Timestamp Timestamp of the log entry
	Timestamp time.Time `json:"timestamp"`
}

// SandboxLogEntry defines model for SandboxLogEntry.
type SandboxLogEntry struct {
	Fields map[string]string `json:"fields"`

	// Level State of the sandbox
	Level LogLevel `json:"level"`

	// Message Log message content
	Message string `json:"message"`

	// Timestamp Timestamp of the log entry
	Timestamp time.Time `json:"timestamp"`
}

// SandboxLogs defines model for SandboxLogs.
type SandboxLogs struct {
	// LogEntries Structured logs of the sandbox
	LogEntries []SandboxLogEntry `json:"logEntries"`

	// Logs Logs of the sandbox
	Logs []SandboxLog `json:"logs"`
}

// SandboxLogsV2Response defines model for SandboxLogsV2Response.
type SandboxLogsV2Response struct {
	// Logs Sandbox logs structured
	Logs []SandboxLogEntry `json:"logs"`
}

// SandboxMetadata defines model for SandboxMetadata.
type SandboxMetadata map[string]string

// SandboxMetric Metric entry with timestamp and line
type SandboxMetric struct {
	// CpuCount Number of CPU cores
	CpuCount int32 `json:"cpuCount"`

	// CpuUsedPct CPU usage percentage
	CpuUsedPct float32 `json:"cpuUsedPct"`

	// DiskTotal Total disk space in bytes
	DiskTotal int64 `json:"diskTotal"`

	// DiskUsed Disk used in bytes
	DiskUsed int64 `json:"diskUsed"`

	// MemTotal Total memory in bytes
	MemTotal int64 `json:"memTotal"`

	// MemUsed Memory used in bytes
	MemUsed int64 `json:"memUsed"`

	// Timestamp Timestamp of the metric entry
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Timestamp time.Time `json:"timestamp"`

	// TimestampUnix Timestamp of the metric entry in Unix time (seconds since epoch)
	TimestampUnix int64 `json:"timestampUnix"`
}

// SandboxNetworkConfig defines model for SandboxNetworkConfig.
type SandboxNetworkConfig struct {
	// AllowOut List of allowed CIDR blocks or IP addresses for egress traffic. Allowed addresses always take precedence over blocked addresses.
	AllowOut *[]string `json:"allowOut,omitempty"`

	// AllowPublicTraffic Specify if the sandbox URLs should be accessible only with authentication.
	AllowPublicTraffic *bool `json:"allowPublicTraffic,omitempty"`

	// DenyOut List of denied CIDR blocks or IP addresses for egress traffic
	DenyOut *[]string `json:"denyOut,omitempty"`

	// MaskRequestHost Specify host mask which will be used for all sandbox requests
	MaskRequestHost *string `json:"maskRequestHost,omitempty"`
}

// SandboxState State of the sandbox
type SandboxState string

// SandboxesWithMetrics defines model for SandboxesWithMetrics.
type SandboxesWithMetrics struct {
	Sandboxes map[string]SandboxMetric `json:"sandboxes"`
}

// Team defines model for Team.
type Team struct {
	// ApiKey API key for the team
	ApiKey string `json:"apiKey"`

	// IsDefault Whether the team is the default team
	IsDefault bool `json:"isDefault"`

	// Name Name of the team
	Name string `json:"name"`

	// TeamID Identifier of the team
	TeamID string `json:"teamID"`
}

// TeamAPIKey defines model for TeamAPIKey.
type TeamAPIKey struct {
	// CreatedAt Timestamp of API key creation
	CreatedAt time.Time `json:"createdAt"`
	CreatedBy *TeamUser `json:"createdBy"`

	// Id Identifier of the API key
	Id openapi_types.UUID `json:"id"`

	// LastUsed Last time this API key was used
	LastUsed *time.Time               `json:"lastUsed"`
	Mask     IdentifierMaskingDetails `json:"mask"`

	// Name Name of the API key
	Name string `json:"name"`
}

// TeamMetric Team metric with timestamp
type TeamMetric struct {
	// ConcurrentSandboxes The number of concurrent sandboxes for the team
	ConcurrentSandboxes int32 `json:"concurrentSandboxes"`

	// SandboxStartRate Number of sandboxes started per second
	SandboxStartRate float32 `json:"sandboxStartRate"`

	// Timestamp Timestamp of the metric entry
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Timestamp time.Time `json:"timestamp"`

	// TimestampUnix Timestamp of the metric entry in Unix time (seconds since epoch)
	TimestampUnix int64 `json:"timestampUnix"`
}

// TeamUser defines model for TeamUser.
type TeamUser struct {
	// Email Email of the user
	Email string `json:"email"`

	// Id Identifier of the user
	Id openapi_types.UUID `json:"id"`
}

// Template defines model for Template.
type Template struct {
	// Aliases Aliases of the template
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Aliases []string `json:"aliases"`

	// BuildCount Number of times the template was built
	BuildCount int32 `json:"buildCount"`

	// BuildID Identifier of the last successful build for given template
	BuildID string `json:"buildID"`

	// BuildStatus Status of the template build
	BuildStatus TemplateBuildStatus `json:"buildStatus"`

	// CpuCount CPU cores for the sandbox
	CpuCount CPUCount `json:"cpuCount"`

	// CreatedAt Time when the template was created
	CreatedAt time.Time `json:"createdAt"`
	CreatedBy *TeamUser `json:"createdBy"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB DiskSizeMB `json:"diskSizeMB"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// LastSpawnedAt Time when the template was last used
	LastSpawnedAt *time.Time `json:"lastSpawnedAt"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB `json:"memoryMB"`

	// Names Names of the template (namespace/alias format when namespaced)
	Names []string `json:"names"`

	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// SpawnCount Number of times the template was used
	SpawnCount int64 `json:"spawnCount"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`

	// UpdatedAt Time when the template was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// TemplateAliasResponse defines model for TemplateAliasResponse.
type TemplateAliasResponse struct {
	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`
}

// TemplateBuild defines model for TemplateBuild.
type TemplateBuild struct {
	// BuildID Identifier of the build
	BuildID openapi_types.UUID `json:"buildID"`

	// CpuCount CPU cores for the sandbox
	CpuCount CPUCount `json:"cpuCount"`

	// CreatedAt Time when the build was created
	CreatedAt time.Time `json:"createdAt"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB *DiskSizeMB `json:"diskSizeMB,omitempty"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion *EnvdVersion `json:"envdVersion,omitempty"`

	// FinishedAt Time when the build was finished
	FinishedAt *time.Time `json:"finishedAt,omitempty"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB `json:"memoryMB"`

	// Status Status of the template build
	Status TemplateBuildStatus `json:"status"`

	// UpdatedAt Time when the build was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// TemplateBuildFileUpload defines model for TemplateBuildFileUpload.
type TemplateBuildFileUpload struct {
	// Present Whether the file is already present in the cache
	Present bool `json:"present"`

	// Url Url where the file should be uploaded to
	Url *string `json:"url,omitempty"`
}

// TemplateBuildInfo defines model for TemplateBuildInfo.
type TemplateBuildInfo struct {
	// BuildID Identifier of the build
	BuildID string `json:"buildID"`

	// LogEntries Build logs structured
	LogEntries []BuildLogEntry `json:"logEntries"`

	// Logs Build logs
	Logs   []string           `json:"logs"`
	Reason *BuildStatusReason `json:"reason,omitempty"`

	// Status Status of the template build
	Status TemplateBuildStatus `json:"status"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`
}

// TemplateBuildLogsResponse defines model for TemplateBuildLogsResponse.
type TemplateBuildLogsResponse struct {
	// Logs Build logs structured
	Logs []BuildLogEntry `json:"logs"`
}

// TemplateBuildRequest defines model for TemplateBuildRequest.
type TemplateBuildRequest struct {
	// Alias Alias of the template
	Alias *string `json:"alias,omitempty"`

	// CpuCount CPU cores for the sandbox
	CpuCount *CPUCount `json:"cpuCount,omitempty"`

	// Dockerfile Dockerfile for the template
	Dockerfile string `json:"dockerfile"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB *MemoryMB `json:"memoryMB,omitempty"`

	// ReadyCmd Ready check command to execute in the template after the build
	ReadyCmd *string `json:"readyCmd,omitempty"`

	// StartCmd Start command to execute in the template after the build
	StartCmd *string `json:"startCmd,omitempty"`

	// TeamID Identifier of the team
	TeamID *string `json:"teamID,omitempty"`
}

// TemplateBuildRequestV2 defines model for TemplateBuildRequestV2.
type TemplateBuildRequestV2 struct {
	// Alias Alias of the template
	Alias string `json:"alias"`

	// CpuCount CPU cores for the sandbox
	CpuCount *CPUCount `json:"cpuCount,omitempty"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB *MemoryMB `json:"memoryMB,omitempty"`

	// TeamID Identifier of the team
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	TeamID *string `json:"teamID,omitempty"`
}

// TemplateBuildRequestV3 defines model for TemplateBuildRequestV3.
type TemplateBuildRequestV3 struct {
	// Alias Alias of the template. Deprecated, use name instead.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Alias *string `json:"alias,omitempty"`

	// CpuCount CPU cores for the sandbox
	CpuCount *CPUCount `json:"cpuCount,omitempty"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB *MemoryMB `json:"memoryMB,omitempty"`

	// Name Name of the template. Can include a tag with colon separator (e.g. "my-template" or "my-template:v1"). If tag is included, it will be treated as if the tag was provided in the tags array.
	Name *string `json:"name,omitempty"`

	// Tags Tags to assign to the template build
	Tags *[]string `json:"tags,omitempty"`

	// TeamID Identifier of the team
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	TeamID *string `json:"teamID,omitempty"`
}

// TemplateBuildStartV2 defines model for TemplateBuildStartV2.
type TemplateBuildStartV2 struct {
	// Force Whether the whole build should be forced to run regardless of the cache
	Force *bool `json:"force,omitempty"`

	// FromImage Image to use as a base for the template build
	FromImage         *string            `json:"fromImage,omitempty"`
	FromImageRegistry *FromImageRegistry `json:"fromImageRegistry,omitempty"`

	// FromTemplate Template to use as a base for the template build
	FromTemplate *string `json:"fromTemplate,omitempty"`

	// ReadyCmd Ready check command to execute in the template after the build
	ReadyCmd *string `json:"readyCmd,omitempty"`

	// StartCmd Start command to execute in the template after the build
	StartCmd *string `json:"startCmd,omitempty"`

	// Steps List of steps to execute in the template build
	Steps *[]TemplateStep `json:"steps,omitempty"`
}

// TemplateBuildStatus Status of the template build
type TemplateBuildStatus string

// TemplateLegacy defines model for TemplateLegacy.
type TemplateLegacy struct {
	// Aliases Aliases of the template
	Aliases []string `json:"aliases"`

	// BuildCount Number of times the template was built
	BuildCount int32 `json:"buildCount"`

	// BuildID Identifier of the last successful build for given template
	BuildID string `json:"buildID"`

	// CpuCount CPU cores for the sandbox
	CpuCount CPUCount `json:"cpuCount"`

	// CreatedAt Time when the template was created
	CreatedAt time.Time `json:"createdAt"`
	CreatedBy *TeamUser `json:"createdBy"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB DiskSizeMB `json:"diskSizeMB"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// LastSpawnedAt Time when the template was last used
	LastSpawnedAt *time.Time `json:"lastSpawnedAt"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB `json:"memoryMB"`

	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// SpawnCount Number of times the template was used
	SpawnCount int64 `json:"spawnCount"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`

	// UpdatedAt Time when the template was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// TemplateRequestResponseV3 defines model for TemplateRequestResponseV3.
type TemplateRequestResponseV3 struct {
	// Aliases Aliases of the template
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Aliases []string `json:"aliases"`

	// BuildID Identifier of the last successful build for given template
	BuildID string `json:"buildID"`

	// Names Names of the template
	Names []string `json:"names"`

	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// Tags Tags assigned to the template build
	Tags []string `json:"tags"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`
}

// TemplateStep Step in the template build process
type TemplateStep struct {
	// Args Arguments for the step
	Args *[]string `json:"args,omitempty"`

	// FilesHash Hash of the files used in the step
	FilesHash *string `json:"filesHash,omitempty"`

	// Force Whether the step should be forced to run regardless of the cache
	Force *bool `json:"force,omitempty"`

	// Type Type of the step
	Type string `json:"type"`
}

// TemplateUpdateRequest defines model for TemplateUpdateRequest.
type TemplateUpdateRequest struct {
	// Public Whether the template is public or only accessible by the team
	Public *bool `json:"public,omitempty"`
}

// TemplateUpdateResponse defines model for TemplateUpdateResponse.
type TemplateUpdateResponse struct {
	// Names Names of the template (namespace/alias format when namespaced)
	Names []string `json:"names"`
}

// TemplateWithBuilds defines model for TemplateWithBuilds.
type TemplateWithBuilds struct {
	// Aliases Aliases of the template
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Aliases []string `json:"aliases"`

	// Builds List of builds for the template
	Builds []TemplateBuild `json:"builds"`

	// CreatedAt Time when the template was created
	CreatedAt time.Time `json:"createdAt"`

	// LastSpawnedAt Time when the template was last used
	LastSpawnedAt *time.Time `json:"lastSpawnedAt"`

	// Names Names of the template (namespace/alias format when namespaced)
	Names []string `json:"names"`

	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// SpawnCount Number of times the template was used
	SpawnCount int64 `json:"spawnCount"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`

	// UpdatedAt Time when the template was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// UpdateTeamAPIKey defines model for UpdateTeamAPIKey.
type UpdateTeamAPIKey struct {
	// Name New name for the API key
	Name string `json:"name"`
}

// AccessTokenID defines model for accessTokenID.
type AccessTokenID = string

// ApiKeyID defines model for apiKeyID.
type ApiKeyID = string

// BuildID defines model for buildID.
type BuildID = string

// NodeID defines model for nodeID.
type NodeID = string

// PaginationLimit defines model for paginationLimit.
type PaginationLimit = int32

// PaginationNextToken defines model for paginationNextToken.
type PaginationNextToken = string

// SandboxID defines model for sandboxID.
type SandboxID = string

// TeamID defines model for teamID.
type TeamID = string

// TemplateID defines model for templateID.
type TemplateID = string

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N409 defines model for 409.
type N409 = Error

// N500 defines model for 500.
type N500 = Error

// GetNodesNodeIDParams defines parameters for GetNodesNodeID.
type GetNodesNodeIDParams struct {
	// ClusterID Identifier of the cluster
	ClusterID *openapi_types.UUID `form:"clusterID,omitempty" json:"clusterID,omitempty"`
}

// GetSandboxesParams defines parameters for GetSandboxes.
type GetSandboxesParams struct {
	// Metadata Metadata query used to filter the sandboxes (e.g. "user=abc&app=prod"). Each key and values must be URL encoded.
	Metadata *string `form:"metadata,omitempty" json:"metadata,omitempty"`
}

// GetSandboxesMetricsParams defines parameters for GetSandboxesMetrics.
type GetSandboxesMetricsParams struct {
	// SandboxIds Comma-separated list of sandbox IDs to get metrics for
	SandboxIds []string `form:"sandbox_ids" json:"sandbox_ids"`
}

// GetSandboxesSandboxIDLogsParams defines parameters for GetSandboxesSandboxIDLogs.
type GetSandboxesSandboxIDLogsParams struct {
	// Start Starting timestamp of the logs that should be returned in milliseconds
	Start *int64 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Maximum number of logs that should be returned
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSandboxesSandboxIDMetricsParams defines parameters for GetSandboxesSandboxIDMetrics.
type GetSandboxesSandboxIDMetricsParams struct {
	// Start Unix timestamp for the start of the interval, in seconds, for which the metrics
	Start *int64 `form:"start,omitempty" json:"start,omitempty"`
	End   *int64 `form:"end,omitempty" json:"end,omitempty"`
}

// PostSandboxesSandboxIDRefreshesJSONBody defines parameters for PostSandboxesSandboxIDRefreshes.
type PostSandboxesSandboxIDRefreshesJSONBody struct {
	// Duration Duration for which the sandbox should be kept alive in seconds
	Duration *int `json:"duration,omitempty"`
}

// PostSandboxesSandboxIDTimeoutJSONBody defines parameters for PostSandboxesSandboxIDTimeout.
type PostSandboxesSandboxIDTimeoutJSONBody struct {
	// Timeout Timeout in seconds from the current time after which the sandbox should expire
	Timeout int32 `json:"timeout"`
}

// GetTeamsTeamIDMetricsParams defines parameters for GetTeamsTeamIDMetrics.
type GetTeamsTeamIDMetricsParams struct {
	// Start Unix timestamp for the start of the interval, in seconds, for which the metrics
	Start *int64 `form:"start,omitempty" json:"start,omitempty"`
	End   *int64 `form:"end,omitempty" json:"end,omitempty"`
}

// GetTeamsTeamIDMetricsMaxParams defines parameters for GetTeamsTeamIDMetricsMax.
type GetTeamsTeamIDMetricsMaxParams struct {
	// Start Unix timestamp for the start of the interval, in seconds, for which the metrics
	Start *int64 `form:"start,omitempty" json:"start,omitempty"`
	End   *int64 `form:"end,omitempty" json:"end,omitempty"`

	// Metric Metric to retrieve the maximum value for
	Metric GetTeamsTeamIDMetricsMaxParamsMetric `form:"metric" json:"metric"`
}

// GetTeamsTeamIDMetricsMaxParamsMetric defines parameters for GetTeamsTeamIDMetricsMax.
type GetTeamsTeamIDMetricsMaxParamsMetric string

// GetTemplatesParams defines parameters for GetTemplates.
type GetTemplatesParams struct {
	TeamID *string `form:"teamID,omitempty" json:"teamID,omitempty"`
}

// GetTemplatesTemplateIDParams defines parameters for GetTemplatesTemplateID.
type GetTemplatesTemplateIDParams struct {
	// NextToken Cursor to start the list from
	NextToken *PaginationNextToken `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// Limit Maximum number of items to return per page
	Limit *PaginationLimit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTemplatesTemplateIDBuildsBuildIDLogsParams defines parameters for GetTemplatesTemplateIDBuildsBuildIDLogs.
type GetTemplatesTemplateIDBuildsBuildIDLogsParams struct {
	// Cursor Starting timestamp of the logs that should be returned in milliseconds
	Cursor *int64 `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of logs that should be returned
	Limit     *int32         `form:"limit,omitempty" json:"limit,omitempty"`
	Direction *LogsDirection `form:"direction,omitempty" json:"direction,omitempty"`
	Level     *LogLevel      `form:"level,omitempty" json:"level,omitempty"`

	// Source Source of the logs that should be returned from
	Source *LogsSource `form:"source,omitempty" json:"source,omitempty"`
}

// GetTemplatesTemplateIDBuildsBuildIDStatusParams defines parameters for GetTemplatesTemplateIDBuildsBuildIDStatus.
type GetTemplatesTemplateIDBuildsBuildIDStatusParams struct {
	// LogsOffset Index of the starting build log that should be returned with the template
	LogsOffset *int32 `form:"logsOffset,omitempty" json:"logsOffset,omitempty"`

	// Limit Maximum number of logs that should be returned
	Limit *int32    `form:"limit,omitempty" json:"limit,omitempty"`
	Level *LogLevel `form:"level,omitempty" json:"level,omitempty"`
}

// GetV2SandboxesParams defines parameters for GetV2Sandboxes.
type GetV2SandboxesParams struct {
	// Metadata Metadata query used to filter the sandboxes (e.g. "user=abc&app=prod"). Each key and values must be URL encoded.
	Metadata *string `form:"metadata,omitempty" json:"metadata,omitempty"`

	// State Filter sandboxes by one or more states
	State *[]SandboxState `form:"state,omitempty" json:"state,omitempty"`

	// NextToken Cursor to start the list from
	NextToken *PaginationNextToken `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// Limit Maximum number of items to return per page
	Limit *PaginationLimit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetV2SandboxesSandboxIDLogsParams defines parameters for GetV2SandboxesSandboxIDLogs.
type GetV2SandboxesSandboxIDLogsParams struct {
	// Cursor Starting timestamp of the logs that should be returned in milliseconds
	Cursor *int64 `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of logs that should be returned
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction Direction of the logs that should be returned
	Direction *LogsDirection `form:"direction,omitempty" json:"direction,omitempty"`
}

// PostAccessTokensJSONRequestBody defines body for PostAccessTokens for application/json ContentType.
type PostAccessTokensJSONRequestBody = NewAccessToken

// PostApiKeysJSONRequestBody defines body for PostApiKeys for application/json ContentType.
type PostApiKeysJSONRequestBody = NewTeamAPIKey

// PatchApiKeysApiKeyIDJSONRequestBody defines body for PatchApiKeysApiKeyID for application/json ContentType.
type PatchApiKeysApiKeyIDJSONRequestBody = UpdateTeamAPIKey

// PostNodesNodeIDJSONRequestBody defines body for PostNodesNodeID for application/json ContentType.
type PostNodesNodeIDJSONRequestBody = NodeStatusChange

// PostSandboxesJSONRequestBody defines body for PostSandboxes for application/json ContentType.
type PostSandboxesJSONRequestBody = NewSandbox

// PostSandboxesSandboxIDConnectJSONRequestBody defines body for PostSandboxesSandboxIDConnect for application/json ContentType.
type PostSandboxesSandboxIDConnectJSONRequestBody = ConnectSandbox

// PostSandboxesSandboxIDRefreshesJSONRequestBody defines body for PostSandboxesSandboxIDRefreshes for application/json ContentType.
type PostSandboxesSandboxIDRefreshesJSONRequestBody PostSandboxesSandboxIDRefreshesJSONBody

// PostSandboxesSandboxIDResumeJSONRequestBody defines body for PostSandboxesSandboxIDResume for application/json ContentType.
type PostSandboxesSandboxIDResumeJSONRequestBody = ResumedSandbox

// PostSandboxesSandboxIDTimeoutJSONRequestBody defines body for PostSandboxesSandboxIDTimeout for application/json ContentType.
type PostSandboxesSandboxIDTimeoutJSONRequestBody PostSandboxesSandboxIDTimeoutJSONBody

// PostTemplatesJSONRequestBody defines body for PostTemplates for application/json ContentType.
type PostTemplatesJSONRequestBody = TemplateBuildRequest

// DeleteTemplatesTagsJSONRequestBody defines body for DeleteTemplatesTags for application/json ContentType.
type DeleteTemplatesTagsJSONRequestBody = DeleteTemplateTagsRequest

// PostTemplatesTagsJSONRequestBody defines body for PostTemplatesTags for application/json ContentType.
type PostTemplatesTagsJSONRequestBody = AssignTemplateTagsRequest

// PatchTemplatesTemplateIDJSONRequestBody defines body for PatchTemplatesTemplateID for application/json ContentType.
type PatchTemplatesTemplateIDJSONRequestBody = TemplateUpdateRequest

// PostTemplatesTemplateIDJSONRequestBody defines body for PostTemplatesTemplateID for application/json ContentType.
type PostTemplatesTemplateIDJSONRequestBody = TemplateBuildRequest

// PostV2TemplatesJSONRequestBody defines body for PostV2Templates for application/json ContentType.
type PostV2TemplatesJSONRequestBody = TemplateBuildRequestV2

// PatchV2TemplatesTemplateIDJSONRequestBody defines body for PatchV2TemplatesTemplateID for application/json ContentType.
type PatchV2TemplatesTemplateIDJSONRequestBody = TemplateUpdateRequest

// PostV2TemplatesTemplateIDBuildsBuildIDJSONRequestBody defines body for PostV2TemplatesTemplateIDBuildsBuildID for application/json ContentType.
type PostV2TemplatesTemplateIDBuildsBuildIDJSONRequestBody = TemplateBuildStartV2

// PostV3TemplatesJSONRequestBody defines body for PostV3Templates for application/json ContentType.
type PostV3TemplatesJSONRequestBody = TemplateBuildRequestV3

// AsAWSRegistry returns the union data inside the FromImageRegistry as a AWSRegistry
func (t FromImageRegistry) AsAWSRegistry() (AWSRegistry, error) {
	var body AWSRegistry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSRegistry overwrites any union data inside the FromImageRegistry as the provided AWSRegistry
func (t *FromImageRegistry) FromAWSRegistry(v AWSRegistry) error {
	v.Type = "aws"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSRegistry performs a merge with any union data inside the FromImageRegistry, using the provided AWSRegistry
func (t *FromImageRegistry) MergeAWSRegistry(v AWSRegistry) error {
	v.Type = "aws"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGCPRegistry returns the union data inside the FromImageRegistry as a GCPRegistry
func (t FromImageRegistry) AsGCPRegistry() (GCPRegistry, error) {
	var body GCPRegistry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPRegistry overwrites any union data inside the FromImageRegistry as the provided GCPRegistry
func (t *FromImageRegistry) FromGCPRegistry(v GCPRegistry) error {
	v.Type = "gcp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPRegistry performs a merge with any union data inside the FromImageRegistry, using the provided GCPRegistry
func (t *FromImageRegistry) MergeGCPRegistry(v GCPRegistry) error {
	v.Type = "gcp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeneralRegistry returns the union data inside the FromImageRegistry as a GeneralRegistry
func (t FromImageRegistry) AsGeneralRegistry() (GeneralRegistry, error) {
	var body GeneralRegistry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeneralRegistry overwrites any union data inside the FromImageRegistry as the provided GeneralRegistry
func (t *FromImageRegistry) FromGeneralRegistry(v GeneralRegistry) error {
	v.Type = "registry"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeneralRegistry performs a merge with any union data inside the FromImageRegistry, using the provided GeneralRegistry
func (t *FromImageRegistry) MergeGeneralRegistry(v GeneralRegistry) error {
	v.Type = "registry"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FromImageRegistry) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t FromImageRegistry) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "aws":
		return t.AsAWSRegistry()
	case "gcp":
		return t.AsGCPRegistry()
	case "registry":
		return t.AsGeneralRegistry()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t FromImageRegistry) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FromImageRegistry) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostAccessTokensWithBody request with any body
	PostAccessTokensWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAccessTokens(ctx context.Context, body PostAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAccessTokensAccessTokenID request
	DeleteAccessTokensAccessTokenID(ctx context.Context, accessTokenID AccessTokenID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAdminTeamsTeamIDSandboxesKill request
	PostAdminTeamsTeamIDSandboxesKill(ctx context.Context, teamID openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiKeys request
	GetApiKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApiKeysWithBody request with any body
	PostApiKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApiKeys(ctx context.Context, body PostApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApiKeysApiKeyID request
	DeleteApiKeysApiKeyID(ctx context.Context, apiKeyID ApiKeyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApiKeysApiKeyIDWithBody request with any body
	PatchApiKeysApiKeyIDWithBody(ctx context.Context, apiKeyID ApiKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApiKeysApiKeyID(ctx context.Context, apiKeyID ApiKeyID, body PatchApiKeysApiKeyIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealth request
	GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNodes request
	GetNodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNodesNodeID request
	GetNodesNodeID(ctx context.Context, nodeID NodeID, params *GetNodesNodeIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodesNodeIDWithBody request with any body
	PostNodesNodeIDWithBody(ctx context.Context, nodeID NodeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodesNodeID(ctx context.Context, nodeID NodeID, body PostNodesNodeIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxes request
	GetSandboxes(ctx context.Context, params *GetSandboxesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSandboxesWithBody request with any body
	PostSandboxesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSandboxes(ctx context.Context, body PostSandboxesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxesMetrics request
	GetSandboxesMetrics(ctx context.Context, params *GetSandboxesMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSandboxesSandboxID request
	DeleteSandboxesSandboxID(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxesSandboxID request
	GetSandboxesSandboxID(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSandboxesSandboxIDConnectWithBody request with any body
	PostSandboxesSandboxIDConnectWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSandboxesSandboxIDConnect(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxesSandboxIDLogs request
	GetSandboxesSandboxIDLogs(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxesSandboxIDMetrics request
	GetSandboxesSandboxIDMetrics(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSandboxesSandboxIDPause request
	PostSandboxesSandboxIDPause(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSandboxesSandboxIDRefreshesWithBody request with any body
	PostSandboxesSandboxIDRefreshesWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSandboxesSandboxIDRefreshes(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDRefreshesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSandboxesSandboxIDResumeWithBody request with any body
	PostSandboxesSandboxIDResumeWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSandboxesSandboxIDResume(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDResumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSandboxesSandboxIDTimeoutWithBody request with any body
	PostSandboxesSandboxIDTimeoutWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSandboxesSandboxIDTimeout(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeams request
	GetTeams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsTeamIDMetrics request
	GetTeamsTeamIDMetrics(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsTeamIDMetricsMax request
	GetTeamsTeamIDMetricsMax(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsMaxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplates request
	GetTemplates(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTemplatesWithBody request with any body
	PostTemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTemplates(ctx context.Context, body PostTemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplatesAliasesAlias request
	GetTemplatesAliasesAlias(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTemplatesTagsWithBody request with any body
	DeleteTemplatesTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTemplatesTags(ctx context.Context, body DeleteTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTemplatesTagsWithBody request with any body
	PostTemplatesTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTemplatesTags(ctx context.Context, body PostTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTemplatesTemplateID request
	DeleteTemplatesTemplateID(ctx context.Context, templateID TemplateID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplatesTemplateID request
	GetTemplatesTemplateID(ctx context.Context, templateID TemplateID, params *GetTemplatesTemplateIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchTemplatesTemplateIDWithBody request with any body
	PatchTemplatesTemplateIDWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchTemplatesTemplateID(ctx context.Context, templateID TemplateID, body PatchTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTemplatesTemplateIDWithBody request with any body
	PostTemplatesTemplateIDWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTemplatesTemplateID(ctx context.Context, templateID TemplateID, body PostTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTemplatesTemplateIDBuildsBuildID request
	PostTemplatesTemplateIDBuildsBuildID(ctx context.Context, templateID TemplateID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplatesTemplateIDBuildsBuildIDLogs request
	GetTemplatesTemplateIDBuildsBuildIDLogs(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplatesTemplateIDBuildsBuildIDStatus request
	GetTemplatesTemplateIDBuildsBuildIDStatus(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplatesTemplateIDFilesHash request
	GetTemplatesTemplateIDFilesHash(ctx context.Context, templateID TemplateID, hash string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2Sandboxes request
	GetV2Sandboxes(ctx context.Context, params *GetV2SandboxesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2SandboxesSandboxIDLogs request
	GetV2SandboxesSandboxIDLogs(ctx context.Context, sandboxID SandboxID, params *GetV2SandboxesSandboxIDLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2TemplatesWithBody request with any body
	PostV2TemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2Templates(ctx context.Context, body PostV2TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchV2TemplatesTemplateIDWithBody request with any body
	PatchV2TemplatesTemplateIDWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchV2TemplatesTemplateID(ctx context.Context, templateID TemplateID, body PatchV2TemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2TemplatesTemplateIDBuildsBuildIDWithBody request with any body
	PostV2TemplatesTemplateIDBuildsBuildIDWithBody(ctx context.Context, templateID TemplateID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2TemplatesTemplateIDBuildsBuildID(ctx context.Context, templateID TemplateID, buildID BuildID, body PostV2TemplatesTemplateIDBuildsBuildIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV3TemplatesWithBody request with any body
	PostV3TemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV3Templates(ctx context.Context, body PostV3TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostAccessTokensWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAccessTokensRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAccessTokens(ctx context.Context, body PostAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAccessTokensRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAccessTokensAccessTokenID(ctx context.Context, accessTokenID AccessTokenID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccessTokensAccessTokenIDRequest(c.Server, accessTokenID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAdminTeamsTeamIDSandboxesKill(ctx context.Context, teamID openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAdminTeamsTeamIDSandboxesKillRequest(c.Server, teamID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiKeysRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiKeys(ctx context.Context, body PostApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiKeysRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApiKeysApiKeyID(ctx context.Context, apiKeyID ApiKeyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApiKeysApiKeyIDRequest(c.Server, apiKeyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApiKeysApiKeyIDWithBody(ctx context.Context, apiKeyID ApiKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApiKeysApiKeyIDRequestWithBody(c.Server, apiKeyID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApiKeysApiKeyID(ctx context.Context, apiKeyID ApiKeyID, body PatchApiKeysApiKeyIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApiKeysApiKeyIDRequest(c.Server, apiKeyID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNodesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNodesNodeID(ctx context.Context, nodeID NodeID, params *GetNodesNodeIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNodesNodeIDRequest(c.Server, nodeID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodesNodeIDWithBody(ctx context.Context, nodeID NodeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodesNodeIDRequestWithBody(c.Server, nodeID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodesNodeID(ctx context.Context, nodeID NodeID, body PostNodesNodeIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodesNodeIDRequest(c.Server, nodeID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxes(ctx context.Context, params *GetSandboxesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxes(ctx context.Context, body PostSandboxesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxesMetrics(ctx context.Context, params *GetSandboxesMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxesMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSandboxesSandboxID(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSandboxesSandboxIDRequest(c.Server, sandboxID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxesSandboxID(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxesSandboxIDRequest(c.Server, sandboxID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDConnectWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDConnectRequestWithBody(c.Server, sandboxID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDConnect(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDConnectRequest(c.Server, sandboxID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxesSandboxIDLogs(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxesSandboxIDLogsRequest(c.Server, sandboxID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxesSandboxIDMetrics(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxesSandboxIDMetricsRequest(c.Server, sandboxID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDPause(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDPauseRequest(c.Server, sandboxID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDRefreshesWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDRefreshesRequestWithBody(c.Server, sandboxID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDRefreshes(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDRefreshesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDRefreshesRequest(c.Server, sandboxID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDResumeWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDResumeRequestWithBody(c.Server, sandboxID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDResume(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDResumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDResumeRequest(c.Server, sandboxID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDTimeoutWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDTimeoutRequestWithBody(c.Server, sandboxID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDTimeout(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDTimeoutRequest(c.Server, sandboxID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsTeamIDMetrics(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsTeamIDMetricsRequest(c.Server, teamID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsTeamIDMetricsMax(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsMaxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsTeamIDMetricsMaxRequest(c.Server, teamID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplates(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTemplatesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTemplates(ctx context.Context, body PostTemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTemplatesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplatesAliasesAlias(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesAliasesAliasRequest(c.Server, alias)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTemplatesTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTemplatesTagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTemplatesTags(ctx context.Context, body DeleteTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTemplatesTagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTemplatesTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTemplatesTagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTemplatesTags(ctx context.Context, body PostTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTemplatesTagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTemplatesTemplateID(ctx context.Context, templateID TemplateID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTemplatesTemplateIDRequest(c.Server, templateID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplatesTemplateID(ctx context.Context, templateID TemplateID, params *GetTemplatesTemplateIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesTemplateIDRequest(c.Server, templateID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchTemplatesTemplateIDWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchTemplatesTemplateIDRequestWithBody(c.Server, templateID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchTemplatesTemplateID(ctx context.Context, templateID TemplateID, body PatchTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchTemplatesTemplateIDRequest(c.Server, templateID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTemplatesTemplateIDWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTemplatesTemplateIDRequestWithBody(c.Server, templateID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTemplatesTemplateID(ctx context.Context, templateID TemplateID, body PostTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTemplatesTemplateIDRequest(c.Server, templateID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTemplatesTemplateIDBuildsBuildID(ctx context.Context, templateID TemplateID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTemplatesTemplateIDBuildsBuildIDRequest(c.Server, templateID, buildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplatesTemplateIDBuildsBuildIDLogs(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesTemplateIDBuildsBuildIDLogsRequest(c.Server, templateID, buildID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplatesTemplateIDBuildsBuildIDStatus(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesTemplateIDBuildsBuildIDStatusRequest(c.Server, templateID, buildID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplatesTemplateIDFilesHash(ctx context.Context, templateID TemplateID, hash string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesTemplateIDFilesHashRequest(c.Server, templateID, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2Sandboxes(ctx context.Context, params *GetV2SandboxesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2SandboxesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2SandboxesSandboxIDLogs(ctx context.Context, sandboxID SandboxID, params *GetV2SandboxesSandboxIDLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2SandboxesSandboxIDLogsRequest(c.Server, sandboxID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2TemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2TemplatesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2Templates(ctx context.Context, body PostV2TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2TemplatesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2TemplatesTemplateIDWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2TemplatesTemplateIDRequestWithBody(c.Server, templateID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2TemplatesTemplateID(ctx context.Context, templateID TemplateID, body PatchV2TemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2TemplatesTemplateIDRequest(c.Server, templateID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2TemplatesTemplateIDBuildsBuildIDWithBody(ctx context.Context, templateID TemplateID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2TemplatesTemplateIDBuildsBuildIDRequestWithBody(c.Server, templateID, buildID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2TemplatesTemplateIDBuildsBuildID(ctx context.Context, templateID TemplateID, buildID BuildID, body PostV2TemplatesTemplateIDBuildsBuildIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2TemplatesTemplateIDBuildsBuildIDRequest(c.Server, templateID, buildID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV3TemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV3TemplatesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV3Templates(ctx context.Context, body PostV3TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV3TemplatesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostAccessTokensRequest calls the generic PostAccessTokens builder with application/json body
func NewPostAccessTokensRequest(server string, body PostAccessTokensJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAccessTokensRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAccessTokensRequestWithBody generates requests for PostAccessTokens with any type of body
func NewPostAccessTokensRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAccessTokensAccessTokenIDRequest generates requests for DeleteAccessTokensAccessTokenID
func NewDeleteAccessTokensAccessTokenIDRequest(server string, accessTokenID AccessTokenID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessTokenID", runtime.ParamLocationPath, accessTokenID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAdminTeamsTeamIDSandboxesKillRequest generates requests for PostAdminTeamsTeamIDSandboxesKill
func NewPostAdminTeamsTeamIDSandboxesKillRequest(server string, teamID openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamID", runtime.ParamLocationPath, teamID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/teams/%s/sandboxes/kill", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiKeysRequest generates requests for GetApiKeys
func NewGetApiKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostApiKeysRequest calls the generic PostApiKeys builder with application/json body
func NewPostApiKeysRequest(server string, body PostApiKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApiKeysRequestWithBody(server, "application/json", bodyReader)
}

// NewPostApiKeysRequestWithBody generates requests for PostApiKeys with any type of body
func NewPostApiKeysRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteApiKeysApiKeyIDRequest generates requests for DeleteApiKeysApiKeyID
func NewDeleteApiKeysApiKeyIDRequest(server string, apiKeyID ApiKeyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiKeyID", runtime.ParamLocationPath, apiKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchApiKeysApiKeyIDRequest calls the generic PatchApiKeysApiKeyID builder with application/json body
func NewPatchApiKeysApiKeyIDRequest(server string, apiKeyID ApiKeyID, body PatchApiKeysApiKeyIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApiKeysApiKeyIDRequestWithBody(server, apiKeyID, "application/json", bodyReader)
}

// NewPatchApiKeysApiKeyIDRequestWithBody generates requests for PatchApiKeysApiKeyID with any type of body
func NewPatchApiKeysApiKeyIDRequestWithBody(server string, apiKeyID ApiKeyID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiKeyID", runtime.ParamLocationPath, apiKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHealthRequest generates requests for GetHealth
func NewGetHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNodesRequest generates requests for GetNodes
func NewGetNodesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNodesNodeIDRequest generates requests for GetNodesNodeID
func NewGetNodesNodeIDRequest(server string, nodeID NodeID, params *GetNodesNodeIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "nodeID", runtime.ParamLocationPath, nodeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClusterID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clusterID", runtime.ParamLocationQuery, *params.ClusterID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostNodesNodeIDRequest calls the generic PostNodesNodeID builder with application/json body
func NewPostNodesNodeIDRequest(server string, nodeID NodeID, body PostNodesNodeIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodesNodeIDRequestWithBody(server, nodeID, "application/json", bodyReader)
}

// NewPostNodesNodeIDRequestWithBody generates requests for PostNodesNodeID with any type of body
func NewPostNodesNodeIDRequestWithBody(server string, nodeID NodeID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "nodeID", runtime.ParamLocationPath, nodeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSandboxesRequest generates requests for GetSandboxes
func NewGetSandboxesRequest(server string, params *GetSandboxesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSandboxesRequest calls the generic PostSandboxes builder with application/json body
func NewPostSandboxesRequest(server string, body PostSandboxesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSandboxesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSandboxesRequestWithBody generates requests for PostSandboxes with any type of body
func NewPostSandboxesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSandboxesMetricsRequest generates requests for GetSandboxesMetrics
func NewGetSandboxesMetricsRequest(server string, params *GetSandboxesMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sandbox_ids", runtime.ParamLocationQuery, params.SandboxIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSandboxesSandboxIDRequest generates requests for DeleteSandboxesSandboxID
func NewDeleteSandboxesSandboxIDRequest(server string, sandboxID SandboxID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSandboxesSandboxIDRequest generates requests for GetSandboxesSandboxID
func NewGetSandboxesSandboxIDRequest(server string, sandboxID SandboxID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSandboxesSandboxIDConnectRequest calls the generic PostSandboxesSandboxIDConnect builder with application/json body
func NewPostSandboxesSandboxIDConnectRequest(server string, sandboxID SandboxID, body PostSandboxesSandboxIDConnectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSandboxesSandboxIDConnectRequestWithBody(server, sandboxID, "application/json", bodyReader)
}

// NewPostSandboxesSandboxIDConnectRequestWithBody generates requests for PostSandboxesSandboxIDConnect with any type of body
func NewPostSandboxesSandboxIDConnectRequestWithBody(server string, sandboxID SandboxID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/connect", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSandboxesSandboxIDLogsRequest generates requests for GetSandboxesSandboxIDLogs
func NewGetSandboxesSandboxIDLogsRequest(server string, sandboxID SandboxID, params *GetSandboxesSandboxIDLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSandboxesSandboxIDMetricsRequest generates requests for GetSandboxesSandboxIDMetrics
func NewGetSandboxesSandboxIDMetricsRequest(server string, sandboxID SandboxID, params *GetSandboxesSandboxIDMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSandboxesSandboxIDPauseRequest generates requests for PostSandboxesSandboxIDPause
func NewPostSandboxesSandboxIDPauseRequest(server string, sandboxID SandboxID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/pause", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSandboxesSandboxIDRefreshesRequest calls the generic PostSandboxesSandboxIDRefreshes builder with application/json body
func NewPostSandboxesSandboxIDRefreshesRequest(server string, sandboxID SandboxID, body PostSandboxesSandboxIDRefreshesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSandboxesSandboxIDRefreshesRequestWithBody(server, sandboxID, "application/json", bodyReader)
}

// NewPostSandboxesSandboxIDRefreshesRequestWithBody generates requests for PostSandboxesSandboxIDRefreshes with any type of body
func NewPostSandboxesSandboxIDRefreshesRequestWithBody(server string, sandboxID SandboxID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/refreshes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSandboxesSandboxIDResumeRequest calls the generic PostSandboxesSandboxIDResume builder with application/json body
func NewPostSandboxesSandboxIDResumeRequest(server string, sandboxID SandboxID, body PostSandboxesSandboxIDResumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSandboxesSandboxIDResumeRequestWithBody(server, sandboxID, "application/json", bodyReader)
}

// NewPostSandboxesSandboxIDResumeRequestWithBody generates requests for PostSandboxesSandboxIDResume with any type of body
func NewPostSandboxesSandboxIDResumeRequestWithBody(server string, sandboxID SandboxID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/resume", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSandboxesSandboxIDTimeoutRequest calls the generic PostSandboxesSandboxIDTimeout builder with application/json body
func NewPostSandboxesSandboxIDTimeoutRequest(server string, sandboxID SandboxID, body PostSandboxesSandboxIDTimeoutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSandboxesSandboxIDTimeoutRequestWithBody(server, sandboxID, "application/json", bodyReader)
}

// NewPostSandboxesSandboxIDTimeoutRequestWithBody generates requests for PostSandboxesSandboxIDTimeout with any type of body
func NewPostSandboxesSandboxIDTimeoutRequestWithBody(server string, sandboxID SandboxID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/timeout", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamsRequest generates requests for GetTeams
func NewGetTeamsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsTeamIDMetricsRequest generates requests for GetTeamsTeamIDMetrics
func NewGetTeamsTeamIDMetricsRequest(server string, teamID TeamID, params *GetTeamsTeamIDMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamID", runtime.ParamLocationPath, teamID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsTeamIDMetricsMaxRequest generates requests for GetTeamsTeamIDMetricsMax
func NewGetTeamsTeamIDMetricsMaxRequest(server string, teamID TeamID, params *GetTeamsTeamIDMetricsMaxParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamID", runtime.ParamLocationPath, teamID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/metrics/max", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metric", runtime.ParamLocationQuery, params.Metric); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplatesRequest generates requests for GetTemplates
func NewGetTemplatesRequest(server string, params *GetTemplatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TeamID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamID", runtime.ParamLocationQuery, *params.TeamID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTemplatesRequest calls the generic PostTemplates builder with application/json body
func NewPostTemplatesRequest(server string, body PostTemplatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTemplatesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostTemplatesRequestWithBody generates requests for PostTemplates with any type of body
func NewPostTemplatesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTemplatesAliasesAliasRequest generates requests for GetTemplatesAliasesAlias
func NewGetTemplatesAliasesAliasRequest(server string, alias string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alias", runtime.ParamLocationPath, alias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/aliases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTemplatesTagsRequest calls the generic DeleteTemplatesTags builder with application/json body
func NewDeleteTemplatesTagsRequest(server string, body DeleteTemplatesTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTemplatesTagsRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteTemplatesTagsRequestWithBody generates requests for DeleteTemplatesTags with any type of body
func NewDeleteTemplatesTagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTemplatesTagsRequest calls the generic PostTemplatesTags builder with application/json body
func NewPostTemplatesTagsRequest(server string, body PostTemplatesTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTemplatesTagsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostTemplatesTagsRequestWithBody generates requests for PostTemplatesTags with any type of body
func NewPostTemplatesTagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTemplatesTemplateIDRequest generates requests for DeleteTemplatesTemplateID
func NewDeleteTemplatesTemplateIDRequest(server string, templateID TemplateID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplatesTemplateIDRequest generates requests for GetTemplatesTemplateID
func NewGetTemplatesTemplateIDRequest(server string, templateID TemplateID, params *GetTemplatesTemplateIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchTemplatesTemplateIDRequest calls the generic PatchTemplatesTemplateID builder with application/json body
func NewPatchTemplatesTemplateIDRequest(server string, templateID TemplateID, body PatchTemplatesTemplateIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchTemplatesTemplateIDRequestWithBody(server, templateID, "application/json", bodyReader)
}

// NewPatchTemplatesTemplateIDRequestWithBody generates requests for PatchTemplatesTemplateID with any type of body
func NewPatchTemplatesTemplateIDRequestWithBody(server string, templateID TemplateID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTemplatesTemplateIDRequest calls the generic PostTemplatesTemplateID builder with application/json body
func NewPostTemplatesTemplateIDRequest(server string, templateID TemplateID, body PostTemplatesTemplateIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTemplatesTemplateIDRequestWithBody(server, templateID, "application/json", bodyReader)
}

// NewPostTemplatesTemplateIDRequestWithBody generates requests for PostTemplatesTemplateID with any type of body
func NewPostTemplatesTemplateIDRequestWithBody(server string, templateID TemplateID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTemplatesTemplateIDBuildsBuildIDRequest generates requests for PostTemplatesTemplateIDBuildsBuildID
func NewPostTemplatesTemplateIDBuildsBuildIDRequest(server string, templateID TemplateID, buildID BuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplatesTemplateIDBuildsBuildIDLogsRequest generates requests for GetTemplatesTemplateIDBuildsBuildIDLogs
func NewGetTemplatesTemplateIDBuildsBuildIDLogsRequest(server string, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s/builds/%s/logs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplatesTemplateIDBuildsBuildIDStatusRequest generates requests for GetTemplatesTemplateIDBuildsBuildIDStatus
func NewGetTemplatesTemplateIDBuildsBuildIDStatusRequest(server string, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s/builds/%s/status", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LogsOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "logsOffset", runtime.ParamLocationQuery, *params.LogsOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplatesTemplateIDFilesHashRequest generates requests for GetTemplatesTemplateIDFilesHash
func NewGetTemplatesTemplateIDFilesHashRequest(server string, templateID TemplateID, hash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s/files/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2SandboxesRequest generates requests for GetV2Sandboxes
func NewGetV2SandboxesRequest(server string, params *GetV2SandboxesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2SandboxesSandboxIDLogsRequest generates requests for GetV2SandboxesSandboxIDLogs
func NewGetV2SandboxesSandboxIDLogsRequest(server string, sandboxID SandboxID, params *GetV2SandboxesSandboxIDLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sandboxes/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2TemplatesRequest calls the generic PostV2Templates builder with application/json body
func NewPostV2TemplatesRequest(server string, body PostV2TemplatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2TemplatesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2TemplatesRequestWithBody generates requests for PostV2Templates with any type of body
func NewPostV2TemplatesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchV2TemplatesTemplateIDRequest calls the generic PatchV2TemplatesTemplateID builder with application/json body
func NewPatchV2TemplatesTemplateIDRequest(server string, templateID TemplateID, body PatchV2TemplatesTemplateIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchV2TemplatesTemplateIDRequestWithBody(server, templateID, "application/json", bodyReader)
}

// NewPatchV2TemplatesTemplateIDRequestWithBody generates requests for PatchV2TemplatesTemplateID with any type of body
func NewPatchV2TemplatesTemplateIDRequestWithBody(server string, templateID TemplateID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2TemplatesTemplateIDBuildsBuildIDRequest calls the generic PostV2TemplatesTemplateIDBuildsBuildID builder with application/json body
func NewPostV2TemplatesTemplateIDBuildsBuildIDRequest(server string, templateID TemplateID, buildID BuildID, body PostV2TemplatesTemplateIDBuildsBuildIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2TemplatesTemplateIDBuildsBuildIDRequestWithBody(server, templateID, buildID, "application/json", bodyReader)
}

// NewPostV2TemplatesTemplateIDBuildsBuildIDRequestWithBody generates requests for PostV2TemplatesTemplateIDBuildsBuildID with any type of body
func NewPostV2TemplatesTemplateIDBuildsBuildIDRequestWithBody(server string, templateID TemplateID, buildID BuildID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/templates/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV3TemplatesRequest calls the generic PostV3Templates builder with application/json body
func NewPostV3TemplatesRequest(server string, body PostV3TemplatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV3TemplatesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV3TemplatesRequestWithBody generates requests for PostV3Templates with any type of body
func NewPostV3TemplatesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostAccessTokensWithBodyWithResponse request with any body
	PostAccessTokensWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAccessTokensResponse, error)

	PostAccessTokensWithResponse(ctx context.Context, body PostAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAccessTokensResponse, error)

	// DeleteAccessTokensAccessTokenIDWithResponse request
	DeleteAccessTokensAccessTokenIDWithResponse(ctx context.Context, accessTokenID AccessTokenID, reqEditors ...RequestEditorFn) (*DeleteAccessTokensAccessTokenIDResponse, error)

	// PostAdminTeamsTeamIDSandboxesKillWithResponse request
	PostAdminTeamsTeamIDSandboxesKillWithResponse(ctx context.Context, teamID openapi_types.UUID, reqEditors ...RequestEditorFn) (*PostAdminTeamsTeamIDSandboxesKillResponse, error)

	// GetApiKeysWithResponse request
	GetApiKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApiKeysResponse, error)

	// PostApiKeysWithBodyWithResponse request with any body
	PostApiKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiKeysResponse, error)

	PostApiKeysWithResponse(ctx context.Context, body PostApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiKeysResponse, error)

	// DeleteApiKeysApiKeyIDWithResponse request
	DeleteApiKeysApiKeyIDWithResponse(ctx context.Context, apiKeyID ApiKeyID, reqEditors ...RequestEditorFn) (*DeleteApiKeysApiKeyIDResponse, error)

	// PatchApiKeysApiKeyIDWithBodyWithResponse request with any body
	PatchApiKeysApiKeyIDWithBodyWithResponse(ctx context.Context, apiKeyID ApiKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApiKeysApiKeyIDResponse, error)

	PatchApiKeysApiKeyIDWithResponse(ctx context.Context, apiKeyID ApiKeyID, body PatchApiKeysApiKeyIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApiKeysApiKeyIDResponse, error)

	// GetHealthWithResponse request
	GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error)

	// GetNodesWithResponse request
	GetNodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNodesResponse, error)

	// GetNodesNodeIDWithResponse request
	GetNodesNodeIDWithResponse(ctx context.Context, nodeID NodeID, params *GetNodesNodeIDParams, reqEditors ...RequestEditorFn) (*GetNodesNodeIDResponse, error)

	// PostNodesNodeIDWithBodyWithResponse request with any body
	PostNodesNodeIDWithBodyWithResponse(ctx context.Context, nodeID NodeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodesNodeIDResponse, error)

	PostNodesNodeIDWithResponse(ctx context.Context, nodeID NodeID, body PostNodesNodeIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodesNodeIDResponse, error)

	// GetSandboxesWithResponse request
	GetSandboxesWithResponse(ctx context.Context, params *GetSandboxesParams, reqEditors ...RequestEditorFn) (*GetSandboxesResponse, error)

	// PostSandboxesWithBodyWithResponse request with any body
	PostSandboxesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesResponse, error)

	PostSandboxesWithResponse(ctx context.Context, body PostSandboxesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesResponse, error)

	// GetSandboxesMetricsWithResponse request
	GetSandboxesMetricsWithResponse(ctx context.Context, params *GetSandboxesMetricsParams, reqEditors ...RequestEditorFn) (*GetSandboxesMetricsResponse, error)

	// DeleteSandboxesSandboxIDWithResponse request
	DeleteSandboxesSandboxIDWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*DeleteSandboxesSandboxIDResponse, error)

	// GetSandboxesSandboxIDWithResponse request
	GetSandboxesSandboxIDWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*GetSandboxesSandboxIDResponse, error)

	// PostSandboxesSandboxIDConnectWithBodyWithResponse request with any body
	PostSandboxesSandboxIDConnectWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDConnectResponse, error)

	PostSandboxesSandboxIDConnectWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDConnectResponse, error)

	// GetSandboxesSandboxIDLogsWithResponse request
	GetSandboxesSandboxIDLogsWithResponse(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDLogsParams, reqEditors ...RequestEditorFn) (*GetSandboxesSandboxIDLogsResponse, error)

	// GetSandboxesSandboxIDMetricsWithResponse request
	GetSandboxesSandboxIDMetricsWithResponse(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDMetricsParams, reqEditors ...RequestEditorFn) (*GetSandboxesSandboxIDMetricsResponse, error)

	// PostSandboxesSandboxIDPauseWithResponse request
	PostSandboxesSandboxIDPauseWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDPauseResponse, error)

	// PostSandboxesSandboxIDRefreshesWithBodyWithResponse request with any body
	PostSandboxesSandboxIDRefreshesWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDRefreshesResponse, error)

	PostSandboxesSandboxIDRefreshesWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDRefreshesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDRefreshesResponse, error)

	// PostSandboxesSandboxIDResumeWithBodyWithResponse request with any body
	PostSandboxesSandboxIDResumeWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDResumeResponse, error)

	PostSandboxesSandboxIDResumeWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDResumeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDResumeResponse, error)

	// PostSandboxesSandboxIDTimeoutWithBodyWithResponse request with any body
	PostSandboxesSandboxIDTimeoutWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDTimeoutResponse, error)

	PostSandboxesSandboxIDTimeoutWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDTimeoutResponse, error)

	// GetTeamsWithResponse request
	GetTeamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error)

	// GetTeamsTeamIDMetricsWithResponse request
	GetTeamsTeamIDMetricsWithResponse(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsParams, reqEditors ...RequestEditorFn) (*GetTeamsTeamIDMetricsResponse, error)

	// GetTeamsTeamIDMetricsMaxWithResponse request
	GetTeamsTeamIDMetricsMaxWithResponse(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsMaxParams, reqEditors ...RequestEditorFn) (*GetTeamsTeamIDMetricsMaxResponse, error)

	// GetTemplatesWithResponse request
	GetTemplatesWithResponse(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*GetTemplatesResponse, error)

	// PostTemplatesWithBodyWithResponse request with any body
	PostTemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTemplatesResponse, error)

	PostTemplatesWithResponse(ctx context.Context, body PostTemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTemplatesResponse, error)

	// GetTemplatesAliasesAliasWithResponse request
	GetTemplatesAliasesAliasWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*GetTemplatesAliasesAliasResponse, error)

	// DeleteTemplatesTagsWithBodyWithResponse request with any body
	DeleteTemplatesTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTemplatesTagsResponse, error)

	DeleteTemplatesTagsWithResponse(ctx context.Context, body DeleteTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTemplatesTagsResponse, error)

	// PostTemplatesTagsWithBodyWithResponse request with any body
	PostTemplatesTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTemplatesTagsResponse, error)

	PostTemplatesTagsWithResponse(ctx context.Context, body PostTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTemplatesTagsResponse, error)

	// DeleteTemplatesTemplateIDWithResponse request
	DeleteTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, reqEditors ...RequestEditorFn) (*DeleteTemplatesTemplateIDResponse, error)

	// GetTemplatesTemplateIDWithResponse request
	GetTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, params *GetTemplatesTemplateIDParams, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDResponse, error)

	// PatchTemplatesTemplateIDWithBodyWithResponse request with any body
	PatchTemplatesTemplateIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchTemplatesTemplateIDResponse, error)

	PatchTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, body PatchTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchTemplatesTemplateIDResponse, error)

	// PostTemplatesTemplateIDWithBodyWithResponse request with any body
	PostTemplatesTemplateIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTemplatesTemplateIDResponse, error)

	PostTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, body PostTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTemplatesTemplateIDResponse, error)

	// PostTemplatesTemplateIDBuildsBuildIDWithResponse request
	PostTemplatesTemplateIDBuildsBuildIDWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, reqEditors ...RequestEditorFn) (*PostTemplatesTemplateIDBuildsBuildIDResponse, error)

	// GetTemplatesTemplateIDBuildsBuildIDLogsWithResponse request
	GetTemplatesTemplateIDBuildsBuildIDLogsWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDLogsParams, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDBuildsBuildIDLogsResponse, error)

	// GetTemplatesTemplateIDBuildsBuildIDStatusWithResponse request
	GetTemplatesTemplateIDBuildsBuildIDStatusWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDStatusParams, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDBuildsBuildIDStatusResponse, error)

	// GetTemplatesTemplateIDFilesHashWithResponse request
	GetTemplatesTemplateIDFilesHashWithResponse(ctx context.Context, templateID TemplateID, hash string, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDFilesHashResponse, error)

	// GetV2SandboxesWithResponse request
	GetV2SandboxesWithResponse(ctx context.Context, params *GetV2SandboxesParams, reqEditors ...RequestEditorFn) (*GetV2SandboxesResponse, error)

	// GetV2SandboxesSandboxIDLogsWithResponse request
	GetV2SandboxesSandboxIDLogsWithResponse(ctx context.Context, sandboxID SandboxID, params *GetV2SandboxesSandboxIDLogsParams, reqEditors ...RequestEditorFn) (*GetV2SandboxesSandboxIDLogsResponse, error)

	// PostV2TemplatesWithBodyWithResponse request with any body
	PostV2TemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2TemplatesResponse, error)

	PostV2TemplatesWithResponse(ctx context.Context, body PostV2TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2TemplatesResponse, error)

	// PatchV2TemplatesTemplateIDWithBodyWithResponse request with any body
	PatchV2TemplatesTemplateIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2TemplatesTemplateIDResponse, error)

	PatchV2TemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, body PatchV2TemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2TemplatesTemplateIDResponse, error)

	// PostV2TemplatesTemplateIDBuildsBuildIDWithBodyWithResponse request with any body
	PostV2TemplatesTemplateIDBuildsBuildIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2TemplatesTemplateIDBuildsBuildIDResponse, error)

	PostV2TemplatesTemplateIDBuildsBuildIDWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, body PostV2TemplatesTemplateIDBuildsBuildIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2TemplatesTemplateIDBuildsBuildIDResponse, error)

	// PostV3TemplatesWithBodyWithResponse request with any body
	PostV3TemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV3TemplatesResponse, error)

	PostV3TemplatesWithResponse(ctx context.Context, body PostV3TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV3TemplatesResponse, error)
}

type PostAccessTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreatedAccessToken
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostAccessTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAccessTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAccessTokensAccessTokenIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteAccessTokensAccessTokenIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccessTokensAccessTokenIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAdminTeamsTeamIDSandboxesKillResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSandboxKillResult
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostAdminTeamsTeamIDSandboxesKillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAdminTeamsTeamIDSandboxesKillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamAPIKey
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreatedTeamAPIKey
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApiKeysApiKeyIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteApiKeysApiKeyIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApiKeysApiKeyIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApiKeysApiKeyIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PatchApiKeysApiKeyIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApiKeysApiKeyIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r GetHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Node
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNodesNodeIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NodeDetail
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetNodesNodeIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNodesNodeIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodesNodeIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostNodesNodeIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodesNodeIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListedSandbox
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetSandboxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSandboxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Sandbox
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostSandboxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSandboxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxesMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxesWithMetrics
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetSandboxesMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxesMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSandboxesSandboxIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteSandboxesSandboxIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSandboxesSandboxIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxesSandboxIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxDetail
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetSandboxesSandboxIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxesSandboxIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSandboxesSandboxIDConnectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
	JSON201      *Sandbox
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostSandboxesSandboxIDConnectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSandboxesSandboxIDConnectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxesSandboxIDLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxLogs
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetSandboxesSandboxIDLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxesSandboxIDLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxesSandboxIDMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SandboxMetric
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetSandboxesSandboxIDMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxesSandboxIDMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSandboxesSandboxIDPauseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON409      *N409
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostSandboxesSandboxIDPauseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSandboxesSandboxIDPauseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSandboxesSandboxIDRefreshesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r PostSandboxesSandboxIDRefreshesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSandboxesSandboxIDRefreshesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSandboxesSandboxIDResumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Sandbox
	JSON401      *N401
	JSON404      *N404
	JSON409      *N409
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostSandboxesSandboxIDResumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSandboxesSandboxIDResumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSandboxesSandboxIDTimeoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostSandboxesSandboxIDTimeoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSandboxesSandboxIDTimeoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsTeamIDMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamMetric
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTeamsTeamIDMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsTeamIDMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsTeamIDMetricsMaxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MaxTeamMetric
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTeamsTeamIDMetricsMaxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsTeamIDMetricsMaxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Template
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TemplateLegacy
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesAliasesAliasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateAliasResponse
	JSON400      *N400
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplatesAliasesAliasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesAliasesAliasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTemplatesTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteTemplatesTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTemplatesTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTemplatesTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AssignedTemplateTags
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostTemplatesTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTemplatesTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTemplatesTemplateIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteTemplatesTemplateIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTemplatesTemplateIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesTemplateIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateWithBuilds
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplatesTemplateIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesTemplateIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchTemplatesTemplateIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PatchTemplatesTemplateIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchTemplatesTemplateIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTemplatesTemplateIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TemplateLegacy
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostTemplatesTemplateIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTemplatesTemplateIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTemplatesTemplateIDBuildsBuildIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostTemplatesTemplateIDBuildsBuildIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTemplatesTemplateIDBuildsBuildIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesTemplateIDBuildsBuildIDLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateBuildLogsResponse
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplatesTemplateIDBuildsBuildIDLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesTemplateIDBuildsBuildIDLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesTemplateIDBuildsBuildIDStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateBuildInfo
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplatesTemplateIDBuildsBuildIDStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesTemplateIDBuildsBuildIDStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesTemplateIDFilesHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TemplateBuildFileUpload
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplatesTemplateIDFilesHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesTemplateIDFilesHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2SandboxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListedSandbox
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetV2SandboxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2SandboxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2SandboxesSandboxIDLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxLogsV2Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetV2SandboxesSandboxIDLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2SandboxesSandboxIDLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2TemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TemplateLegacy
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostV2TemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2TemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchV2TemplatesTemplateIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateUpdateResponse
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PatchV2TemplatesTemplateIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchV2TemplatesTemplateIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2TemplatesTemplateIDBuildsBuildIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostV2TemplatesTemplateIDBuildsBuildIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2TemplatesTemplateIDBuildsBuildIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV3TemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TemplateRequestResponseV3
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostV3TemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV3TemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostAccessTokensWithBodyWithResponse request with arbitrary body returning *PostAccessTokensResponse
func (c *ClientWithResponses) PostAccessTokensWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAccessTokensResponse, error) {
	rsp, err := c.PostAccessTokensWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAccessTokensResponse(rsp)
}

func (c *ClientWithResponses) PostAccessTokensWithResponse(ctx context.Context, body PostAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAccessTokensResponse, error) {
	rsp, err := c.PostAccessTokens(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAccessTokensResponse(rsp)
}

// DeleteAccessTokensAccessTokenIDWithResponse request returning *DeleteAccessTokensAccessTokenIDResponse
func (c *ClientWithResponses) DeleteAccessTokensAccessTokenIDWithResponse(ctx context.Context, accessTokenID AccessTokenID, reqEditors ...RequestEditorFn) (*DeleteAccessTokensAccessTokenIDResponse, error) {
	rsp, err := c.DeleteAccessTokensAccessTokenID(ctx, accessTokenID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccessTokensAccessTokenIDResponse(rsp)
}

// PostAdminTeamsTeamIDSandboxesKillWithResponse request returning *PostAdminTeamsTeamIDSandboxesKillResponse
func (c *ClientWithResponses) PostAdminTeamsTeamIDSandboxesKillWithResponse(ctx context.Context, teamID openapi_types.UUID, reqEditors ...RequestEditorFn) (*PostAdminTeamsTeamIDSandboxesKillResponse, error) {
	rsp, err := c.PostAdminTeamsTeamIDSandboxesKill(ctx, teamID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAdminTeamsTeamIDSandboxesKillResponse(rsp)
}

// GetApiKeysWithResponse request returning *GetApiKeysResponse
func (c *ClientWithResponses) GetApiKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApiKeysResponse, error) {
	rsp, err := c.GetApiKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiKeysResponse(rsp)
}

// PostApiKeysWithBodyWithResponse request with arbitrary body returning *PostApiKeysResponse
func (c *ClientWithResponses) PostApiKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiKeysResponse, error) {
	rsp, err := c.PostApiKeysWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiKeysResponse(rsp)
}

func (c *ClientWithResponses) PostApiKeysWithResponse(ctx context.Context, body PostApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiKeysResponse, error) {
	rsp, err := c.PostApiKeys(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiKeysResponse(rsp)
}

// DeleteApiKeysApiKeyIDWithResponse request returning *DeleteApiKeysApiKeyIDResponse
func (c *ClientWithResponses) DeleteApiKeysApiKeyIDWithResponse(ctx context.Context, apiKeyID ApiKeyID, reqEditors ...RequestEditorFn) (*DeleteApiKeysApiKeyIDResponse, error) {
	rsp, err := c.DeleteApiKeysApiKeyID(ctx, apiKeyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApiKeysApiKeyIDResponse(rsp)
}

// PatchApiKeysApiKeyIDWithBodyWithResponse request with arbitrary body returning *PatchApiKeysApiKeyIDResponse
func (c *ClientWithResponses) PatchApiKeysApiKeyIDWithBodyWithResponse(ctx context.Context, apiKeyID ApiKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApiKeysApiKeyIDResponse, error) {
	rsp, err := c.PatchApiKeysApiKeyIDWithBody(ctx, apiKeyID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApiKeysApiKeyIDResponse(rsp)
}

func (c *ClientWithResponses) PatchApiKeysApiKeyIDWithResponse(ctx context.Context, apiKeyID ApiKeyID, body PatchApiKeysApiKeyIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApiKeysApiKeyIDResponse, error) {
	rsp, err := c.PatchApiKeysApiKeyID(ctx, apiKeyID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApiKeysApiKeyIDResponse(rsp)
}

// GetHealthWithResponse request returning *GetHealthResponse
func (c *ClientWithResponses) GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error) {
	rsp, err := c.GetHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthResponse(rsp)
}

// GetNodesWithResponse request returning *GetNodesResponse
func (c *ClientWithResponses) GetNodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNodesResponse, error) {
	rsp, err := c.GetNodes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNodesResponse(rsp)
}

// GetNodesNodeIDWithResponse request returning *GetNodesNodeIDResponse
func (c *ClientWithResponses) GetNodesNodeIDWithResponse(ctx context.Context, nodeID NodeID, params *GetNodesNodeIDParams, reqEditors ...RequestEditorFn) (*GetNodesNodeIDResponse, error) {
	rsp, err := c.GetNodesNodeID(ctx, nodeID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNodesNodeIDResponse(rsp)
}

// PostNodesNodeIDWithBodyWithResponse request with arbitrary body returning *PostNodesNodeIDResponse
func (c *ClientWithResponses) PostNodesNodeIDWithBodyWithResponse(ctx context.Context, nodeID NodeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodesNodeIDResponse, error) {
	rsp, err := c.PostNodesNodeIDWithBody(ctx, nodeID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodesNodeIDResponse(rsp)
}

func (c *ClientWithResponses) PostNodesNodeIDWithResponse(ctx context.Context, nodeID NodeID, body PostNodesNodeIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodesNodeIDResponse, error) {
	rsp, err := c.PostNodesNodeID(ctx, nodeID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodesNodeIDResponse(rsp)
}

// GetSandboxesWithResponse request returning *GetSandboxesResponse
func (c *ClientWithResponses) GetSandboxesWithResponse(ctx context.Context, params *GetSandboxesParams, reqEditors ...RequestEditorFn) (*GetSandboxesResponse, error) {
	rsp, err := c.GetSandboxes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxesResponse(rsp)
}

// PostSandboxesWithBodyWithResponse request with arbitrary body returning *PostSandboxesResponse
func (c *ClientWithResponses) PostSandboxesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesResponse, error) {
	rsp, err := c.PostSandboxesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesResponse(rsp)
}

func (c *ClientWithResponses) PostSandboxesWithResponse(ctx context.Context, body PostSandboxesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesResponse, error) {
	rsp, err := c.PostSandboxes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesResponse(rsp)
}

// GetSandboxesMetricsWithResponse request returning *GetSandboxesMetricsResponse
func (c *ClientWithResponses) GetSandboxesMetricsWithResponse(ctx context.Context, params *GetSandboxesMetricsParams, reqEditors ...RequestEditorFn) (*GetSandboxesMetricsResponse, error) {
	rsp, err := c.GetSandboxesMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxesMetricsResponse(rsp)
}

// DeleteSandboxesSandboxIDWithResponse request returning *DeleteSandboxesSandboxIDResponse
func (c *ClientWithResponses) DeleteSandboxesSandboxIDWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*DeleteSandboxesSandboxIDResponse, error) {
	rsp, err := c.DeleteSandboxesSandboxID(ctx, sandboxID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSandboxesSandboxIDResponse(rsp)
}

// GetSandboxesSandboxIDWithResponse request returning *GetSandboxesSandboxIDResponse
func (c *ClientWithResponses) GetSandboxesSandboxIDWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*GetSandboxesSandboxIDResponse, error) {
	rsp, err := c.GetSandboxesSandboxID(ctx, sandboxID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxesSandboxIDResponse(rsp)
}

// PostSandboxesSandboxIDConnectWithBodyWithResponse request with arbitrary body returning *PostSandboxesSandboxIDConnectResponse
func (c *ClientWithResponses) PostSandboxesSandboxIDConnectWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDConnectResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDConnectWithBody(ctx, sandboxID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDConnectResponse(rsp)
}

func (c *ClientWithResponses) PostSandboxesSandboxIDConnectWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDConnectResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDConnect(ctx, sandboxID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDConnectResponse(rsp)
}

// GetSandboxesSandboxIDLogsWithResponse request returning *GetSandboxesSandboxIDLogsResponse
func (c *ClientWithResponses) GetSandboxesSandboxIDLogsWithResponse(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDLogsParams, reqEditors ...RequestEditorFn) (*GetSandboxesSandboxIDLogsResponse, error) {
	rsp, err := c.GetSandboxesSandboxIDLogs(ctx, sandboxID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxesSandboxIDLogsResponse(rsp)
}

// GetSandboxesSandboxIDMetricsWithResponse request returning *GetSandboxesSandboxIDMetricsResponse
func (c *ClientWithResponses) GetSandboxesSandboxIDMetricsWithResponse(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDMetricsParams, reqEditors ...RequestEditorFn) (*GetSandboxesSandboxIDMetricsResponse, error) {
	rsp, err := c.GetSandboxesSandboxIDMetrics(ctx, sandboxID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxesSandboxIDMetricsResponse(rsp)
}

// PostSandboxesSandboxIDPauseWithResponse request returning *PostSandboxesSandboxIDPauseResponse
func (c *ClientWithResponses) PostSandboxesSandboxIDPauseWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDPauseResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDPause(ctx, sandboxID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDPauseResponse(rsp)
}

// PostSandboxesSandboxIDRefreshesWithBodyWithResponse request with arbitrary body returning *PostSandboxesSandboxIDRefreshesResponse
func (c *ClientWithResponses) PostSandboxesSandboxIDRefreshesWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDRefreshesResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDRefreshesWithBody(ctx, sandboxID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDRefreshesResponse(rsp)
}

func (c *ClientWithResponses) PostSandboxesSandboxIDRefreshesWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDRefreshesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDRefreshesResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDRefreshes(ctx, sandboxID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDRefreshesResponse(rsp)
}

// PostSandboxesSandboxIDResumeWithBodyWithResponse request with arbitrary body returning *PostSandboxesSandboxIDResumeResponse
func (c *ClientWithResponses) PostSandboxesSandboxIDResumeWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDResumeResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDResumeWithBody(ctx, sandboxID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDResumeResponse(rsp)
}

func (c *ClientWithResponses) PostSandboxesSandboxIDResumeWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDResumeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDResumeResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDResume(ctx, sandboxID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDResumeResponse(rsp)
}

// PostSandboxesSandboxIDTimeoutWithBodyWithResponse request with arbitrary body returning *PostSandboxesSandboxIDTimeoutResponse
func (c *ClientWithResponses) PostSandboxesSandboxIDTimeoutWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDTimeoutResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDTimeoutWithBody(ctx, sandboxID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDTimeoutResponse(rsp)
}

func (c *ClientWithResponses) PostSandboxesSandboxIDTimeoutWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDTimeoutResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDTimeout(ctx, sandboxID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDTimeoutResponse(rsp)
}

// GetTeamsWithResponse request returning *GetTeamsResponse
func (c *ClientWithResponses) GetTeamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error) {
	rsp, err := c.GetTeams(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsResponse(rsp)
}

// GetTeamsTeamIDMetricsWithResponse request returning *GetTeamsTeamIDMetricsResponse
func (c *ClientWithResponses) GetTeamsTeamIDMetricsWithResponse(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsParams, reqEditors ...RequestEditorFn) (*GetTeamsTeamIDMetricsResponse, error) {
	rsp, err := c.GetTeamsTeamIDMetrics(ctx, teamID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsTeamIDMetricsResponse(rsp)
}

// GetTeamsTeamIDMetricsMaxWithResponse request returning *GetTeamsTeamIDMetricsMaxResponse
func (c *ClientWithResponses) GetTeamsTeamIDMetricsMaxWithResponse(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsMaxParams, reqEditors ...RequestEditorFn) (*GetTeamsTeamIDMetricsMaxResponse, error) {
	rsp, err := c.GetTeamsTeamIDMetricsMax(ctx, teamID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsTeamIDMetricsMaxResponse(rsp)
}

// GetTemplatesWithResponse request returning *GetTemplatesResponse
func (c *ClientWithResponses) GetTemplatesWithResponse(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*GetTemplatesResponse, error) {
	rsp, err := c.GetTemplates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesResponse(rsp)
}

// PostTemplatesWithBodyWithResponse request with arbitrary body returning *PostTemplatesResponse
func (c *ClientWithResponses) PostTemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTemplatesResponse, error) {
	rsp, err := c.PostTemplatesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTemplatesResponse(rsp)
}

func (c *ClientWithResponses) PostTemplatesWithResponse(ctx context.Context, body PostTemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTemplatesResponse, error) {
	rsp, err := c.PostTemplates(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTemplatesResponse(rsp)
}

// GetTemplatesAliasesAliasWithResponse request returning *GetTemplatesAliasesAliasResponse
func (c *ClientWithResponses) GetTemplatesAliasesAliasWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*GetTemplatesAliasesAliasResponse, error) {
	rsp, err := c.GetTemplatesAliasesAlias(ctx, alias, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesAliasesAliasResponse(rsp)
}

// DeleteTemplatesTagsWithBodyWithResponse request with arbitrary body returning *DeleteTemplatesTagsResponse
func (c *ClientWithResponses) DeleteTemplatesTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTemplatesTagsResponse, error) {
	rsp, err := c.DeleteTemplatesTagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTemplatesTagsResponse(rsp)
}

func (c *ClientWithResponses) DeleteTemplatesTagsWithResponse(ctx context.Context, body DeleteTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTemplatesTagsResponse, error) {
	rsp, err := c.DeleteTemplatesTags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTemplatesTagsResponse(rsp)
}

// PostTemplatesTagsWithBodyWithResponse request with arbitrary body returning *PostTemplatesTagsResponse
func (c *ClientWithResponses) PostTemplatesTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTemplatesTagsResponse, error) {
	rsp, err := c.PostTemplatesTagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTemplatesTagsResponse(rsp)
}

func (c *ClientWithResponses) PostTemplatesTagsWithResponse(ctx context.Context, body PostTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTemplatesTagsResponse, error) {
	rsp, err := c.PostTemplatesTags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTemplatesTagsResponse(rsp)
}

// DeleteTemplatesTemplateIDWithResponse request returning *DeleteTemplatesTemplateIDResponse
func (c *ClientWithResponses) DeleteTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, reqEditors ...RequestEditorFn) (*DeleteTemplatesTemplateIDResponse, error) {
	rsp, err := c.DeleteTemplatesTemplateID(ctx, templateID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTemplatesTemplateIDResponse(rsp)
}

// GetTemplatesTemplateIDWithResponse request returning *GetTemplatesTemplateIDResponse
func (c *ClientWithResponses) GetTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, params *GetTemplatesTemplateIDParams, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDResponse, error) {
	rsp, err := c.GetTemplatesTemplateID(ctx, templateID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesTemplateIDResponse(rsp)
}

// PatchTemplatesTemplateIDWithBodyWithResponse request with arbitrary body returning *PatchTemplatesTemplateIDResponse
func (c *ClientWithResponses) PatchTemplatesTemplateIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchTemplatesTemplateIDResponse, error) {
	rsp, err := c.PatchTemplatesTemplateIDWithBody(ctx, templateID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchTemplatesTemplateIDResponse(rsp)
}

func (c *ClientWithResponses) PatchTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, body PatchTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchTemplatesTemplateIDResponse, error) {
	rsp, err := c.PatchTemplatesTemplateID(ctx, templateID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchTemplatesTemplateIDResponse(rsp)
}

// PostTemplatesTemplateIDWithBodyWithResponse request with arbitrary body returning *PostTemplatesTemplateIDResponse
func (c *ClientWithResponses) PostTemplatesTemplateIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTemplatesTemplateIDResponse, error) {
	rsp, err := c.PostTemplatesTemplateIDWithBody(ctx, templateID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTemplatesTemplateIDResponse(rsp)
}

func (c *ClientWithResponses) PostTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, body PostTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTemplatesTemplateIDResponse, error) {
	rsp, err := c.PostTemplatesTemplateID(ctx, templateID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTemplatesTemplateIDResponse(rsp)
}

// PostTemplatesTemplateIDBuildsBuildIDWithResponse request returning *PostTemplatesTemplateIDBuildsBuildIDResponse
func (c *ClientWithResponses) PostTemplatesTemplateIDBuildsBuildIDWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, reqEditors ...RequestEditorFn) (*PostTemplatesTemplateIDBuildsBuildIDResponse, error) {
	rsp, err := c.PostTemplatesTemplateIDBuildsBuildID(ctx, templateID, buildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTemplatesTemplateIDBuildsBuildIDResponse(rsp)
}

// GetTemplatesTemplateIDBuildsBuildIDLogsWithResponse request returning *GetTemplatesTemplateIDBuildsBuildIDLogsResponse
func (c *ClientWithResponses) GetTemplatesTemplateIDBuildsBuildIDLogsWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDLogsParams, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDBuildsBuildIDLogsResponse, error) {
	rsp, err := c.GetTemplatesTemplateIDBuildsBuildIDLogs(ctx, templateID, buildID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesTemplateIDBuildsBuildIDLogsResponse(rsp)
}

// GetTemplatesTemplateIDBuildsBuildIDStatusWithResponse request returning *GetTemplatesTemplateIDBuildsBuildIDStatusResponse
func (c *ClientWithResponses) GetTemplatesTemplateIDBuildsBuildIDStatusWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDStatusParams, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDBuildsBuildIDStatusResponse, error) {
	rsp, err := c.GetTemplatesTemplateIDBuildsBuildIDStatus(ctx, templateID, buildID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesTemplateIDBuildsBuildIDStatusResponse(rsp)
}

// GetTemplatesTemplateIDFilesHashWithResponse request returning *GetTemplatesTemplateIDFilesHashResponse
func (c *ClientWithResponses) GetTemplatesTemplateIDFilesHashWithResponse(ctx context.Context, templateID TemplateID, hash string, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDFilesHashResponse, error) {
	rsp, err := c.GetTemplatesTemplateIDFilesHash(ctx, templateID, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesTemplateIDFilesHashResponse(rsp)
}

// GetV2SandboxesWithResponse request returning *GetV2SandboxesResponse
func (c *ClientWithResponses) GetV2SandboxesWithResponse(ctx context.Context, params *GetV2SandboxesParams, reqEditors ...RequestEditorFn) (*GetV2SandboxesResponse, error) {
	rsp, err := c.GetV2Sandboxes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2SandboxesResponse(rsp)
}

// GetV2SandboxesSandboxIDLogsWithResponse request returning *GetV2SandboxesSandboxIDLogsResponse
func (c *ClientWithResponses) GetV2SandboxesSandboxIDLogsWithResponse(ctx context.Context, sandboxID SandboxID, params *GetV2SandboxesSandboxIDLogsParams, reqEditors ...RequestEditorFn) (*GetV2SandboxesSandboxIDLogsResponse, error) {
	rsp, err := c.GetV2SandboxesSandboxIDLogs(ctx, sandboxID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2SandboxesSandboxIDLogsResponse(rsp)
}

// PostV2TemplatesWithBodyWithResponse request with arbitrary body returning *PostV2TemplatesResponse
func (c *ClientWithResponses) PostV2TemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2TemplatesResponse, error) {
	rsp, err := c.PostV2TemplatesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2TemplatesResponse(rsp)
}

func (c *ClientWithResponses) PostV2TemplatesWithResponse(ctx context.Context, body PostV2TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2TemplatesResponse, error) {
	rsp, err := c.PostV2Templates(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2TemplatesResponse(rsp)
}

// PatchV2TemplatesTemplateIDWithBodyWithResponse request with arbitrary body returning *PatchV2TemplatesTemplateIDResponse
func (c *ClientWithResponses) PatchV2TemplatesTemplateIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2TemplatesTemplateIDResponse, error) {
	rsp, err := c.PatchV2TemplatesTemplateIDWithBody(ctx, templateID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2TemplatesTemplateIDResponse(rsp)
}

func (c *ClientWithResponses) PatchV2TemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, body PatchV2TemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2TemplatesTemplateIDResponse, error) {
	rsp, err := c.PatchV2TemplatesTemplateID(ctx, templateID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2TemplatesTemplateIDResponse(rsp)
}

// PostV2TemplatesTemplateIDBuildsBuildIDWithBodyWithResponse request with arbitrary body returning *PostV2TemplatesTemplateIDBuildsBuildIDResponse
func (c *ClientWithResponses) PostV2TemplatesTemplateIDBuildsBuildIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2TemplatesTemplateIDBuildsBuildIDResponse, error) {
	rsp, err := c.PostV2TemplatesTemplateIDBuildsBuildIDWithBody(ctx, templateID, buildID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2TemplatesTemplateIDBuildsBuildIDResponse(rsp)
}

func (c *ClientWithResponses) PostV2TemplatesTemplateIDBuildsBuildIDWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, body PostV2TemplatesTemplateIDBuildsBuildIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2TemplatesTemplateIDBuildsBuildIDResponse, error) {
	rsp, err := c.PostV2TemplatesTemplateIDBuildsBuildID(ctx, templateID, buildID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2TemplatesTemplateIDBuildsBuildIDResponse(rsp)
}

// PostV3TemplatesWithBodyWithResponse request with arbitrary body returning *PostV3TemplatesResponse
func (c *ClientWithResponses) PostV3TemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV3TemplatesResponse, error) {
	rsp, err := c.PostV3TemplatesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV3TemplatesResponse(rsp)
}

func (c *ClientWithResponses) PostV3TemplatesWithResponse(ctx context.Context, body PostV3TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV3TemplatesResponse, error) {
	rsp, err := c.PostV3Templates(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV3TemplatesResponse(rsp)
}

// ParsePostAccessTokensResponse parses an HTTP response from a PostAccessTokensWithResponse call
func ParsePostAccessTokensResponse(rsp *http.Response) (*PostAccessTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAccessTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreatedAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAccessTokensAccessTokenIDResponse parses an HTTP response from a DeleteAccessTokensAccessTokenIDWithResponse call
func ParseDeleteAccessTokensAccessTokenIDResponse(rsp *http.Response) (*DeleteAccessTokensAccessTokenIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccessTokensAccessTokenIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAdminTeamsTeamIDSandboxesKillResponse parses an HTTP response from a PostAdminTeamsTeamIDSandboxesKillWithResponse call
func ParsePostAdminTeamsTeamIDSandboxesKillResponse(rsp *http.Response) (*PostAdminTeamsTeamIDSandboxesKillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAdminTeamsTeamIDSandboxesKillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSandboxKillResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetApiKeysResponse parses an HTTP response from a GetApiKeysWithResponse call
func ParseGetApiKeysResponse(rsp *http.Response) (*GetApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamAPIKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostApiKeysResponse parses an HTTP response from a PostApiKeysWithResponse call
func ParsePostApiKeysResponse(rsp *http.Response) (*PostApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreatedTeamAPIKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteApiKeysApiKeyIDResponse parses an HTTP response from a DeleteApiKeysApiKeyIDWithResponse call
func ParseDeleteApiKeysApiKeyIDResponse(rsp *http.Response) (*DeleteApiKeysApiKeyIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApiKeysApiKeyIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchApiKeysApiKeyIDResponse parses an HTTP response from a PatchApiKeysApiKeyIDWithResponse call
func ParsePatchApiKeysApiKeyIDResponse(rsp *http.Response) (*PatchApiKeysApiKeyIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApiKeysApiKeyIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHealthResponse parses an HTTP response from a GetHealthWithResponse call
func ParseGetHealthResponse(rsp *http.Response) (*GetHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetNodesResponse parses an HTTP response from a GetNodesWithResponse call
func ParseGetNodesResponse(rsp *http.Response) (*GetNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Node
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNodesNodeIDResponse parses an HTTP response from a GetNodesNodeIDWithResponse call
func ParseGetNodesNodeIDResponse(rsp *http.Response) (*GetNodesNodeIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNodesNodeIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NodeDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostNodesNodeIDResponse parses an HTTP response from a PostNodesNodeIDWithResponse call
func ParsePostNodesNodeIDResponse(rsp *http.Response) (*PostNodesNodeIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodesNodeIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxesResponse parses an HTTP response from a GetSandboxesWithResponse call
func ParseGetSandboxesResponse(rsp *http.Response) (*GetSandboxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListedSandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSandboxesResponse parses an HTTP response from a PostSandboxesWithResponse call
func ParsePostSandboxesResponse(rsp *http.Response) (*PostSandboxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSandboxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxesMetricsResponse parses an HTTP response from a GetSandboxesMetricsWithResponse call
func ParseGetSandboxesMetricsResponse(rsp *http.Response) (*GetSandboxesMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxesMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxesWithMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSandboxesSandboxIDResponse parses an HTTP response from a DeleteSandboxesSandboxIDWithResponse call
func ParseDeleteSandboxesSandboxIDResponse(rsp *http.Response) (*DeleteSandboxesSandboxIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSandboxesSandboxIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxesSandboxIDResponse parses an HTTP response from a GetSandboxesSandboxIDWithResponse call
func ParseGetSandboxesSandboxIDResponse(rsp *http.Response) (*GetSandboxesSandboxIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxesSandboxIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSandboxesSandboxIDConnectResponse parses an HTTP response from a PostSandboxesSandboxIDConnectWithResponse call
func ParsePostSandboxesSandboxIDConnectResponse(rsp *http.Response) (*PostSandboxesSandboxIDConnectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSandboxesSandboxIDConnectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxesSandboxIDLogsResponse parses an HTTP response from a GetSandboxesSandboxIDLogsWithResponse call
func ParseGetSandboxesSandboxIDLogsResponse(rsp *http.Response) (*GetSandboxesSandboxIDLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxesSandboxIDLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxLogs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxesSandboxIDMetricsResponse parses an HTTP response from a GetSandboxesSandboxIDMetricsWithResponse call
func ParseGetSandboxesSandboxIDMetricsResponse(rsp *http.Response) (*GetSandboxesSandboxIDMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxesSandboxIDMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SandboxMetric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSandboxesSandboxIDPauseResponse parses an HTTP response from a PostSandboxesSandboxIDPauseWithResponse call
func ParsePostSandboxesSandboxIDPauseResponse(rsp *http.Response) (*PostSandboxesSandboxIDPauseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSandboxesSandboxIDPauseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSandboxesSandboxIDRefreshesResponse parses an HTTP response from a PostSandboxesSandboxIDRefreshesWithResponse call
func ParsePostSandboxesSandboxIDRefreshesResponse(rsp *http.Response) (*PostSandboxesSandboxIDRefreshesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSandboxesSandboxIDRefreshesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostSandboxesSandboxIDResumeResponse parses an HTTP response from a PostSandboxesSandboxIDResumeWithResponse call
func ParsePostSandboxesSandboxIDResumeResponse(rsp *http.Response) (*PostSandboxesSandboxIDResumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSandboxesSandboxIDResumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSandboxesSandboxIDTimeoutResponse parses an HTTP response from a PostSandboxesSandboxIDTimeoutWithResponse call
func ParsePostSandboxesSandboxIDTimeoutResponse(rsp *http.Response) (*PostSandboxesSandboxIDTimeoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSandboxesSandboxIDTimeoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamsResponse parses an HTTP response from a GetTeamsWithResponse call
func ParseGetTeamsResponse(rsp *http.Response) (*GetTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamsTeamIDMetricsResponse parses an HTTP response from a GetTeamsTeamIDMetricsWithResponse call
func ParseGetTeamsTeamIDMetricsResponse(rsp *http.Response) (*GetTeamsTeamIDMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsTeamIDMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamMetric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamsTeamIDMetricsMaxResponse parses an HTTP response from a GetTeamsTeamIDMetricsMaxWithResponse call
func ParseGetTeamsTeamIDMetricsMaxResponse(rsp *http.Response) (*GetTeamsTeamIDMetricsMaxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsTeamIDMetricsMaxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MaxTeamMetric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplatesResponse parses an HTTP response from a GetTemplatesWithResponse call
func ParseGetTemplatesResponse(rsp *http.Response) (*GetTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTemplatesResponse parses an HTTP response from a PostTemplatesWithResponse call
func ParsePostTemplatesResponse(rsp *http.Response) (*PostTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TemplateLegacy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplatesAliasesAliasResponse parses an HTTP response from a GetTemplatesAliasesAliasWithResponse call
func ParseGetTemplatesAliasesAliasResponse(rsp *http.Response) (*GetTemplatesAliasesAliasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesAliasesAliasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateAliasResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTemplatesTagsResponse parses an HTTP response from a DeleteTemplatesTagsWithResponse call
func ParseDeleteTemplatesTagsResponse(rsp *http.Response) (*DeleteTemplatesTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTemplatesTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTemplatesTagsResponse parses an HTTP response from a PostTemplatesTagsWithResponse call
func ParsePostTemplatesTagsResponse(rsp *http.Response) (*PostTemplatesTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTemplatesTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AssignedTemplateTags
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTemplatesTemplateIDResponse parses an HTTP response from a DeleteTemplatesTemplateIDWithResponse call
func ParseDeleteTemplatesTemplateIDResponse(rsp *http.Response) (*DeleteTemplatesTemplateIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTemplatesTemplateIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplatesTemplateIDResponse parses an HTTP response from a GetTemplatesTemplateIDWithResponse call
func ParseGetTemplatesTemplateIDResponse(rsp *http.Response) (*GetTemplatesTemplateIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesTemplateIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateWithBuilds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchTemplatesTemplateIDResponse parses an HTTP response from a PatchTemplatesTemplateIDWithResponse call
func ParsePatchTemplatesTemplateIDResponse(rsp *http.Response) (*PatchTemplatesTemplateIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchTemplatesTemplateIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTemplatesTemplateIDResponse parses an HTTP response from a PostTemplatesTemplateIDWithResponse call
func ParsePostTemplatesTemplateIDResponse(rsp *http.Response) (*PostTemplatesTemplateIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTemplatesTemplateIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TemplateLegacy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTemplatesTemplateIDBuildsBuildIDResponse parses an HTTP response from a PostTemplatesTemplateIDBuildsBuildIDWithResponse call
func ParsePostTemplatesTemplateIDBuildsBuildIDResponse(rsp *http.Response) (*PostTemplatesTemplateIDBuildsBuildIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTemplatesTemplateIDBuildsBuildIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplatesTemplateIDBuildsBuildIDLogsResponse parses an HTTP response from a GetTemplatesTemplateIDBuildsBuildIDLogsWithResponse call
func ParseGetTemplatesTemplateIDBuildsBuildIDLogsResponse(rsp *http.Response) (*GetTemplatesTemplateIDBuildsBuildIDLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesTemplateIDBuildsBuildIDLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateBuildLogsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplatesTemplateIDBuildsBuildIDStatusResponse parses an HTTP response from a GetTemplatesTemplateIDBuildsBuildIDStatusWithResponse call
func ParseGetTemplatesTemplateIDBuildsBuildIDStatusResponse(rsp *http.Response) (*GetTemplatesTemplateIDBuildsBuildIDStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesTemplateIDBuildsBuildIDStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateBuildInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplatesTemplateIDFilesHashResponse parses an HTTP response from a GetTemplatesTemplateIDFilesHashWithResponse call
func ParseGetTemplatesTemplateIDFilesHashResponse(rsp *http.Response) (*GetTemplatesTemplateIDFilesHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesTemplateIDFilesHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TemplateBuildFileUpload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2SandboxesResponse parses an HTTP response from a GetV2SandboxesWithResponse call
func ParseGetV2SandboxesResponse(rsp *http.Response) (*GetV2SandboxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2SandboxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListedSandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2SandboxesSandboxIDLogsResponse parses an HTTP response from a GetV2SandboxesSandboxIDLogsWithResponse call
func ParseGetV2SandboxesSandboxIDLogsResponse(rsp *http.Response) (*GetV2SandboxesSandboxIDLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2SandboxesSandboxIDLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxLogsV2Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV2TemplatesResponse parses an HTTP response from a PostV2TemplatesWithResponse call
func ParsePostV2TemplatesResponse(rsp *http.Response) (*PostV2TemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2TemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TemplateLegacy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchV2TemplatesTemplateIDResponse parses an HTTP response from a PatchV2TemplatesTemplateIDWithResponse call
func ParsePatchV2TemplatesTemplateIDResponse(rsp *http.Response) (*PatchV2TemplatesTemplateIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchV2TemplatesTemplateIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV2TemplatesTemplateIDBuildsBuildIDResponse parses an HTTP response from a PostV2TemplatesTemplateIDBuildsBuildIDWithResponse call
func ParsePostV2TemplatesTemplateIDBuildsBuildIDResponse(rsp *http.Response) (*PostV2TemplatesTemplateIDBuildsBuildIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2TemplatesTemplateIDBuildsBuildIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV3TemplatesResponse parses an HTTP response from a PostV3TemplatesWithResponse call
func ParsePostV3TemplatesResponse(rsp *http.Response) (*PostV3TemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV3TemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TemplateRequestResponseV3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /access-tokens)
	PostAccessTokens(c *gin.Context)

	// (DELETE /access-tokens/{accessTokenID})
	DeleteAccessTokensAccessTokenID(c *gin.Context, accessTokenID AccessTokenID)
	// Kill all sandboxes for a team
	// (POST /admin/teams/{teamID}/sandboxes/kill)
	PostAdminTeamsTeamIDSandboxesKill(c *gin.Context, teamID openapi_types.UUID)

	// (GET /api-keys)
	GetApiKeys(c *gin.Context)

	// (POST /api-keys)
	PostApiKeys(c *gin.Context)

	// (DELETE /api-keys/{apiKeyID})
	DeleteApiKeysApiKeyID(c *gin.Context, apiKeyID ApiKeyID)

	// (PATCH /api-keys/{apiKeyID})
	PatchApiKeysApiKeyID(c *gin.Context, apiKeyID ApiKeyID)

	// (GET /health)
	GetHealth(c *gin.Context)

	// (GET /nodes)
	GetNodes(c *gin.Context)

	// (GET /nodes/{nodeID})
	GetNodesNodeID(c *gin.Context, nodeID NodeID, params GetNodesNodeIDParams)

	// (POST /nodes/{nodeID})
	PostNodesNodeID(c *gin.Context, nodeID NodeID)

	// (GET /sandboxes)
	GetSandboxes(c *gin.Context, params GetSandboxesParams)

	// (POST /sandboxes)
	PostSandboxes(c *gin.Context)

	// (GET /sandboxes/metrics)
	GetSandboxesMetrics(c *gin.Context, params GetSandboxesMetricsParams)

	// (DELETE /sandboxes/{sandboxID})
	DeleteSandboxesSandboxID(c *gin.Context, sandboxID SandboxID)

	// (GET /sandboxes/{sandboxID})
	GetSandboxesSandboxID(c *gin.Context, sandboxID SandboxID)

	// (POST /sandboxes/{sandboxID}/connect)
	PostSandboxesSandboxIDConnect(c *gin.Context, sandboxID SandboxID)

	// (GET /sandboxes/{sandboxID}/logs)
	GetSandboxesSandboxIDLogs(c *gin.Context, sandboxID SandboxID, params GetSandboxesSandboxIDLogsParams)

	// (GET /sandboxes/{sandboxID}/metrics)
	GetSandboxesSandboxIDMetrics(c *gin.Context, sandboxID SandboxID, params GetSandboxesSandboxIDMetricsParams)

	// (POST /sandboxes/{sandboxID}/pause)
	PostSandboxesSandboxIDPause(c *gin.Context, sandboxID SandboxID)

	// (POST /sandboxes/{sandboxID}/refreshes)
	PostSandboxesSandboxIDRefreshes(c *gin.Context, sandboxID SandboxID)

	// (POST /sandboxes/{sandboxID}/resume)
	PostSandboxesSandboxIDResume(c *gin.Context, sandboxID SandboxID)

	// (POST /sandboxes/{sandboxID}/timeout)
	PostSandboxesSandboxIDTimeout(c *gin.Context, sandboxID SandboxID)

	// (GET /teams)
	GetTeams(c *gin.Context)

	// (GET /teams/{teamID}/metrics)
	GetTeamsTeamIDMetrics(c *gin.Context, teamID TeamID, params GetTeamsTeamIDMetricsParams)

	// (GET /teams/{teamID}/metrics/max)
	GetTeamsTeamIDMetricsMax(c *gin.Context, teamID TeamID, params GetTeamsTeamIDMetricsMaxParams)

	// (GET /templates)
	GetTemplates(c *gin.Context, params GetTemplatesParams)

	// (POST /templates)
	PostTemplates(c *gin.Context)

	// (GET /templates/aliases/{alias})
	GetTemplatesAliasesAlias(c *gin.Context, alias string)

	// (DELETE /templates/tags)
	DeleteTemplatesTags(c *gin.Context)

	// (POST /templates/tags)
	PostTemplatesTags(c *gin.Context)

	// (DELETE /templates/{templateID})
	DeleteTemplatesTemplateID(c *gin.Context, templateID TemplateID)

	// (GET /templates/{templateID})
	GetTemplatesTemplateID(c *gin.Context, templateID TemplateID, params GetTemplatesTemplateIDParams)

	// (PATCH /templates/{templateID})
	PatchTemplatesTemplateID(c *gin.Context, templateID TemplateID)

	// (POST /templates/{templateID})
	PostTemplatesTemplateID(c *gin.Context, templateID TemplateID)

	// (POST /templates/{templateID}/builds/{buildID})
	PostTemplatesTemplateIDBuildsBuildID(c *gin.Context, templateID TemplateID, buildID BuildID)

	// (GET /templates/{templateID}/builds/{buildID}/logs)
	GetTemplatesTemplateIDBuildsBuildIDLogs(c *gin.Context, templateID TemplateID, buildID BuildID, params GetTemplatesTemplateIDBuildsBuildIDLogsParams)

	// (GET /templates/{templateID}/builds/{buildID}/status)
	GetTemplatesTemplateIDBuildsBuildIDStatus(c *gin.Context, templateID TemplateID, buildID BuildID, params GetTemplatesTemplateIDBuildsBuildIDStatusParams)

	// (GET /templates/{templateID}/files/{hash})
	GetTemplatesTemplateIDFilesHash(c *gin.Context, templateID TemplateID, hash string)

	// (GET /v2/sandboxes)
	GetV2Sandboxes(c *gin.Context, params GetV2SandboxesParams)

	// (GET /v2/sandboxes/{sandboxID}/logs)
	GetV2SandboxesSandboxIDLogs(c *gin.Context, sandboxID SandboxID, params GetV2SandboxesSandboxIDLogsParams)

	// (POST /v2/templates)
	PostV2Templates(c *gin.Context)

	// (PATCH /v2/templates/{templateID})
	PatchV2TemplatesTemplateID(c *gin.Context, templateID TemplateID)

	// (POST /v2/templates/{templateID}/builds/{buildID})
	PostV2TemplatesTemplateIDBuildsBuildID(c *gin.Context, templateID TemplateID, buildID BuildID)

	// (POST /v3/templates)
	PostV3Templates(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// PostAccessTokens operation middleware
func (siw *ServerInterfaceWrapper) PostAccessTokens(c *gin.Context) {

	c.Set(Supabase1TokenAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostAccessTokens(c)
}

// DeleteAccessTokensAccessTokenID operation middleware
func (siw *ServerInterfaceWrapper) DeleteAccessTokensAccessTokenID(c *gin.Context) {

	var err error

	// ------------- Path parameter "accessTokenID" -------------
	var accessTokenID AccessTokenID

	err = runtime.BindStyledParameterWithOptions("simple", "accessTokenID", c.Param("accessTokenID"), &accessTokenID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter accessTokenID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(Supabase1TokenAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteAccessTokensAccessTokenID(c, accessTokenID)
}

// PostAdminTeamsTeamIDSandboxesKill operation middleware
func (siw *ServerInterfaceWrapper) PostAdminTeamsTeamIDSandboxesKill(c *gin.Context) {

	var err error

	// ------------- Path parameter "teamID" -------------
	var teamID openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "teamID", c.Param("teamID"), &teamID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter teamID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AdminTokenAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostAdminTeamsTeamIDSandboxesKill(c, teamID)
}

// GetApiKeys operation middleware
func (siw *ServerInterfaceWrapper) GetApiKeys(c *gin.Context) {

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetApiKeys(c)
}

// PostApiKeys operation middleware
func (siw *ServerInterfaceWrapper) PostApiKeys(c *gin.Context) {

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostApiKeys(c)
}

// DeleteApiKeysApiKeyID operation middleware
func (siw *ServerInterfaceWrapper) DeleteApiKeysApiKeyID(c *gin.Context) {

	var err error

	// ------------- Path parameter "apiKeyID" -------------
	var apiKeyID ApiKeyID

	err = runtime.BindStyledParameterWithOptions("simple", "apiKeyID", c.Param("apiKeyID"), &apiKeyID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter apiKeyID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteApiKeysApiKeyID(c, apiKeyID)
}

// PatchApiKeysApiKeyID operation middleware
func (siw *ServerInterfaceWrapper) PatchApiKeysApiKeyID(c *gin.Context) {

	var err error

	// ------------- Path parameter "apiKeyID" -------------
	var apiKeyID ApiKeyID

	err = runtime.BindStyledParameterWithOptions("simple", "apiKeyID", c.Param("apiKeyID"), &apiKeyID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter apiKeyID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchApiKeysApiKeyID(c, apiKeyID)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// GetNodes operation middleware
func (siw *ServerInterfaceWrapper) GetNodes(c *gin.Context) {

	c.Set(AdminTokenAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetNodes(c)
}

// GetNodesNodeID operation middleware
func (siw *ServerInterfaceWrapper) GetNodesNodeID(c *gin.Context) {

	var err error

	// ------------- Path parameter "nodeID" -------------
	var nodeID NodeID

	err = runtime.BindStyledParameterWithOptions("simple", "nodeID", c.Param("nodeID"), &nodeID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nodeID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AdminTokenAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNodesNodeIDParams

	// ------------- Optional query parameter "clusterID" -------------

	err = runtime.BindQueryParameter("form", true, false, "clusterID", c.Request.URL.Query(), &params.ClusterID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter clusterID: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetNodesNodeID(c, nodeID, params)
}

// PostNodesNodeID operation middleware
func (siw *ServerInterfaceWrapper) PostNodesNodeID(c *gin.Context) {

	var err error

	// ------------- Path parameter "nodeID" -------------
	var nodeID NodeID

	err = runtime.BindStyledParameterWithOptions("simple", "nodeID", c.Param("nodeID"), &nodeID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nodeID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AdminTokenAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostNodesNodeID(c, nodeID)
}

// GetSandboxes operation middleware
func (siw *ServerInterfaceWrapper) GetSandboxes(c *gin.Context) {

	var err error

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSandboxesParams

	// ------------- Optional query parameter "metadata" -------------

	err = runtime.BindQueryParameter("form", true, false, "metadata", c.Request.URL.Query(), &params.Metadata)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter metadata: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSandboxes(c, params)
}

// PostSandboxes operation middleware
func (siw *ServerInterfaceWrapper) PostSandboxes(c *gin.Context) {

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSandboxes(c)
}

// GetSandboxesMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetSandboxesMetrics(c *gin.Context) {

	var err error

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSandboxesMetricsParams

	// ------------- Required query parameter "sandbox_ids" -------------

	if paramValue := c.Query("sandbox_ids"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument sandbox_ids is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", false, true, "sandbox_ids", c.Request.URL.Query(), &params.SandboxIds)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandbox_ids: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSandboxesMetrics(c, params)
}

// DeleteSandboxesSandboxID operation middleware
func (siw *ServerInterfaceWrapper) DeleteSandboxesSandboxID(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteSandboxesSandboxID(c, sandboxID)
}

// GetSandboxesSandboxID operation middleware
func (siw *ServerInterfaceWrapper) GetSandboxesSandboxID(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSandboxesSandboxID(c, sandboxID)
}

// PostSandboxesSandboxIDConnect operation middleware
func (siw *ServerInterfaceWrapper) PostSandboxesSandboxIDConnect(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSandboxesSandboxIDConnect(c, sandboxID)
}

// GetSandboxesSandboxIDLogs operation middleware
func (siw *ServerInterfaceWrapper) GetSandboxesSandboxIDLogs(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSandboxesSandboxIDLogsParams

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", c.Request.URL.Query(), &params.Start)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter start: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSandboxesSandboxIDLogs(c, sandboxID, params)
}

// GetSandboxesSandboxIDMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetSandboxesSandboxIDMetrics(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSandboxesSandboxIDMetricsParams

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", c.Request.URL.Query(), &params.Start)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter start: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", c.Request.URL.Query(), &params.End)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter end: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSandboxesSandboxIDMetrics(c, sandboxID, params)
}

// PostSandboxesSandboxIDPause operation middleware
func (siw *ServerInterfaceWrapper) PostSandboxesSandboxIDPause(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSandboxesSandboxIDPause(c, sandboxID)
}

// PostSandboxesSandboxIDRefreshes operation middleware
func (siw *ServerInterfaceWrapper) PostSandboxesSandboxIDRefreshes(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSandboxesSandboxIDRefreshes(c, sandboxID)
}

// PostSandboxesSandboxIDResume operation middleware
func (siw *ServerInterfaceWrapper) PostSandboxesSandboxIDResume(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSandboxesSandboxIDResume(c, sandboxID)
}

// PostSandboxesSandboxIDTimeout operation middleware
func (siw *ServerInterfaceWrapper) PostSandboxesSandboxIDTimeout(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSandboxesSandboxIDTimeout(c, sandboxID)
}

// GetTeams operation middleware
func (siw *ServerInterfaceWrapper) GetTeams(c *gin.Context) {

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTeams(c)
}

// GetTeamsTeamIDMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetTeamsTeamIDMetrics(c *gin.Context) {

	var err error

	// ------------- Path parameter "teamID" -------------
	var teamID TeamID

	err = runtime.BindStyledParameterWithOptions("simple", "teamID", c.Param("teamID"), &teamID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter teamID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTeamsTeamIDMetricsParams

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", c.Request.URL.Query(), &params.Start)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter start: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", c.Request.URL.Query(), &params.End)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter end: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTeamsTeamIDMetrics(c, teamID, params)
}

// GetTeamsTeamIDMetricsMax operation middleware
func (siw *ServerInterfaceWrapper) GetTeamsTeamIDMetricsMax(c *gin.Context) {

	var err error

	// ------------- Path parameter "teamID" -------------
	var teamID TeamID

	err = runtime.BindStyledParameterWithOptions("simple", "teamID", c.Param("teamID"), &teamID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter teamID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTeamsTeamIDMetricsMaxParams

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", c.Request.URL.Query(), &params.Start)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter start: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", c.Request.URL.Query(), &params.End)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter end: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "metric" -------------

	if paramValue := c.Query("metric"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument metric is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "metric", c.Request.URL.Query(), &params.Metric)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter metric: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTeamsTeamIDMetricsMax(c, teamID, params)
}

// GetTemplates operation middleware
func (siw *ServerInterfaceWrapper) GetTemplates(c *gin.Context) {

	var err error

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTemplatesParams

	// ------------- Optional query parameter "teamID" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamID", c.Request.URL.Query(), &params.TeamID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter teamID: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTemplates(c, params)
}

// PostTemplates operation middleware
func (siw *ServerInterfaceWrapper) PostTemplates(c *gin.Context) {

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostTemplates(c)
}

// GetTemplatesAliasesAlias operation middleware
func (siw *ServerInterfaceWrapper) GetTemplatesAliasesAlias(c *gin.Context) {

	var err error

	// ------------- Path parameter "alias" -------------
	var alias string

	err = runtime.BindStyledParameterWithOptions("simple", "alias", c.Param("alias"), &alias, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter alias: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTemplatesAliasesAlias(c, alias)
}

// DeleteTemplatesTags operation middleware
func (siw *ServerInterfaceWrapper) DeleteTemplatesTags(c *gin.Context) {

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteTemplatesTags(c)
}

// PostTemplatesTags operation middleware
func (siw *ServerInterfaceWrapper) PostTemplatesTags(c *gin.Context) {

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostTemplatesTags(c)
}

// DeleteTemplatesTemplateID operation middleware
func (siw *ServerInterfaceWrapper) DeleteTemplatesTemplateID(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteTemplatesTemplateID(c, templateID)
}

// GetTemplatesTemplateID operation middleware
func (siw *ServerInterfaceWrapper) GetTemplatesTemplateID(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTemplatesTemplateIDParams

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", c.Request.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nextToken: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTemplatesTemplateID(c, templateID, params)
}

// PatchTemplatesTemplateID operation middleware
func (siw *ServerInterfaceWrapper) PatchTemplatesTemplateID(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchTemplatesTemplateID(c, templateID)
}

// PostTemplatesTemplateID operation middleware
func (siw *ServerInterfaceWrapper) PostTemplatesTemplateID(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostTemplatesTemplateID(c, templateID)
}

// PostTemplatesTemplateIDBuildsBuildID operation middleware
func (siw *ServerInterfaceWrapper) PostTemplatesTemplateIDBuildsBuildID(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "buildID" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "buildID", c.Param("buildID"), &buildID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter buildID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostTemplatesTemplateIDBuildsBuildID(c, templateID, buildID)
}

// GetTemplatesTemplateIDBuildsBuildIDLogs operation middleware
func (siw *ServerInterfaceWrapper) GetTemplatesTemplateIDBuildsBuildIDLogs(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "buildID" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "buildID", c.Param("buildID"), &buildID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter buildID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTemplatesTemplateIDBuildsBuildIDLogsParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", c.Request.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter cursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", c.Request.URL.Query(), &params.Direction)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter direction: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "level" -------------

	err = runtime.BindQueryParameter("form", true, false, "level", c.Request.URL.Query(), &params.Level)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter level: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "source" -------------

	err = runtime.BindQueryParameter("form", true, false, "source", c.Request.URL.Query(), &params.Source)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter source: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTemplatesTemplateIDBuildsBuildIDLogs(c, templateID, buildID, params)
}

// GetTemplatesTemplateIDBuildsBuildIDStatus operation middleware
func (siw *ServerInterfaceWrapper) GetTemplatesTemplateIDBuildsBuildIDStatus(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "buildID" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "buildID", c.Param("buildID"), &buildID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter buildID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTemplatesTemplateIDBuildsBuildIDStatusParams

	// ------------- Optional query parameter "logsOffset" -------------

	err = runtime.BindQueryParameter("form", true, false, "logsOffset", c.Request.URL.Query(), &params.LogsOffset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter logsOffset: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "level" -------------

	err = runtime.BindQueryParameter("form", true, false, "level", c.Request.URL.Query(), &params.Level)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter level: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTemplatesTemplateIDBuildsBuildIDStatus(c, templateID, buildID, params)
}

// GetTemplatesTemplateIDFilesHash operation middleware
func (siw *ServerInterfaceWrapper) GetTemplatesTemplateIDFilesHash(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "hash" -------------
	var hash string

	err = runtime.BindStyledParameterWithOptions("simple", "hash", c.Param("hash"), &hash, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter hash: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTemplatesTemplateIDFilesHash(c, templateID, hash)
}

// GetV2Sandboxes operation middleware
func (siw *ServerInterfaceWrapper) GetV2Sandboxes(c *gin.Context) {

	var err error

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetV2SandboxesParams

	// ------------- Optional query parameter "metadata" -------------

	err = runtime.BindQueryParameter("form", true, false, "metadata", c.Request.URL.Query(), &params.Metadata)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter metadata: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", false, false, "state", c.Request.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter state: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", c.Request.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nextToken: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetV2Sandboxes(c, params)
}

// GetV2SandboxesSandboxIDLogs operation middleware
func (siw *ServerInterfaceWrapper) GetV2SandboxesSandboxIDLogs(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetV2SandboxesSandboxIDLogsParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", c.Request.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter cursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", c.Request.URL.Query(), &params.Direction)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter direction: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetV2SandboxesSandboxIDLogs(c, sandboxID, params)
}

// PostV2Templates operation middleware
func (siw *ServerInterfaceWrapper) PostV2Templates(c *gin.Context) {

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostV2Templates(c)
}

// PatchV2TemplatesTemplateID operation middleware
func (siw *ServerInterfaceWrapper) PatchV2TemplatesTemplateID(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchV2TemplatesTemplateID(c, templateID)
}

// PostV2TemplatesTemplateIDBuildsBuildID operation middleware
func (siw *ServerInterfaceWrapper) PostV2TemplatesTemplateIDBuildsBuildID(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "buildID" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "buildID", c.Param("buildID"), &buildID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter buildID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostV2TemplatesTemplateIDBuildsBuildID(c, templateID, buildID)
}

// PostV3Templates operation middleware
func (siw *ServerInterfaceWrapper) PostV3Templates(c *gin.Context) {

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostV3Templates(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/access-tokens", wrapper.PostAccessTokens)
	router.DELETE(options.BaseURL+"/access-tokens/:accessTokenID", wrapper.DeleteAccessTokensAccessTokenID)
	router.POST(options.BaseURL+"/admin/teams/:teamID/sandboxes/kill", wrapper.PostAdminTeamsTeamIDSandboxesKill)
	router.GET(options.BaseURL+"/api-keys", wrapper.GetApiKeys)
	router.POST(options.BaseURL+"/api-keys", wrapper.PostApiKeys)
	router.DELETE(options.BaseURL+"/api-keys/:apiKeyID", wrapper.DeleteApiKeysApiKeyID)
	router.PATCH(options.BaseURL+"/api-keys/:apiKeyID", wrapper.PatchApiKeysApiKeyID)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.GET(options.BaseURL+"/nodes", wrapper.GetNodes)
	router.GET(options.BaseURL+"/nodes/:nodeID", wrapper.GetNodesNodeID)
	router.POST(options.BaseURL+"/nodes/:nodeID", wrapper.PostNodesNodeID)
	router.GET(options.BaseURL+"/sandboxes", wrapper.GetSandboxes)
	router.POST(options.BaseURL+"/sandboxes", wrapper.PostSandboxes)
	router.GET(options.BaseURL+"/sandboxes/metrics", wrapper.GetSandboxesMetrics)
	router.DELETE(options.BaseURL+"/sandboxes/:sandboxID", wrapper.DeleteSandboxesSandboxID)
	router.GET(options.BaseURL+"/sandboxes/:sandboxID", wrapper.GetSandboxesSandboxID)
	router.POST(options.BaseURL+"/sandboxes/:sandboxID/connect", wrapper.PostSandboxesSandboxIDConnect)
	router.GET(options.BaseURL+"/sandboxes/:sandboxID/logs", wrapper.GetSandboxesSandboxIDLogs)
	router.GET(options.BaseURL+"/sandboxes/:sandboxID/metrics", wrapper.GetSandboxesSandboxIDMetrics)
	router.POST(options.BaseURL+"/sandboxes/:sandboxID/pause", wrapper.PostSandboxesSandboxIDPause)
	router.POST(options.BaseURL+"/sandboxes/:sandboxID/refreshes", wrapper.PostSandboxesSandboxIDRefreshes)
	router.POST(options.BaseURL+"/sandboxes/:sandboxID/resume", wrapper.PostSandboxesSandboxIDResume)
	router.POST(options.BaseURL+"/sandboxes/:sandboxID/timeout", wrapper.PostSandboxesSandboxIDTimeout)
	router.GET(options.BaseURL+"/teams", wrapper.GetTeams)
	router.GET(options.BaseURL+"/teams/:teamID/metrics", wrapper.GetTeamsTeamIDMetrics)
	router.GET(options.BaseURL+"/teams/:teamID/metrics/max", wrapper.GetTeamsTeamIDMetricsMax)
	router.GET(options.BaseURL+"/templates", wrapper.GetTemplates)
	router.POST(options.BaseURL+"/templates", wrapper.PostTemplates)
	router.GET(options.BaseURL+"/templates/aliases/:alias", wrapper.GetTemplatesAliasesAlias)
	router.DELETE(options.BaseURL+"/templates/tags", wrapper.DeleteTemplatesTags)
	router.POST(options.BaseURL+"/templates/tags", wrapper.PostTemplatesTags)
	router.DELETE(options.BaseURL+"/templates/:templateID", wrapper.DeleteTemplatesTemplateID)
	router.GET(options.BaseURL+"/templates/:templateID", wrapper.GetTemplatesTemplateID)
	router.PATCH(options.BaseURL+"/templates/:templateID", wrapper.PatchTemplatesTemplateID)
	router.POST(options.BaseURL+"/templates/:templateID", wrapper.PostTemplatesTemplateID)
	router.POST(options.BaseURL+"/templates/:templateID/builds/:buildID", wrapper.PostTemplatesTemplateIDBuildsBuildID)
	router.GET(options.BaseURL+"/templates/:templateID/builds/:buildID/logs", wrapper.GetTemplatesTemplateIDBuildsBuildIDLogs)
	router.GET(options.BaseURL+"/templates/:templateID/builds/:buildID/status", wrapper.GetTemplatesTemplateIDBuildsBuildIDStatus)
	router.GET(options.BaseURL+"/templates/:templateID/files/:hash", wrapper.GetTemplatesTemplateIDFilesHash)
	router.GET(options.BaseURL+"/v2/sandboxes", wrapper.GetV2Sandboxes)
	router.GET(options.BaseURL+"/v2/sandboxes/:sandboxID/logs", wrapper.GetV2SandboxesSandboxIDLogs)
	router.POST(options.BaseURL+"/v2/templates", wrapper.PostV2Templates)
	router.PATCH(options.BaseURL+"/v2/templates/:templateID", wrapper.PatchV2TemplatesTemplateID)
	router.POST(options.BaseURL+"/v2/templates/:templateID/builds/:buildID", wrapper.PostV2TemplatesTemplateIDBuildsBuildID)
	router.POST(options.BaseURL+"/v3/templates", wrapper.PostV3Templates)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9a28cuY7oXxHq3g9ngI7tONmDewLsB8dJzvGOnTH8yFxgJhjIVexuret1JJXt3sD/",
	"fSFKqlJVqV7tdttJjPkwcZeeJEVSJEV+C8IsybMUUimCd9+CnHKagASOf9EwBCEusmtIjz6oH1gavAty",
	"KpfBLEhpAsG7RptZwOHfBeMQBe8kL2AWiHAJCVWd5SpXHYTkLF0E9/ezgObsV1h1D20/Txv1qmBx1Dmo",
	"/TptzDSLoHNI83HaiDldsJRKlqXHLGFSNYpAhJzl6rfgXXBC71hSJCQtkivgJJsTJiERRGaEgyx4SnLg",
	"JKcLCGZ6Vf8ugK+qZcU4rruKCOa0iGXw7vXe3iyYZzyhMngXsFS+2Q9mQaJnNJ8Tlpq/Znb5LJWwAN5Y",
	"/2e4k4j/9h4OCy4yrpYsJOWSyCWQmAlJ5jxLOpadlsP1A1DQNLrK7jqxUn2fhhgJNOkc1HycOmKSx1RC",
	"z6hlgykj36vGIs9SAXhc3+7tqf+FWSohRYqieR6zELG0+98iQwxV4/1fDvPgXfB/disesKu/it2PnGdc",
	"z1FH6XsaEbVEEDK4nwVv914//pwHhVxCKs2oBHQ7Nfmbx5/8U8avWBRBqmd8+/gzfs4kmWdFGukZ//H4",
	"Mx5m6TxmIWL0P7ZBRefAb4BbTN5bKkcyPvj9/AwWTEi+QpHEsxy4ZJrG6a04QImjJEPU5jgHv58T3YD8",
	"City9IHMM04+Hp4RWiOiYNY8TjM1tpo4S/3D6m/kdgkckJOpUblZKWGCxFlIJUQdQ59DyEGWi/fPoRu5",
	"Oxi/fP1Dc9SLVQ5KeJQLbQ0EqeLyf6g1Bl9nHv5VcaQ/9NdZEw3eDboArcbNrv4bNKEdRAlLzzWX/pXF",
	"8RkIFE5NlM8piyE6zIrUIyU/l9LR8HsQRC6pJLqXEj3XLI6DtgybBerDpIFFgZubF3G8Irp34BWOLsTc",
	"WWa1zXxVQBCCLdILIwAu6EKcGebagoOkC+HBL12gTkBxIPUvRZpWoigZq7QGj/goF045pyv8m/IFSN8U",
	"6vdyTMJS8ieKrneSLv4MiFEkBklHDz/TG6k2D5G7/fa+HX2uvq6jSNHxnGk0qW1jUwWKLGTqKJJbJpfq",
	"iwCCszpaT1Ew71H1g9kuFYex060B5RZMcFF2iwoo79W/j7PFx9TLAGO4gXiI7x5ni2Nsdz8LEhBCKYmt",
	"LR1nC2I+EsvtPfAQEvJ253MJuSKECuo5z5BpcYgR9IYS42xBALfigzVLQEiaeCa4sJ8ssN2BSiRGVMIr",
	"Ncow9ZVTVSCZGWiWYD+XVBbiDKiRcg3Qa6SYv0pl+o+vMw9kQbdsgkPgDITrKRy66UNnnSQ8J7cTxycG",
	"v/Yc1OefkbDgHFIZrwiHPOOSpQuSpbEWOyidTY+JlOGw4EHM2MUrLByeXnbw48PTSxJmHAQuDbei+XLg",
	"u8n03F1mSttJIZRG9HgYLUsgK6SfJrNCKroXEGZpJPAig6sxkCSqM6FzCZzcLlm4dJdKxDIr4ojAXc44",
	"9C58b1Cu2FX6ROshB0V0B9XdvL3L0LSRA2dPX/CJVKMQ7KTVhjFncBawaAzfducYw6MTKq6HDk01ywkV",
	"1yxdfABJWSxUf33vaol8mkDHitqcy3/hvVgC0eqBAe/AQA2c4m5xcXYGs9eZg66vFYIvgCYHp0dGnVwP",
	"vwenR+QaVtNRayZ4j3PTOP5tHrz7ox8nar2XQhHz11mQFnFMr2LQF93RtGLWO4ZMrn1q9hm9JTc0LqA9",
	"YGuAmAp5KcCzrmMqzFmXSyZKIN5SQQqBTM8LxPqen4SyO7fro0Xd0JCgIcw6JX6AGCSMUmCH1+YoVCP1",
	"Mqv+RriM9RUxe+isavqBiesTkJyFHo00ghsWerbyAX8ndqzmAuYsBrESEpIL71XtU/mdqL7kb7Cz2JkR",
	"uJNvZ+RuLn7xskIlLk8z5pOZJ+obydVHC+GIISo9/EzS+P1Kgg/G6hsROQ1R97/CVu7xY6n8+1vvFUud",
	"hY5R1blaZ9Cm9lDtf2YR0wK1u5DaXi2qz9n/wMl7D0aZuCaC/Q80tQ615hP2fqoMnwUf05sv1JjXo4ip",
	"eWh82iAvdwkf0xvGszRRysUN5UyxD58S1D7NH9Ob6Atw4bVomA+WLiC9iQgv0lRpgEav7xx7FmjDTlvm",
	"ZJGHrrExwW8ecLVB1KnN6lmHGJeZyFUrP/EsOUroAlzDUsTU2AlLqdR7SWieqwG1mamL+7rmqVmwCPOu",
	"hv88PHUa8nLmjtaQAqdx2eN+ZmG7+mysxGrX97MgS2GEqHWXeT/rb+uudLBtc50Kvu4ALaIQwNWpPAhD",
	"dVT/S/io8Vy3IaYR+a/z3z4jjf/z8HQLpi+FxbGmL892fCp4E04tsORUiNuMe3SLU/NFybVCVKyHV9S0",
	"cQiUY3/1DF4I4H7hfWm+jF+qH6jlDLMKLj6odqo+LfAqnQWiL0rRO+UwZ3ceOOPvqK8plqd7kJs6Y9T3",
	"nox3qYjOPOfF3DuP/v2B8+T9m8ALN7PQEa0hiQF0a1xUhY8hXcilR8vF3/uX2CWYzYLrM8w8ePHBUDGV",
	"YyYkRJ23dBoz6jPUqZ/H6JNhzCCV1q6Yc9DGe6OYD91CdG/vuHlRmjD6GGlp6rifKVHkqCB9vRxl5V6d",
	"3s77HbldQk2Mk1sWxx7TQ+8dD+oqRK+vx2mKQjzJ+Gp4Qye2HfaRNKJy0K1kaOLENm96g4eQ16PYoJ8a",
	"pkCVCmI6jYaqkIomx23yHNu2vMhDWyyN9Wig0pYoJmorN/e4YRbteqddr3p5glywOQfAIYIaiVu6tYCo",
	"kxkefWu/9lgX1aZaeLRiLIKrYoGBBfMsmAW3lKOQQ73RJ9mOs4X4wDiE0qskl58cI7TxLxlT3hWYaAwE",
	"pF3GPOO3lKtfrmh4jf9szT4L7l6p9q9uKIo+oTrW1vOpHKX28/tySLOB86zgvuuo/n3i0hW2M05RdOcK",
	"JQIdA+OXr2e9cIapfj11BryfBSc0XLIUjhSy2neJvDjg4ZJJCGXBwW8Rpk4Lu9FU6/8+xvyJJixe+Yea",
	"47cRg5xkkY8y1RiJ+jR2iM9ejaoaJnUMI/6xmhefcoPOOhvzzVpw1Yi4uwCaaIOHh/MBTUiCH40nwXGm",
	"tG3njkenX6y2fDxmjiluHseJdJn6FKTeSZQ+prppU97frFVfsDQEAnkWLn9p3Fk7DB2o5PjtwSasqm50",
	"NCE0ENnlmDv3gt1AStTA/IY6bmsdBdbr1arDwS4J0RvmPfaGVnDGyeEpCbN0zhYF1xE3bWtDhyGz0tRP",
	"HPnf9EmpL+sYVF7v/z8f7D/Dba+n46HWfp+p8Kuet0c7jbPbvxCPKci/9AQ+bTXObksQyKxcyRKI7bxD",
	"fldKhwCpGsxpLGBGmCRXsKQ3YGV6AkRpIjmEbL5i6YJEkK5+K7DP3g7+t7tnqSwFeZvxa4PlnWrLV1kW",
	"A0UFjhYyO6WFgJqzU0/fjs/KEqpulXG8IrnqVFc1tD8M9RLjteqa8QxEkYzVjQ7KDqdZzMKV0VitfW1A",
	"W8VmSuvUp6NXSQ3zB+qnBuIje37WrQ8RPagxQuiVgef4O6FxTIzlOMySpEhtqBxy65a668B8mlZpj0G/",
	"od51n9qA0//w8X5FmzG78RpXDSveeaiXtNqfObJ9PrPNeU8qJmFMog3lJi6EBD4O6qaxV5fIEm/w8CH+",
	"bgfIeLgEITkaOjs9eZ+sIWUgEMpcHNC9P9YPoLuc6/gpmDKLKPuMm2mcE7FLN0vqGmkvT3Caat5gnUV9",
	"vRQ5WL9SLa58ugkizRIade7EgHFCdJu1/mepC6IazDsM9qK8qmIEyfCcpiE5t5M3Trl/Fm14PUqFpGno",
	"5VjWjMxMm8oiNoh5E+YyAn06SAiVvpHOlf7z1+Qc9jUBOmDbm545zKNcdgPfFTm2j179uHcgr9pbyWPq",
	"h8OyNm1/9TA4Gi4hwsAlz2k/ZgKZk26lA8gEYVGD9saHLr7w0xd+uhV+Cj3UPMRKR8X61a3eHlJ/YYMj",
	"2KDmcy4PGmaEPo5XclEf73PiQ5oPOCJrZhAtC4m6GSJdHp5e9p3bsh0pQx9HiuOyp75pd8RfHGDkRH0m",
	"ba+dGuThejx8kSPVC7YqiHO6khHmxSnwELyqhQK4GrzAaNdct9MhvmPGjpi4Fr54HqlfERhc6qhYGi4x",
	"jGY3qcJrxp5uN6zIG8er4H8xGIuTagJbB1m612V3XM5nZ2zrslw7OqdG7B2UWUNte4Eeh4IDIIs7eybP",
	"S/7V9hsUosH9Kuc3jdSVLuKUpdq4HeoYYf1HkS6BxnK5GmkGrxZyZkaufvlQzVH9eOjOVv18Wc1b297h",
	"kqaLzd0qB+MopwuFBhmYAdQutL2mx61bNzv1C/ENGZ6e2GJxPwu+Oy93lCWUeUT+eyqA6I/OS7nSwMnp",
	"fM5CwoQxdLKreFRYLKQ3zWj2BkDcKHVkW8ir05uobhHbrJN7U17n7fl2Z4HBQS808efK2qdAafCVLso5",
	"bhglOc/uVjvDGFzDpdz0CXfZfN1DG2TzeeBjEq84diE59sENIbeIKqV9h3zQwyhYZvP5jvs0MlVMXA3u",
	"cyKblXVdhV8CVZ6AXWwhLuYZ8qOXoJuXoJu1g27M3o+zhf+tqHaY1/3/hKYRiVkKrWsu/ugdR33pe3D6",
	"RI9CccF1OHQ8wZ0zMFbNrgj+Lntl5R7f+jPep4Iqrt99cmugV4e0GH5tW7/N8QKjVyId1tRiMaMu401E",
	"ey7kceZ7dHS8iTkHnyTh3DMXDg2Yfdk/M+lfvNAbeqVsRtIQFCVENwY933acHZw4cmfcSxjbY1Ci1Cbx",
	"RjSduDFAY1lat53rc9vCNe6pS5gXlwKi07DjxXOfPWseZ27WBRshpLk+mki6zEcRvmrqfHrVbTxSHf3v",
	"IfGhVKe5qNcc1bvUHiNX76D+VZ4MmLW6h/w549omRJs5CohD1BUuHFQ7dOQSq8Mb6vEv/uCq33wv9K0r",
	"BltARA6PPpyRqzgLrwXJODk6JTSKONr/tUK+4Kim64vGDjkw/apWNL6lK0EkvQaisA4RKBhmN8D1wG7r",
	"nUlOS1zkaXEVs/BCL6DGsX2Uda7juwircUByeXYsnLDe6rKkkzkgg6s//fHHfJmYsW64RpCyyWCdBJSE",
	"imvzgvhfmfAsxYJgmQmJb2mMoo3XuCuoLlsYFGUAZMIthVdWtJSz2i1gagi68f3hSyZ8Ct5jMgDxO5PL",
	"znfGNZ9jl4wcd2dTUvC+ZZYtx1dn7wJo4jlrmITRc8E1L96tIVSq3r4EEOKDJejmEL8vQS6h6m7vSuYE",
	"NIZ0yHTMQ3L/aqrkfsN3Od8IrVuaSQdo3q4ZYLm7tpB9SdPQ6V746bMsGOrxZvrYUFx+mKUmQ815dyDD",
	"xRIcZ23VxYlsaBz3ESquG1905mWo3lRr2raBOU619jJK9X1R04bUNA8deHBkKQ+5QItnQWIM3Y3n+epn",
	"u81C+COsxnEP03uAdfjOkl6bXr+xqfst8vYADHgYddMHZHwz2d0Gb46IqboZUfE51VmOO2kTEuUpluuk",
	"MzQp3NTh1g9Q+vwRV1WmtCEealHgJFdb1/MwICcrG3ENepW59YmE5fove9f1ASjUnuf0Np0MLCSKh8nV",
	"NfwPJmrCJ0xbx478DVvnNIRdPMQm96TeUPkt+mXS+czxCjakn9rkl4Lo9urig7cr57Z1tfLojo7iKhRe",
	"1uUETcz0GCvW8lr4zkORR2ucOk1IuuuaJmTX/VGlbB/h5TDIdBmGuw33iDfPSg0/NbZdP4+zUoBY6q0z",
	"RVf4oPzoNtNuj/Q2RRN9iDK7cfePnP/hOV3HXCMeVapoAbmOSNm+BJizlInltF3ZPqO3tQ6rFw9RGkaz",
	"ompTD+dDFespI4w7+YqHN7VOwicWw2UeZ9RzJnIOwhvd6jKDOYuREdAYgxaJ6WQfdmLIs/f8F9yjsV/y",
	"2Am7wLErK2KB68TUtYNwsmtvbdj/tn+N49+2GozNxovrWNfLNZh6d4SjrVrAJLWEl2mIBxdYy1v80IO2",
	"DUnhOVd+d2dtjcfZQjzI5fmYpNDl7qztoDM35oODxNYJ5srCa+Dq1Hv8eeU3x+TTPf060gAZ2GHisQdg",
	"1DQJlxBeY7QUTTEXGtxBWOj88zW9qAry7WQWaE7yzoU2jw3NsmHrsoOfLkL6sv88SGkd/LvQmhrVOAp+",
	"GhCdoHvTC7oRZqEmMHfIh7LbDNPhYQoXlgoJNNp5SliPT727Qw5pSlgaxkUEhBJJF9q2HGZxlhIBOcUH",
	"XDo7LfkzSFavbN8/A3Uzqf307ub1n8EvO+RojiMxYYeOMIeFddpJmy1bWNcmzksFyXl2wyLtrze/C4Is",
	"d2d6lmB/kYzyQE8olbF52m2SKTIm3/meZ2W2p76kHK7WeLvMYqsYVwoeDoQ8jxcp4bCgPIpBlHTdrUzO",
	"bT5VD69TP9t0kFQQSq6oaAuRbiY69+Vq7aPzdnJXM4prAG46TswqHrDOH098CQn5YGkL+9ZVte2br3Wm",
	"xmii5xJyr2bVctH7dNeBR1+tpVmPPf6tXfa3lJlXWPZNWHfuOLuEY1jQcDXgZXjxKWxc53jxCPygHoEX",
	"e/yLPX49e7yr6xs139oLOtX9LfuBH5+XTnGoPVM/WY8WT8tCbBtQ4rdp6CoPQtt5VFYdqelBvTXX6tu2",
	"xdfaySb4oE3sgC+KRPHi6k2zmn0KILHaxr+o8GQQV79aCGKzMvjamal9B5h+xVFDbeRu059Jv3vVvsT2",
	"Lk4vked1GgC3dbjuPUvqsqg+tWvek1Ovfk5+Z3JZ5Zh6eubekxzI5LjyGFMn3ZC0P9WXAWsr2vBTqpIv",
	"gSIviumo+AOfiO3SPoc1Ts1xNKtcI3co3GorsD34ExOI2tyvTK7OFSvQczlPzw8KXbjjCigH/slCUNPa",
	"X9ItpI80hs2q2ZdS5mUx5tqAWKd+CTTC5qZS/f9/hQ1fXdQzJZu4dzUO/mtojNOjV7+6MKj6nxc5vaIC",
	"Xo9Zi23cvRzbYh8xN3a02qm0gylUMOPNlkwqRhV83H+vEOokD3sX7O283tnDOk05pDRnwbvgzc7ezh4+",
	"CJFLxN+uRs8rRI+WXd63LrrMI6EkhdtmkmpFe/gS4CgK3gWnmZAOVYhAUxMI+T6LVhsr6N5Itd14UWIs",
	"HNwoFLix/b3XG5vdU9bUU1v+oFWwFKJa6W5dVv9112zl8ndVo6oifn9b1cg9rWgl8lHzH1/vv9obzh9B",
	"nRDwvNeJY/cbrbZ79OFeEwkWO/TkK1O/E5r204pu5lLLgTsFEiqnCUjgotPYVTXZrS0QjV4NCng7kB9D",
	"7+dhSHqrZxlq+/ZJEKp45q4S9mL3m3Yd3e+Wbx12sUB9Jw/4lcWxcB+zudX/8C0cw4TcyLM8TAEZu5r6",
	"Aicuw/5/1WXxG6j2PDDRWRjVn4p/VRyzfPxUZwAz5zAPxe+3SWVvY8wCN252q/Z6BkLdJD0M47xd1r+C",
	"9fOkw6a41jQoiiShWGJQbdhDM7TUOC21qnEslebs1TWsEBEL6HoEqgbFx3pGkREtqvsnSK0FaCH0APSO",
	"vBmVOln7AtmPa1v+xrOpJxYRXs2lwWgsupR6OkJ9cPfn5xQO0h5Fc3Ax9SSKQ3MBHmZXe2b5zPSGaUTh",
	"Hundb1qLHak/9NOKUR80tRyYcacrDbbjOH2hhpzvXV+YfLqpDD22VX0nHULXqeq8YWxtnj207tejOMTe",
	"AKGYm/5PQijqxOuEsZ0i/F/4Wcem+AS3/h6MAbSxZOtcbCV8p0EXkbybZhGM0Dp0M8+iP5sPm9E1xvn4",
	"sawL1j5eX+PQG9qaUPHrjD5NEBe2+02nYL/vxMw/QepM1Kbaoh8xn20i92kcx+R/v59NyWSMt5R/F4DP",
	"t801pZYm/lncTJy6GaPppcxa/R1dR5qk1ammYjprIspoLWoTdLeV1E2Q1COJsFZ+7nsjwwZ1G4NbCwF0",
	"zOAQ34PkGs9Wauls+nm9LaDhlnNosRc3g0GvGaNMHIesQXugZUbmLLYxkdU12YY1FwL4f9Kr8M9ib2//",
	"7zTP/zPnWYSxzB9puET1gqaRruooSFIISa6AXJ4dE0jDLAIM+PYxpDLhqsuPNs1/JoqzRtWRh8m1NvKQ",
	"GPfGEOPeFuWh46r446sSNGsrYfVESgOXcZuTCpPENvxqbYbnEvkj3ctLtG/3Ul6bts0R3Vy/3bfxn4So",
	"auxz16mN1M1G3ZolOmhsHDM9qerW9PHUwyxJ6CvzHAQiEteLIJGjDxgevoDaSoJZAHd5jDURTUiPj0Wa",
	"Qf5ikei1L3e77hN6d6Q/vt7bazCzWVCk7N8FmAZI54+q8HmzvT2Mpeo3OUlVSuYnPQrfytzYvZYtbQ93",
	"svX5TFolms6dfNvTVMwqU/dIs1aD0Vnvw/PX+h5LeHbeNCvBebUieGfr5mGPhMCNc4R1boGiKg3305BF",
	"55nfNXWaut2nZwg7URJPpLP46ReJbgEfYSqC1N4l6rIh0Q65uDjGuiBpvCJwJyE1Cn6PwlYSoanu9GBa",
	"3LzyZ1Y2SQHcewoF0Ka7sMlV72dPpYoaitiaKvqDnlubrKFk9/0RukoACCdf/Q65FEB2b/Z7hncfXo8Q",
	"Fcc6/8TaR3TmfZqplDbpqa8giFxS6QSslzyepSRhccxMMsgOIwK+CPVbNG24Z3+V9JaNhN6p1k7+z75V",
	"dqwqZrpuZrWqqp7antLDpxVG24IERqyvI391PpeXw6xO29B91D29VVnUEWey8y76gGNZ5lvVR7J69EJ5",
	"WeBZkSC/ofHMqes3w6Y613iVx/URz6dvWMA8uO7xGrE1SKP1NjZtyV+3Ee3TyGi+rpnSPchbuET/oOc+",
	"t3U6/ao3lvFsZMkfoy/r8p/bvnrbeoAuvdA0IiFNnZvAY2L+7d4/xrT9x3dGJRzmHMQSRN8lDZvUjqW+",
	"ZSn9iUlhksDr4qsjyeisnPdpLl715yFRoRfsiboyXxps2MKhUr6uIZeEYvnZintj3vg7zZXf/F3pWP1y",
	"pZlKY6SPssFGNWS3ZJB4BhSszn6dfPvvK7pC6Rq8T3d8hqaCRt3m5+sr6r6gv3DtCTTv1MT28+xzkG5h",
	"7WZF7B1y4a+xSu4s63I8oKxKRGaId4cc0jjG6/OSCaWkLbOIJEUsWR6DefqY3QC/5UyaV5AXF8czXZ8f",
	"ByyE7g7E1rFwiryJSutXrbCKvxIwCVBRmISodmuWd481+F2UtcafXu7Uaps3n2WqzVWipMKHCy+TOapT",
	"MLUr546627dLVqhVft2IfBKGNMs6wmb0n01rxxdH455zeC/kF+bDNiNR8PHlAwNQ9Ia25+hsvsbtQ2Mt",
	"OEr95qCqehw2xqLiOvidx+R+LOrHX+vaU8xTrxdjyo9lTHFqSz3IkiKrOlSPbEZ5M6btm2fDkAcP+G5C",
	"73oPOdKQMc37DrzNpKMjfCxFjmMDJ/TuhRM8e04w66hdLDN1CDmDG6hRCQakmlirjvBTjkkyusOqbGLM",
	"qljYX6JdLewvRMZfHOuFbTeC/oTeubzrhVdtmlfpgNRRuqNt6mU51ccGm/FRZvmgvOsgjs6l/HXbOqsJ",
	"4H2w3mrh9YRBepO02RF0VW2qHhvdb0BrPF3uCZB2iewxDF/e+g2jzF/7G1+DSTXcYQWrCt/QMIRcWm/F",
	"swsMfUQKq7GvXZMHavcb/qP7Jdsh5upmcyc7FZNLo1Tp/GFwx3T96G4uZ9LI4f86OF49gwY1LbslcUfa",
	"cttxmzLXX9FsiL8pFq/zk9h8lSuz+smkOV6efneGm24KrjKh9j7Zr+yidGHteJ2SWfcpyfaCLh6Ld9Zn",
	"UhNNYqBvO3LAdr//f3Hfa3qyCWX9pvsDUwaDLv4mfsG6GO00uj2C9hEJRq9sbYJ5veGFQOQuxSt36aJK",
	"SfxCj/30WGdt36rcjWOzknSogU2GVssJOdG8UXYdH0VSS2m5idwk34863385dHLe9mDPVaE2hLrZYOuc",
	"LliKa/gMd9LkEpzS7RhDXbeicTlZjieaOlxllklhEPJdPgFrXCOrjDj990iTI6f7BqkGehTO8Xg30Xom",
	"8bUT5bTSBncmy3n+Lwufh9HiDPQVnKYjTRbfB719v5aPH8ua4SpMu5qV734zBSbup0Sn6aJhbi2wUTSq",
	"ZdD7qqLFI8pnWzfDI2D3/bxM08CSCu1z+glJoP2oquVNrFcNMSV3x6hjNdyv9VRqTfxv91lVWHCBnrPv",
	"6V2VL/TKhgS/Ho4I9jtjIsYhlLq80jhWrajiQ9mrc+AYbiCeMugxdvCA9jwreAijsD/nWdLlUsZRJu1S",
	"T7wle2u78vV6lwDnyD9Pc4OfiW7FytrPVqtq6mMZa1dCvCHGem6LoT8Naz1KI7irqhwZPlsSTufpwvtl",
	"s6qN7+hnC/HbfC6gg5dNfiD6w3DbtZni1jjQkSLptTjPC7vpZTdYFW3325KKZX+qTZqSIo8zGpGYpdfW",
	"qkY51lUjCuOUpc6BpSvQ38bqeJ/KMm4PZEAeV+dSDzvW09kqGzfK2fn6cUhfweUSId91/3TxcrsErgtL",
	"6x910XKNiR/AKbD1Y+PmeBiOR+rNcfZl/0dOGdkShp/0YquFXq1IlgLJOEkyrtONIiRGpWSTWq6v9177",
	"XBpB0CypJuQKKykpmfo92e1f8ms+5cOW3rwvo9JQdJk+HBbxnWaG+S5NGENa9d7UNZeGiDGQ7Vjyw00g",
	"W0pg82V/PdvAT53K5ma/Hue8+cjUL/tPEZv6Zf+5+2gMJH62fL4exbY7GKa/5Eu/O9uhux/bof0oi+hm",
	"pC8e801Q94Dncqqf0kvsT+epfGQejxCZxOGfl6P0Ebnpmy5xvqbwfvMkwvvNUwlvswDL/+xCXuR4P+Xh",
	"PPzGcpaCx6aotni3u0tztgP7Vzs0zwNnhG/Vg7fqvde3Ru77+o/4OM/9u1Zl1v1gy4E5v+G091/v/zcA",
	"AP//pbpNGu39AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
