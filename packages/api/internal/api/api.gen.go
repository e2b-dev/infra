// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AccessTokenAuthScopes    = "AccessTokenAuth.Scopes"
	AdminTokenAuthScopes     = "AdminTokenAuth.Scopes"
	ApiKeyAuthScopes         = "ApiKeyAuth.Scopes"
	Supabase1TokenAuthScopes = "Supabase1TokenAuth.Scopes"
	Supabase2TeamAuthScopes  = "Supabase2TeamAuth.Scopes"
)

// Defines values for AWSRegistryType.
const (
	Aws AWSRegistryType = "aws"
)

// Defines values for GCPRegistryType.
const (
	Gcp GCPRegistryType = "gcp"
)

// Defines values for GeneralRegistryType.
const (
	Registry GeneralRegistryType = "registry"
)

// Defines values for LogLevel.
const (
	LogLevelDebug LogLevel = "debug"
	LogLevelError LogLevel = "error"
	LogLevelInfo  LogLevel = "info"
	LogLevelWarn  LogLevel = "warn"
)

// Defines values for LogsDirection.
const (
	LogsDirectionBackward LogsDirection = "backward"
	LogsDirectionForward  LogsDirection = "forward"
)

// Defines values for LogsSource.
const (
	LogsSourcePersistent LogsSource = "persistent"
	LogsSourceTemporary  LogsSource = "temporary"
)

// Defines values for NewSandboxAutoResume.
const (
	Any NewSandboxAutoResume = "any"
)

// Defines values for NodeStatus.
const (
	NodeStatusConnecting NodeStatus = "connecting"
	NodeStatusDraining   NodeStatus = "draining"
	NodeStatusReady      NodeStatus = "ready"
	NodeStatusUnhealthy  NodeStatus = "unhealthy"
)

// Defines values for SandboxState.
const (
	Paused  SandboxState = "paused"
	Running SandboxState = "running"
)

// Defines values for TemplateBuildStatus.
const (
	TemplateBuildStatusBuilding TemplateBuildStatus = "building"
	TemplateBuildStatusError    TemplateBuildStatus = "error"
	TemplateBuildStatusReady    TemplateBuildStatus = "ready"
	TemplateBuildStatusWaiting  TemplateBuildStatus = "waiting"
)

// Defines values for GetTeamsTeamIDMetricsMaxParamsMetric.
const (
	ConcurrentSandboxes GetTeamsTeamIDMetricsMaxParamsMetric = "concurrent_sandboxes"
	SandboxStartRate    GetTeamsTeamIDMetricsMaxParamsMetric = "sandbox_start_rate"
)

// AWSRegistry defines model for AWSRegistry.
type AWSRegistry struct {
	// AwsAccessKeyId AWS Access Key ID for ECR authentication
	AwsAccessKeyId string `json:"awsAccessKeyId"`

	// AwsRegion AWS Region where the ECR registry is located
	AwsRegion string `json:"awsRegion"`

	// AwsSecretAccessKey AWS Secret Access Key for ECR authentication
	AwsSecretAccessKey string `json:"awsSecretAccessKey"`

	// Type Type of registry authentication
	Type AWSRegistryType `json:"type"`
}

// AWSRegistryType Type of registry authentication
type AWSRegistryType string

// AdminSandboxKillResult defines model for AdminSandboxKillResult.
type AdminSandboxKillResult struct {
	// FailedCount Number of sandboxes that failed to kill
	FailedCount int `json:"failedCount"`

	// KilledCount Number of sandboxes successfully killed
	KilledCount int `json:"killedCount"`
}

// AssignTemplateTagsRequest defines model for AssignTemplateTagsRequest.
type AssignTemplateTagsRequest struct {
	// Tags Tags to assign to the template
	Tags []string `json:"tags"`

	// Target Target template in "name:tag" format
	Target string `json:"target"`
}

// AssignedTemplateTags defines model for AssignedTemplateTags.
type AssignedTemplateTags struct {
	// BuildID Identifier of the build associated with these tags
	BuildID openapi_types.UUID `json:"buildID"`

	// Tags Assigned tags of the template
	Tags []string `json:"tags"`
}

// BuildLogEntry defines model for BuildLogEntry.
type BuildLogEntry struct {
	// Level State of the sandbox
	Level LogLevel `json:"level"`

	// Message Log message content
	Message string `json:"message"`

	// Step Step in the build process related to the log entry
	Step *string `json:"step,omitempty"`

	// Timestamp Timestamp of the log entry
	Timestamp time.Time `json:"timestamp"`
}

// BuildStatusReason defines model for BuildStatusReason.
type BuildStatusReason struct {
	// LogEntries Log entries related to the status reason
	LogEntries *[]BuildLogEntry `json:"logEntries,omitempty"`

	// Message Message with the status reason, currently reporting only for error status
	Message string `json:"message"`

	// Step Step that failed
	Step *string `json:"step,omitempty"`
}

// CPUCount CPU cores for the sandbox
type CPUCount = int32

// ConnectSandbox defines model for ConnectSandbox.
type ConnectSandbox struct {
	// Timeout Timeout in seconds from the current time after which the sandbox should expire
	Timeout int32 `json:"timeout"`
}

// CreatedAccessToken defines model for CreatedAccessToken.
type CreatedAccessToken struct {
	// CreatedAt Timestamp of access token creation
	CreatedAt time.Time `json:"createdAt"`

	// Id Identifier of the access token
	Id   openapi_types.UUID       `json:"id"`
	Mask IdentifierMaskingDetails `json:"mask"`

	// Name Name of the access token
	Name string `json:"name"`

	// Token The fully created access token
	Token string `json:"token"`
}

// CreatedTeamAPIKey defines model for CreatedTeamAPIKey.
type CreatedTeamAPIKey struct {
	// CreatedAt Timestamp of API key creation
	CreatedAt time.Time `json:"createdAt"`
	CreatedBy *TeamUser `json:"createdBy"`

	// Id Identifier of the API key
	Id openapi_types.UUID `json:"id"`

	// Key Raw value of the API key
	Key string `json:"key"`

	// LastUsed Last time this API key was used
	LastUsed *time.Time               `json:"lastUsed"`
	Mask     IdentifierMaskingDetails `json:"mask"`

	// Name Name of the API key
	Name string `json:"name"`
}

// DeleteTemplateTagsRequest defines model for DeleteTemplateTagsRequest.
type DeleteTemplateTagsRequest struct {
	// Name Name of the template
	Name string `json:"name"`

	// Tags Tags to delete
	Tags []string `json:"tags"`
}

// DiskMetrics defines model for DiskMetrics.
type DiskMetrics struct {
	// Device Device name
	Device string `json:"device"`

	// FilesystemType Filesystem type (e.g., ext4, xfs)
	FilesystemType string `json:"filesystemType"`

	// MountPoint Mount point of the disk
	MountPoint string `json:"mountPoint"`

	// TotalBytes Total space in bytes
	TotalBytes uint64 `json:"totalBytes"`

	// UsedBytes Used space in bytes
	UsedBytes uint64 `json:"usedBytes"`
}

// DiskSizeMB Disk size for the sandbox in MiB
type DiskSizeMB = int32

// EnvVars defines model for EnvVars.
type EnvVars map[string]string

// EnvdVersion Version of the envd running in the sandbox
type EnvdVersion = string

// Error defines model for Error.
type Error struct {
	// Code Error code
	Code int32 `json:"code"`

	// Message Error
	Message string `json:"message"`
}

// FromImageRegistry defines model for FromImageRegistry.
type FromImageRegistry struct {
	union json.RawMessage
}

// GCPRegistry defines model for GCPRegistry.
type GCPRegistry struct {
	// ServiceAccountJson Service Account JSON for GCP authentication
	ServiceAccountJson string `json:"serviceAccountJson"`

	// Type Type of registry authentication
	Type GCPRegistryType `json:"type"`
}

// GCPRegistryType Type of registry authentication
type GCPRegistryType string

// GeneralRegistry defines model for GeneralRegistry.
type GeneralRegistry struct {
	// Password Password to use for the registry
	Password string `json:"password"`

	// Type Type of registry authentication
	Type GeneralRegistryType `json:"type"`

	// Username Username to use for the registry
	Username string `json:"username"`
}

// GeneralRegistryType Type of registry authentication
type GeneralRegistryType string

// IdentifierMaskingDetails defines model for IdentifierMaskingDetails.
type IdentifierMaskingDetails struct {
	// MaskedValuePrefix Prefix used in masked version of the token or key
	MaskedValuePrefix string `json:"maskedValuePrefix"`

	// MaskedValueSuffix Suffix used in masked version of the token or key
	MaskedValueSuffix string `json:"maskedValueSuffix"`

	// Prefix Prefix that identifies the token or key type
	Prefix string `json:"prefix"`

	// ValueLength Length of the token or key
	ValueLength int `json:"valueLength"`
}

// ListedSandbox defines model for ListedSandbox.
type ListedSandbox struct {
	// Alias Alias of the template
	Alias *string `json:"alias,omitempty"`

	// ClientID Identifier of the client
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	ClientID string `json:"clientID"`

	// CpuCount CPU cores for the sandbox
	CpuCount CPUCount `json:"cpuCount"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB DiskSizeMB `json:"diskSizeMB"`

	// EndAt Time when the sandbox will expire
	EndAt time.Time `json:"endAt"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB         `json:"memoryMB"`
	Metadata *SandboxMetadata `json:"metadata,omitempty"`

	// SandboxID Identifier of the sandbox
	SandboxID string `json:"sandboxID"`

	// StartedAt Time when the sandbox was started
	StartedAt time.Time `json:"startedAt"`

	// State State of the sandbox
	State SandboxState `json:"state"`

	// TemplateID Identifier of the template from which is the sandbox created
	TemplateID string `json:"templateID"`
}

// LogLevel State of the sandbox
type LogLevel string

// LogsDirection Direction of the logs that should be returned
type LogsDirection string

// LogsSource Source of the logs that should be returned
type LogsSource string

// MachineInfo defines model for MachineInfo.
type MachineInfo struct {
	// CpuArchitecture CPU architecture of the node
	CpuArchitecture string `json:"cpuArchitecture"`

	// CpuFamily CPU family of the node
	CpuFamily string `json:"cpuFamily"`

	// CpuModel CPU model of the node
	CpuModel string `json:"cpuModel"`

	// CpuModelName CPU model name of the node
	CpuModelName string `json:"cpuModelName"`
}

// MaxTeamMetric Team metric with timestamp
type MaxTeamMetric struct {
	// Timestamp Timestamp of the metric entry
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Timestamp time.Time `json:"timestamp"`

	// TimestampUnix Timestamp of the metric entry in Unix time (seconds since epoch)
	TimestampUnix int64 `json:"timestampUnix"`

	// Value The maximum value of the requested metric in the given interval
	Value float32 `json:"value"`
}

// Mcp MCP configuration for the sandbox
type Mcp map[string]interface{}

// MemoryMB Memory for the sandbox in MiB
type MemoryMB = int32

// NewAccessToken defines model for NewAccessToken.
type NewAccessToken struct {
	// Name Name of the access token
	Name string `json:"name"`
}

// NewSandbox defines model for NewSandbox.
type NewSandbox struct {
	// AllowInternetAccess Allow sandbox to access the internet. When set to false, it behaves the same as specifying denyOut to 0.0.0.0/0 in the network config.
	AllowInternetAccess *bool `json:"allow_internet_access,omitempty"`

	// AutoPause Automatically pauses the sandbox after the timeout
	AutoPause *bool `json:"autoPause,omitempty"`

	// AutoResume Auto-resume policy for paused sandboxes. Omit to disable auto-resume.
	AutoResume *NewSandboxAutoResume `json:"autoResume,omitempty"`
	EnvVars    *EnvVars              `json:"envVars,omitempty"`

	// Mcp MCP configuration for the sandbox
	Mcp      *Mcp                  `json:"mcp"`
	Metadata *SandboxMetadata      `json:"metadata,omitempty"`
	Network  *SandboxNetworkConfig `json:"network,omitempty"`

	// Secure Secure all system communication with sandbox
	Secure *bool `json:"secure,omitempty"`

	// TemplateID Identifier of the required template
	TemplateID string `json:"templateID"`

	// Timeout Time to live for the sandbox in seconds.
	Timeout *int32 `json:"timeout,omitempty"`
}

// NewSandboxAutoResume Auto-resume policy for paused sandboxes. Omit to disable auto-resume.
type NewSandboxAutoResume string

// NewTeamAPIKey defines model for NewTeamAPIKey.
type NewTeamAPIKey struct {
	// Name Name of the API key
	Name string `json:"name"`
}

// Node defines model for Node.
type Node struct {
	// ClusterID Identifier of the cluster
	ClusterID string `json:"clusterID"`

	// Commit Commit of the orchestrator
	Commit string `json:"commit"`

	// CreateFails Number of sandbox create fails
	CreateFails uint64 `json:"createFails"`

	// CreateSuccesses Number of sandbox create successes
	CreateSuccesses uint64 `json:"createSuccesses"`

	// Id Identifier of the node
	Id          string      `json:"id"`
	MachineInfo MachineInfo `json:"machineInfo"`

	// Metrics Node metrics
	Metrics NodeMetrics `json:"metrics"`

	// NodeID Identifier of the nomad node
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	NodeID string `json:"nodeID"`

	// SandboxCount Number of sandboxes running on the node
	SandboxCount uint32 `json:"sandboxCount"`

	// SandboxStartingCount Number of starting Sandboxes
	SandboxStartingCount int `json:"sandboxStartingCount"`

	// ServiceInstanceID Service instance identifier of the node
	ServiceInstanceID string `json:"serviceInstanceID"`

	// Status Status of the node
	Status NodeStatus `json:"status"`

	// Version Version of the orchestrator
	Version string `json:"version"`
}

// NodeDetail defines model for NodeDetail.
type NodeDetail struct {
	// CachedBuilds List of cached builds id on the node
	CachedBuilds []string `json:"cachedBuilds"`

	// ClusterID Identifier of the cluster
	ClusterID string `json:"clusterID"`

	// Commit Commit of the orchestrator
	Commit string `json:"commit"`

	// CreateFails Number of sandbox create fails
	CreateFails uint64 `json:"createFails"`

	// CreateSuccesses Number of sandbox create successes
	CreateSuccesses uint64 `json:"createSuccesses"`

	// Id Identifier of the node
	Id          string      `json:"id"`
	MachineInfo MachineInfo `json:"machineInfo"`

	// Metrics Node metrics
	Metrics NodeMetrics `json:"metrics"`

	// NodeID Identifier of the nomad node
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	NodeID string `json:"nodeID"`

	// Sandboxes List of sandboxes running on the node
	Sandboxes []ListedSandbox `json:"sandboxes"`

	// ServiceInstanceID Service instance identifier of the node
	ServiceInstanceID string `json:"serviceInstanceID"`

	// Status Status of the node
	Status NodeStatus `json:"status"`

	// Version Version of the orchestrator
	Version string `json:"version"`
}

// NodeMetrics Node metrics
type NodeMetrics struct {
	// AllocatedCPU Number of allocated CPU cores
	AllocatedCPU uint32 `json:"allocatedCPU"`

	// AllocatedMemoryBytes Amount of allocated memory in bytes
	AllocatedMemoryBytes uint64 `json:"allocatedMemoryBytes"`

	// CpuCount Total number of CPU cores on the node
	CpuCount uint32 `json:"cpuCount"`

	// CpuPercent Node CPU usage percentage
	CpuPercent uint32 `json:"cpuPercent"`

	// Disks Detailed metrics for each disk/mount point
	Disks []DiskMetrics `json:"disks"`

	// MemoryTotalBytes Total node memory in bytes
	MemoryTotalBytes uint64 `json:"memoryTotalBytes"`

	// MemoryUsedBytes Node memory used in bytes
	MemoryUsedBytes uint64 `json:"memoryUsedBytes"`
}

// NodeStatus Status of the node
type NodeStatus string

// NodeStatusChange defines model for NodeStatusChange.
type NodeStatusChange struct {
	// ClusterID Identifier of the cluster
	ClusterID *openapi_types.UUID `json:"clusterID,omitempty"`

	// Status Status of the node
	Status NodeStatus `json:"status"`
}

// ResumedSandbox defines model for ResumedSandbox.
type ResumedSandbox struct {
	// AutoPause Automatically pauses the sandbox after the timeout
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	AutoPause *bool `json:"autoPause,omitempty"`

	// Timeout Time to live for the sandbox in seconds.
	Timeout *int32 `json:"timeout,omitempty"`
}

// Sandbox defines model for Sandbox.
type Sandbox struct {
	// Alias Alias of the template
	Alias *string `json:"alias,omitempty"`

	// ClientID Identifier of the client
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	ClientID string `json:"clientID"`

	// Domain Base domain where the sandbox traffic is accessible
	Domain *string `json:"domain"`

	// EnvdAccessToken Access token used for envd communication
	EnvdAccessToken *string `json:"envdAccessToken,omitempty"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// SandboxID Identifier of the sandbox
	SandboxID string `json:"sandboxID"`

	// TemplateID Identifier of the template from which is the sandbox created
	TemplateID string `json:"templateID"`

	// TrafficAccessToken Token required for accessing sandbox via proxy.
	TrafficAccessToken *string `json:"trafficAccessToken"`
}

// SandboxDetail defines model for SandboxDetail.
type SandboxDetail struct {
	// Alias Alias of the template
	Alias *string `json:"alias,omitempty"`

	// AutoPause Automatically pauses the sandbox after the timeout
	AutoPause *bool `json:"autoPause,omitempty"`

	// ClientID Identifier of the client
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	ClientID string `json:"clientID"`

	// CpuCount CPU cores for the sandbox
	CpuCount CPUCount `json:"cpuCount"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB DiskSizeMB `json:"diskSizeMB"`

	// Domain Base domain where the sandbox traffic is accessible
	Domain *string `json:"domain"`

	// EndAt Time when the sandbox will expire
	EndAt time.Time `json:"endAt"`

	// EnvdAccessToken Access token used for envd communication
	EnvdAccessToken *string `json:"envdAccessToken,omitempty"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB         `json:"memoryMB"`
	Metadata *SandboxMetadata `json:"metadata,omitempty"`

	// SandboxID Identifier of the sandbox
	SandboxID string `json:"sandboxID"`

	// StartedAt Time when the sandbox was started
	StartedAt time.Time `json:"startedAt"`

	// State State of the sandbox
	State SandboxState `json:"state"`

	// TemplateID Identifier of the template from which is the sandbox created
	TemplateID string `json:"templateID"`
}

// SandboxLog Log entry with timestamp and line
type SandboxLog struct {
	// Line Log line content
	Line string `json:"line"`

	// Timestamp Timestamp of the log entry
	Timestamp time.Time `json:"timestamp"`
}

// SandboxLogEntry defines model for SandboxLogEntry.
type SandboxLogEntry struct {
	Fields map[string]string `json:"fields"`

	// Level State of the sandbox
	Level LogLevel `json:"level"`

	// Message Log message content
	Message string `json:"message"`

	// Timestamp Timestamp of the log entry
	Timestamp time.Time `json:"timestamp"`
}

// SandboxLogs defines model for SandboxLogs.
type SandboxLogs struct {
	// LogEntries Structured logs of the sandbox
	LogEntries []SandboxLogEntry `json:"logEntries"`

	// Logs Logs of the sandbox
	Logs []SandboxLog `json:"logs"`
}

// SandboxMetadata defines model for SandboxMetadata.
type SandboxMetadata map[string]string

// SandboxMetric Metric entry with timestamp and line
type SandboxMetric struct {
	// CpuCount Number of CPU cores
	CpuCount int32 `json:"cpuCount"`

	// CpuUsedPct CPU usage percentage
	CpuUsedPct float32 `json:"cpuUsedPct"`

	// DiskTotal Total disk space in bytes
	DiskTotal int64 `json:"diskTotal"`

	// DiskUsed Disk used in bytes
	DiskUsed int64 `json:"diskUsed"`

	// MemTotal Total memory in bytes
	MemTotal int64 `json:"memTotal"`

	// MemUsed Memory used in bytes
	MemUsed int64 `json:"memUsed"`

	// Timestamp Timestamp of the metric entry
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Timestamp time.Time `json:"timestamp"`

	// TimestampUnix Timestamp of the metric entry in Unix time (seconds since epoch)
	TimestampUnix int64 `json:"timestampUnix"`
}

// SandboxNetworkConfig defines model for SandboxNetworkConfig.
type SandboxNetworkConfig struct {
	// AllowOut List of allowed CIDR blocks or IP addresses for egress traffic. Allowed addresses always take precedence over blocked addresses.
	AllowOut *[]string `json:"allowOut,omitempty"`

	// AllowPublicTraffic Specify if the sandbox URLs should be accessible only with authentication.
	AllowPublicTraffic *bool `json:"allowPublicTraffic,omitempty"`

	// DenyOut List of denied CIDR blocks or IP addresses for egress traffic
	DenyOut *[]string `json:"denyOut,omitempty"`

	// MaskRequestHost Specify host mask which will be used for all sandbox requests
	MaskRequestHost *string `json:"maskRequestHost,omitempty"`
}

// SandboxState State of the sandbox
type SandboxState string

// SandboxesWithMetrics defines model for SandboxesWithMetrics.
type SandboxesWithMetrics struct {
	Sandboxes map[string]SandboxMetric `json:"sandboxes"`
}

// Team defines model for Team.
type Team struct {
	// ApiKey API key for the team
	ApiKey string `json:"apiKey"`

	// IsDefault Whether the team is the default team
	IsDefault bool `json:"isDefault"`

	// Name Name of the team
	Name string `json:"name"`

	// TeamID Identifier of the team
	TeamID string `json:"teamID"`
}

// TeamAPIKey defines model for TeamAPIKey.
type TeamAPIKey struct {
	// CreatedAt Timestamp of API key creation
	CreatedAt time.Time `json:"createdAt"`
	CreatedBy *TeamUser `json:"createdBy"`

	// Id Identifier of the API key
	Id openapi_types.UUID `json:"id"`

	// LastUsed Last time this API key was used
	LastUsed *time.Time               `json:"lastUsed"`
	Mask     IdentifierMaskingDetails `json:"mask"`

	// Name Name of the API key
	Name string `json:"name"`
}

// TeamMetric Team metric with timestamp
type TeamMetric struct {
	// ConcurrentSandboxes The number of concurrent sandboxes for the team
	ConcurrentSandboxes int32 `json:"concurrentSandboxes"`

	// SandboxStartRate Number of sandboxes started per second
	SandboxStartRate float32 `json:"sandboxStartRate"`

	// Timestamp Timestamp of the metric entry
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Timestamp time.Time `json:"timestamp"`

	// TimestampUnix Timestamp of the metric entry in Unix time (seconds since epoch)
	TimestampUnix int64 `json:"timestampUnix"`
}

// TeamUser defines model for TeamUser.
type TeamUser struct {
	// Email Email of the user
	Email string `json:"email"`

	// Id Identifier of the user
	Id openapi_types.UUID `json:"id"`
}

// Template defines model for Template.
type Template struct {
	// Aliases Aliases of the template
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Aliases []string `json:"aliases"`

	// BuildCount Number of times the template was built
	BuildCount int32 `json:"buildCount"`

	// BuildID Identifier of the last successful build for given template
	BuildID string `json:"buildID"`

	// BuildStatus Status of the template build
	BuildStatus TemplateBuildStatus `json:"buildStatus"`

	// CpuCount CPU cores for the sandbox
	CpuCount CPUCount `json:"cpuCount"`

	// CreatedAt Time when the template was created
	CreatedAt time.Time `json:"createdAt"`
	CreatedBy *TeamUser `json:"createdBy"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB DiskSizeMB `json:"diskSizeMB"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// LastSpawnedAt Time when the template was last used
	LastSpawnedAt *time.Time `json:"lastSpawnedAt"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB `json:"memoryMB"`

	// Names Names of the template (namespace/alias format when namespaced)
	Names []string `json:"names"`

	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// SpawnCount Number of times the template was used
	SpawnCount int64 `json:"spawnCount"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`

	// UpdatedAt Time when the template was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// TemplateAliasResponse defines model for TemplateAliasResponse.
type TemplateAliasResponse struct {
	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`
}

// TemplateBuild defines model for TemplateBuild.
type TemplateBuild struct {
	// BuildID Identifier of the build
	BuildID openapi_types.UUID `json:"buildID"`

	// CpuCount CPU cores for the sandbox
	CpuCount CPUCount `json:"cpuCount"`

	// CreatedAt Time when the build was created
	CreatedAt time.Time `json:"createdAt"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB *DiskSizeMB `json:"diskSizeMB,omitempty"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion *EnvdVersion `json:"envdVersion,omitempty"`

	// FinishedAt Time when the build was finished
	FinishedAt *time.Time `json:"finishedAt,omitempty"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB `json:"memoryMB"`

	// Status Status of the template build
	Status TemplateBuildStatus `json:"status"`

	// UpdatedAt Time when the build was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// TemplateBuildFileUpload defines model for TemplateBuildFileUpload.
type TemplateBuildFileUpload struct {
	// Present Whether the file is already present in the cache
	Present bool `json:"present"`

	// Url Url where the file should be uploaded to
	Url *string `json:"url,omitempty"`
}

// TemplateBuildInfo defines model for TemplateBuildInfo.
type TemplateBuildInfo struct {
	// BuildID Identifier of the build
	BuildID string `json:"buildID"`

	// LogEntries Build logs structured
	LogEntries []BuildLogEntry `json:"logEntries"`

	// Logs Build logs
	Logs   []string           `json:"logs"`
	Reason *BuildStatusReason `json:"reason,omitempty"`

	// Status Status of the template build
	Status TemplateBuildStatus `json:"status"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`
}

// TemplateBuildLogsResponse defines model for TemplateBuildLogsResponse.
type TemplateBuildLogsResponse struct {
	// Logs Build logs structured
	Logs []BuildLogEntry `json:"logs"`
}

// TemplateBuildRequest defines model for TemplateBuildRequest.
type TemplateBuildRequest struct {
	// Alias Alias of the template
	Alias *string `json:"alias,omitempty"`

	// CpuCount CPU cores for the sandbox
	CpuCount *CPUCount `json:"cpuCount,omitempty"`

	// Dockerfile Dockerfile for the template
	Dockerfile string `json:"dockerfile"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB *MemoryMB `json:"memoryMB,omitempty"`

	// ReadyCmd Ready check command to execute in the template after the build
	ReadyCmd *string `json:"readyCmd,omitempty"`

	// StartCmd Start command to execute in the template after the build
	StartCmd *string `json:"startCmd,omitempty"`

	// TeamID Identifier of the team
	TeamID *string `json:"teamID,omitempty"`
}

// TemplateBuildRequestV2 defines model for TemplateBuildRequestV2.
type TemplateBuildRequestV2 struct {
	// Alias Alias of the template
	Alias string `json:"alias"`

	// CpuCount CPU cores for the sandbox
	CpuCount *CPUCount `json:"cpuCount,omitempty"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB *MemoryMB `json:"memoryMB,omitempty"`

	// TeamID Identifier of the team
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	TeamID *string `json:"teamID,omitempty"`
}

// TemplateBuildRequestV3 defines model for TemplateBuildRequestV3.
type TemplateBuildRequestV3 struct {
	// Alias Alias of the template. Deprecated, use name instead.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Alias *string `json:"alias,omitempty"`

	// CpuCount CPU cores for the sandbox
	CpuCount *CPUCount `json:"cpuCount,omitempty"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB *MemoryMB `json:"memoryMB,omitempty"`

	// Name Name of the template. Can include a tag with colon separator (e.g. "my-template" or "my-template:v1"). If tag is included, it will be treated as if the tag was provided in the tags array.
	Name *string `json:"name,omitempty"`

	// Tags Tags to assign to the template build
	Tags *[]string `json:"tags,omitempty"`

	// TeamID Identifier of the team
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	TeamID *string `json:"teamID,omitempty"`
}

// TemplateBuildStartV2 defines model for TemplateBuildStartV2.
type TemplateBuildStartV2 struct {
	// Force Whether the whole build should be forced to run regardless of the cache
	Force *bool `json:"force,omitempty"`

	// FromImage Image to use as a base for the template build
	FromImage         *string            `json:"fromImage,omitempty"`
	FromImageRegistry *FromImageRegistry `json:"fromImageRegistry,omitempty"`

	// FromTemplate Template to use as a base for the template build
	FromTemplate *string `json:"fromTemplate,omitempty"`

	// ReadyCmd Ready check command to execute in the template after the build
	ReadyCmd *string `json:"readyCmd,omitempty"`

	// StartCmd Start command to execute in the template after the build
	StartCmd *string `json:"startCmd,omitempty"`

	// Steps List of steps to execute in the template build
	Steps *[]TemplateStep `json:"steps,omitempty"`
}

// TemplateBuildStatus Status of the template build
type TemplateBuildStatus string

// TemplateLegacy defines model for TemplateLegacy.
type TemplateLegacy struct {
	// Aliases Aliases of the template
	Aliases []string `json:"aliases"`

	// BuildCount Number of times the template was built
	BuildCount int32 `json:"buildCount"`

	// BuildID Identifier of the last successful build for given template
	BuildID string `json:"buildID"`

	// CpuCount CPU cores for the sandbox
	CpuCount CPUCount `json:"cpuCount"`

	// CreatedAt Time when the template was created
	CreatedAt time.Time `json:"createdAt"`
	CreatedBy *TeamUser `json:"createdBy"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB DiskSizeMB `json:"diskSizeMB"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// LastSpawnedAt Time when the template was last used
	LastSpawnedAt *time.Time `json:"lastSpawnedAt"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB `json:"memoryMB"`

	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// SpawnCount Number of times the template was used
	SpawnCount int64 `json:"spawnCount"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`

	// UpdatedAt Time when the template was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// TemplateRequestResponseV3 defines model for TemplateRequestResponseV3.
type TemplateRequestResponseV3 struct {
	// Aliases Aliases of the template
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Aliases []string `json:"aliases"`

	// BuildID Identifier of the last successful build for given template
	BuildID string `json:"buildID"`

	// Names Names of the template
	Names []string `json:"names"`

	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// Tags Tags assigned to the template build
	Tags []string `json:"tags"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`
}

// TemplateStep Step in the template build process
type TemplateStep struct {
	// Args Arguments for the step
	Args *[]string `json:"args,omitempty"`

	// FilesHash Hash of the files used in the step
	FilesHash *string `json:"filesHash,omitempty"`

	// Force Whether the step should be forced to run regardless of the cache
	Force *bool `json:"force,omitempty"`

	// Type Type of the step
	Type string `json:"type"`
}

// TemplateUpdateRequest defines model for TemplateUpdateRequest.
type TemplateUpdateRequest struct {
	// Public Whether the template is public or only accessible by the team
	Public *bool `json:"public,omitempty"`
}

// TemplateUpdateResponse defines model for TemplateUpdateResponse.
type TemplateUpdateResponse struct {
	// Names Names of the template (namespace/alias format when namespaced)
	Names []string `json:"names"`
}

// TemplateWithBuilds defines model for TemplateWithBuilds.
type TemplateWithBuilds struct {
	// Aliases Aliases of the template
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Aliases []string `json:"aliases"`

	// Builds List of builds for the template
	Builds []TemplateBuild `json:"builds"`

	// CreatedAt Time when the template was created
	CreatedAt time.Time `json:"createdAt"`

	// LastSpawnedAt Time when the template was last used
	LastSpawnedAt *time.Time `json:"lastSpawnedAt"`

	// Names Names of the template (namespace/alias format when namespaced)
	Names []string `json:"names"`

	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// SpawnCount Number of times the template was used
	SpawnCount int64 `json:"spawnCount"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`

	// UpdatedAt Time when the template was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// UpdateTeamAPIKey defines model for UpdateTeamAPIKey.
type UpdateTeamAPIKey struct {
	// Name New name for the API key
	Name string `json:"name"`
}

// AccessTokenID defines model for accessTokenID.
type AccessTokenID = string

// ApiKeyID defines model for apiKeyID.
type ApiKeyID = string

// BuildID defines model for buildID.
type BuildID = string

// NodeID defines model for nodeID.
type NodeID = string

// PaginationLimit defines model for paginationLimit.
type PaginationLimit = int32

// PaginationNextToken defines model for paginationNextToken.
type PaginationNextToken = string

// SandboxID defines model for sandboxID.
type SandboxID = string

// TeamID defines model for teamID.
type TeamID = string

// TemplateID defines model for templateID.
type TemplateID = string

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N409 defines model for 409.
type N409 = Error

// N500 defines model for 500.
type N500 = Error

// GetNodesNodeIDParams defines parameters for GetNodesNodeID.
type GetNodesNodeIDParams struct {
	// ClusterID Identifier of the cluster
	ClusterID *openapi_types.UUID `form:"clusterID,omitempty" json:"clusterID,omitempty"`
}

// GetSandboxesParams defines parameters for GetSandboxes.
type GetSandboxesParams struct {
	// Metadata Metadata query used to filter the sandboxes (e.g. "user=abc&app=prod"). Each key and values must be URL encoded.
	Metadata *string `form:"metadata,omitempty" json:"metadata,omitempty"`
}

// GetSandboxesMetricsParams defines parameters for GetSandboxesMetrics.
type GetSandboxesMetricsParams struct {
	// SandboxIds Comma-separated list of sandbox IDs to get metrics for
	SandboxIds []string `form:"sandbox_ids" json:"sandbox_ids"`
}

// GetSandboxesSandboxIDLogsParams defines parameters for GetSandboxesSandboxIDLogs.
type GetSandboxesSandboxIDLogsParams struct {
	// Start Starting timestamp of the logs that should be returned in milliseconds
	Start *int64 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Maximum number of logs that should be returned
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSandboxesSandboxIDMetricsParams defines parameters for GetSandboxesSandboxIDMetrics.
type GetSandboxesSandboxIDMetricsParams struct {
	// Start Unix timestamp for the start of the interval, in seconds, for which the metrics
	Start *int64 `form:"start,omitempty" json:"start,omitempty"`
	End   *int64 `form:"end,omitempty" json:"end,omitempty"`
}

// PostSandboxesSandboxIDRefreshesJSONBody defines parameters for PostSandboxesSandboxIDRefreshes.
type PostSandboxesSandboxIDRefreshesJSONBody struct {
	// Duration Duration for which the sandbox should be kept alive in seconds
	Duration *int `json:"duration,omitempty"`
}

// PostSandboxesSandboxIDTimeoutJSONBody defines parameters for PostSandboxesSandboxIDTimeout.
type PostSandboxesSandboxIDTimeoutJSONBody struct {
	// Timeout Timeout in seconds from the current time after which the sandbox should expire
	Timeout int32 `json:"timeout"`
}

// GetTeamsTeamIDMetricsParams defines parameters for GetTeamsTeamIDMetrics.
type GetTeamsTeamIDMetricsParams struct {
	// Start Unix timestamp for the start of the interval, in seconds, for which the metrics
	Start *int64 `form:"start,omitempty" json:"start,omitempty"`
	End   *int64 `form:"end,omitempty" json:"end,omitempty"`
}

// GetTeamsTeamIDMetricsMaxParams defines parameters for GetTeamsTeamIDMetricsMax.
type GetTeamsTeamIDMetricsMaxParams struct {
	// Start Unix timestamp for the start of the interval, in seconds, for which the metrics
	Start *int64 `form:"start,omitempty" json:"start,omitempty"`
	End   *int64 `form:"end,omitempty" json:"end,omitempty"`

	// Metric Metric to retrieve the maximum value for
	Metric GetTeamsTeamIDMetricsMaxParamsMetric `form:"metric" json:"metric"`
}

// GetTeamsTeamIDMetricsMaxParamsMetric defines parameters for GetTeamsTeamIDMetricsMax.
type GetTeamsTeamIDMetricsMaxParamsMetric string

// GetTemplatesParams defines parameters for GetTemplates.
type GetTemplatesParams struct {
	TeamID *string `form:"teamID,omitempty" json:"teamID,omitempty"`
}

// GetTemplatesTemplateIDParams defines parameters for GetTemplatesTemplateID.
type GetTemplatesTemplateIDParams struct {
	// NextToken Cursor to start the list from
	NextToken *PaginationNextToken `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// Limit Maximum number of items to return per page
	Limit *PaginationLimit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTemplatesTemplateIDBuildsBuildIDLogsParams defines parameters for GetTemplatesTemplateIDBuildsBuildIDLogs.
type GetTemplatesTemplateIDBuildsBuildIDLogsParams struct {
	// Cursor Starting timestamp of the logs that should be returned in milliseconds
	Cursor *int64 `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of logs that should be returned
	Limit     *int32         `form:"limit,omitempty" json:"limit,omitempty"`
	Direction *LogsDirection `form:"direction,omitempty" json:"direction,omitempty"`
	Level     *LogLevel      `form:"level,omitempty" json:"level,omitempty"`

	// Source Source of the logs that should be returned from
	Source *LogsSource `form:"source,omitempty" json:"source,omitempty"`
}

// GetTemplatesTemplateIDBuildsBuildIDStatusParams defines parameters for GetTemplatesTemplateIDBuildsBuildIDStatus.
type GetTemplatesTemplateIDBuildsBuildIDStatusParams struct {
	// LogsOffset Index of the starting build log that should be returned with the template
	LogsOffset *int32 `form:"logsOffset,omitempty" json:"logsOffset,omitempty"`

	// Limit Maximum number of logs that should be returned
	Limit *int32    `form:"limit,omitempty" json:"limit,omitempty"`
	Level *LogLevel `form:"level,omitempty" json:"level,omitempty"`
}

// GetV2SandboxesParams defines parameters for GetV2Sandboxes.
type GetV2SandboxesParams struct {
	// Metadata Metadata query used to filter the sandboxes (e.g. "user=abc&app=prod"). Each key and values must be URL encoded.
	Metadata *string `form:"metadata,omitempty" json:"metadata,omitempty"`

	// State Filter sandboxes by one or more states
	State *[]SandboxState `form:"state,omitempty" json:"state,omitempty"`

	// NextToken Cursor to start the list from
	NextToken *PaginationNextToken `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// Limit Maximum number of items to return per page
	Limit *PaginationLimit `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostAccessTokensJSONRequestBody defines body for PostAccessTokens for application/json ContentType.
type PostAccessTokensJSONRequestBody = NewAccessToken

// PostApiKeysJSONRequestBody defines body for PostApiKeys for application/json ContentType.
type PostApiKeysJSONRequestBody = NewTeamAPIKey

// PatchApiKeysApiKeyIDJSONRequestBody defines body for PatchApiKeysApiKeyID for application/json ContentType.
type PatchApiKeysApiKeyIDJSONRequestBody = UpdateTeamAPIKey

// PostNodesNodeIDJSONRequestBody defines body for PostNodesNodeID for application/json ContentType.
type PostNodesNodeIDJSONRequestBody = NodeStatusChange

// PostSandboxesJSONRequestBody defines body for PostSandboxes for application/json ContentType.
type PostSandboxesJSONRequestBody = NewSandbox

// PostSandboxesSandboxIDConnectJSONRequestBody defines body for PostSandboxesSandboxIDConnect for application/json ContentType.
type PostSandboxesSandboxIDConnectJSONRequestBody = ConnectSandbox

// PostSandboxesSandboxIDRefreshesJSONRequestBody defines body for PostSandboxesSandboxIDRefreshes for application/json ContentType.
type PostSandboxesSandboxIDRefreshesJSONRequestBody PostSandboxesSandboxIDRefreshesJSONBody

// PostSandboxesSandboxIDResumeJSONRequestBody defines body for PostSandboxesSandboxIDResume for application/json ContentType.
type PostSandboxesSandboxIDResumeJSONRequestBody = ResumedSandbox

// PostSandboxesSandboxIDTimeoutJSONRequestBody defines body for PostSandboxesSandboxIDTimeout for application/json ContentType.
type PostSandboxesSandboxIDTimeoutJSONRequestBody PostSandboxesSandboxIDTimeoutJSONBody

// PostTemplatesJSONRequestBody defines body for PostTemplates for application/json ContentType.
type PostTemplatesJSONRequestBody = TemplateBuildRequest

// DeleteTemplatesTagsJSONRequestBody defines body for DeleteTemplatesTags for application/json ContentType.
type DeleteTemplatesTagsJSONRequestBody = DeleteTemplateTagsRequest

// PostTemplatesTagsJSONRequestBody defines body for PostTemplatesTags for application/json ContentType.
type PostTemplatesTagsJSONRequestBody = AssignTemplateTagsRequest

// PatchTemplatesTemplateIDJSONRequestBody defines body for PatchTemplatesTemplateID for application/json ContentType.
type PatchTemplatesTemplateIDJSONRequestBody = TemplateUpdateRequest

// PostTemplatesTemplateIDJSONRequestBody defines body for PostTemplatesTemplateID for application/json ContentType.
type PostTemplatesTemplateIDJSONRequestBody = TemplateBuildRequest

// PostV2TemplatesJSONRequestBody defines body for PostV2Templates for application/json ContentType.
type PostV2TemplatesJSONRequestBody = TemplateBuildRequestV2

// PatchV2TemplatesTemplateIDJSONRequestBody defines body for PatchV2TemplatesTemplateID for application/json ContentType.
type PatchV2TemplatesTemplateIDJSONRequestBody = TemplateUpdateRequest

// PostV2TemplatesTemplateIDBuildsBuildIDJSONRequestBody defines body for PostV2TemplatesTemplateIDBuildsBuildID for application/json ContentType.
type PostV2TemplatesTemplateIDBuildsBuildIDJSONRequestBody = TemplateBuildStartV2

// PostV3TemplatesJSONRequestBody defines body for PostV3Templates for application/json ContentType.
type PostV3TemplatesJSONRequestBody = TemplateBuildRequestV3

// AsAWSRegistry returns the union data inside the FromImageRegistry as a AWSRegistry
func (t FromImageRegistry) AsAWSRegistry() (AWSRegistry, error) {
	var body AWSRegistry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSRegistry overwrites any union data inside the FromImageRegistry as the provided AWSRegistry
func (t *FromImageRegistry) FromAWSRegistry(v AWSRegistry) error {
	v.Type = "aws"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSRegistry performs a merge with any union data inside the FromImageRegistry, using the provided AWSRegistry
func (t *FromImageRegistry) MergeAWSRegistry(v AWSRegistry) error {
	v.Type = "aws"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGCPRegistry returns the union data inside the FromImageRegistry as a GCPRegistry
func (t FromImageRegistry) AsGCPRegistry() (GCPRegistry, error) {
	var body GCPRegistry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPRegistry overwrites any union data inside the FromImageRegistry as the provided GCPRegistry
func (t *FromImageRegistry) FromGCPRegistry(v GCPRegistry) error {
	v.Type = "gcp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPRegistry performs a merge with any union data inside the FromImageRegistry, using the provided GCPRegistry
func (t *FromImageRegistry) MergeGCPRegistry(v GCPRegistry) error {
	v.Type = "gcp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeneralRegistry returns the union data inside the FromImageRegistry as a GeneralRegistry
func (t FromImageRegistry) AsGeneralRegistry() (GeneralRegistry, error) {
	var body GeneralRegistry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeneralRegistry overwrites any union data inside the FromImageRegistry as the provided GeneralRegistry
func (t *FromImageRegistry) FromGeneralRegistry(v GeneralRegistry) error {
	v.Type = "registry"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeneralRegistry performs a merge with any union data inside the FromImageRegistry, using the provided GeneralRegistry
func (t *FromImageRegistry) MergeGeneralRegistry(v GeneralRegistry) error {
	v.Type = "registry"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FromImageRegistry) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t FromImageRegistry) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "aws":
		return t.AsAWSRegistry()
	case "gcp":
		return t.AsGCPRegistry()
	case "registry":
		return t.AsGeneralRegistry()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t FromImageRegistry) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FromImageRegistry) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostAccessTokensWithBody request with any body
	PostAccessTokensWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAccessTokens(ctx context.Context, body PostAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAccessTokensAccessTokenID request
	DeleteAccessTokensAccessTokenID(ctx context.Context, accessTokenID AccessTokenID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAdminTeamsTeamIDSandboxesKill request
	PostAdminTeamsTeamIDSandboxesKill(ctx context.Context, teamID openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiKeys request
	GetApiKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApiKeysWithBody request with any body
	PostApiKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApiKeys(ctx context.Context, body PostApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApiKeysApiKeyID request
	DeleteApiKeysApiKeyID(ctx context.Context, apiKeyID ApiKeyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApiKeysApiKeyIDWithBody request with any body
	PatchApiKeysApiKeyIDWithBody(ctx context.Context, apiKeyID ApiKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApiKeysApiKeyID(ctx context.Context, apiKeyID ApiKeyID, body PatchApiKeysApiKeyIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealth request
	GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNodes request
	GetNodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNodesNodeID request
	GetNodesNodeID(ctx context.Context, nodeID NodeID, params *GetNodesNodeIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodesNodeIDWithBody request with any body
	PostNodesNodeIDWithBody(ctx context.Context, nodeID NodeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodesNodeID(ctx context.Context, nodeID NodeID, body PostNodesNodeIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxes request
	GetSandboxes(ctx context.Context, params *GetSandboxesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSandboxesWithBody request with any body
	PostSandboxesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSandboxes(ctx context.Context, body PostSandboxesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxesMetrics request
	GetSandboxesMetrics(ctx context.Context, params *GetSandboxesMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSandboxesSandboxID request
	DeleteSandboxesSandboxID(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxesSandboxID request
	GetSandboxesSandboxID(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSandboxesSandboxIDConnectWithBody request with any body
	PostSandboxesSandboxIDConnectWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSandboxesSandboxIDConnect(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxesSandboxIDLogs request
	GetSandboxesSandboxIDLogs(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxesSandboxIDMetrics request
	GetSandboxesSandboxIDMetrics(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSandboxesSandboxIDPause request
	PostSandboxesSandboxIDPause(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSandboxesSandboxIDRefreshesWithBody request with any body
	PostSandboxesSandboxIDRefreshesWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSandboxesSandboxIDRefreshes(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDRefreshesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSandboxesSandboxIDResumeWithBody request with any body
	PostSandboxesSandboxIDResumeWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSandboxesSandboxIDResume(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDResumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSandboxesSandboxIDTimeoutWithBody request with any body
	PostSandboxesSandboxIDTimeoutWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSandboxesSandboxIDTimeout(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeams request
	GetTeams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsTeamIDMetrics request
	GetTeamsTeamIDMetrics(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsTeamIDMetricsMax request
	GetTeamsTeamIDMetricsMax(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsMaxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplates request
	GetTemplates(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTemplatesWithBody request with any body
	PostTemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTemplates(ctx context.Context, body PostTemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplatesAliasesAlias request
	GetTemplatesAliasesAlias(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTemplatesTagsWithBody request with any body
	DeleteTemplatesTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTemplatesTags(ctx context.Context, body DeleteTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTemplatesTagsWithBody request with any body
	PostTemplatesTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTemplatesTags(ctx context.Context, body PostTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTemplatesTemplateID request
	DeleteTemplatesTemplateID(ctx context.Context, templateID TemplateID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplatesTemplateID request
	GetTemplatesTemplateID(ctx context.Context, templateID TemplateID, params *GetTemplatesTemplateIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchTemplatesTemplateIDWithBody request with any body
	PatchTemplatesTemplateIDWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchTemplatesTemplateID(ctx context.Context, templateID TemplateID, body PatchTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTemplatesTemplateIDWithBody request with any body
	PostTemplatesTemplateIDWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTemplatesTemplateID(ctx context.Context, templateID TemplateID, body PostTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTemplatesTemplateIDBuildsBuildID request
	PostTemplatesTemplateIDBuildsBuildID(ctx context.Context, templateID TemplateID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplatesTemplateIDBuildsBuildIDLogs request
	GetTemplatesTemplateIDBuildsBuildIDLogs(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplatesTemplateIDBuildsBuildIDStatus request
	GetTemplatesTemplateIDBuildsBuildIDStatus(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplatesTemplateIDFilesHash request
	GetTemplatesTemplateIDFilesHash(ctx context.Context, templateID TemplateID, hash string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2Sandboxes request
	GetV2Sandboxes(ctx context.Context, params *GetV2SandboxesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2TemplatesWithBody request with any body
	PostV2TemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2Templates(ctx context.Context, body PostV2TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchV2TemplatesTemplateIDWithBody request with any body
	PatchV2TemplatesTemplateIDWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchV2TemplatesTemplateID(ctx context.Context, templateID TemplateID, body PatchV2TemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2TemplatesTemplateIDBuildsBuildIDWithBody request with any body
	PostV2TemplatesTemplateIDBuildsBuildIDWithBody(ctx context.Context, templateID TemplateID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2TemplatesTemplateIDBuildsBuildID(ctx context.Context, templateID TemplateID, buildID BuildID, body PostV2TemplatesTemplateIDBuildsBuildIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV3TemplatesWithBody request with any body
	PostV3TemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV3Templates(ctx context.Context, body PostV3TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostAccessTokensWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAccessTokensRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAccessTokens(ctx context.Context, body PostAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAccessTokensRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAccessTokensAccessTokenID(ctx context.Context, accessTokenID AccessTokenID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccessTokensAccessTokenIDRequest(c.Server, accessTokenID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAdminTeamsTeamIDSandboxesKill(ctx context.Context, teamID openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAdminTeamsTeamIDSandboxesKillRequest(c.Server, teamID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiKeysRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiKeys(ctx context.Context, body PostApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiKeysRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApiKeysApiKeyID(ctx context.Context, apiKeyID ApiKeyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApiKeysApiKeyIDRequest(c.Server, apiKeyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApiKeysApiKeyIDWithBody(ctx context.Context, apiKeyID ApiKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApiKeysApiKeyIDRequestWithBody(c.Server, apiKeyID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApiKeysApiKeyID(ctx context.Context, apiKeyID ApiKeyID, body PatchApiKeysApiKeyIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApiKeysApiKeyIDRequest(c.Server, apiKeyID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNodesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNodesNodeID(ctx context.Context, nodeID NodeID, params *GetNodesNodeIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNodesNodeIDRequest(c.Server, nodeID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodesNodeIDWithBody(ctx context.Context, nodeID NodeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodesNodeIDRequestWithBody(c.Server, nodeID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodesNodeID(ctx context.Context, nodeID NodeID, body PostNodesNodeIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodesNodeIDRequest(c.Server, nodeID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxes(ctx context.Context, params *GetSandboxesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxes(ctx context.Context, body PostSandboxesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxesMetrics(ctx context.Context, params *GetSandboxesMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxesMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSandboxesSandboxID(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSandboxesSandboxIDRequest(c.Server, sandboxID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxesSandboxID(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxesSandboxIDRequest(c.Server, sandboxID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDConnectWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDConnectRequestWithBody(c.Server, sandboxID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDConnect(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDConnectRequest(c.Server, sandboxID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxesSandboxIDLogs(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxesSandboxIDLogsRequest(c.Server, sandboxID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxesSandboxIDMetrics(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxesSandboxIDMetricsRequest(c.Server, sandboxID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDPause(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDPauseRequest(c.Server, sandboxID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDRefreshesWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDRefreshesRequestWithBody(c.Server, sandboxID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDRefreshes(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDRefreshesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDRefreshesRequest(c.Server, sandboxID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDResumeWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDResumeRequestWithBody(c.Server, sandboxID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDResume(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDResumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDResumeRequest(c.Server, sandboxID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDTimeoutWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDTimeoutRequestWithBody(c.Server, sandboxID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSandboxesSandboxIDTimeout(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSandboxesSandboxIDTimeoutRequest(c.Server, sandboxID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsTeamIDMetrics(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsTeamIDMetricsRequest(c.Server, teamID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsTeamIDMetricsMax(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsMaxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsTeamIDMetricsMaxRequest(c.Server, teamID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplates(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTemplatesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTemplates(ctx context.Context, body PostTemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTemplatesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplatesAliasesAlias(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesAliasesAliasRequest(c.Server, alias)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTemplatesTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTemplatesTagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTemplatesTags(ctx context.Context, body DeleteTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTemplatesTagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTemplatesTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTemplatesTagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTemplatesTags(ctx context.Context, body PostTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTemplatesTagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTemplatesTemplateID(ctx context.Context, templateID TemplateID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTemplatesTemplateIDRequest(c.Server, templateID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplatesTemplateID(ctx context.Context, templateID TemplateID, params *GetTemplatesTemplateIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesTemplateIDRequest(c.Server, templateID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchTemplatesTemplateIDWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchTemplatesTemplateIDRequestWithBody(c.Server, templateID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchTemplatesTemplateID(ctx context.Context, templateID TemplateID, body PatchTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchTemplatesTemplateIDRequest(c.Server, templateID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTemplatesTemplateIDWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTemplatesTemplateIDRequestWithBody(c.Server, templateID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTemplatesTemplateID(ctx context.Context, templateID TemplateID, body PostTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTemplatesTemplateIDRequest(c.Server, templateID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTemplatesTemplateIDBuildsBuildID(ctx context.Context, templateID TemplateID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTemplatesTemplateIDBuildsBuildIDRequest(c.Server, templateID, buildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplatesTemplateIDBuildsBuildIDLogs(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesTemplateIDBuildsBuildIDLogsRequest(c.Server, templateID, buildID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplatesTemplateIDBuildsBuildIDStatus(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesTemplateIDBuildsBuildIDStatusRequest(c.Server, templateID, buildID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplatesTemplateIDFilesHash(ctx context.Context, templateID TemplateID, hash string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesTemplateIDFilesHashRequest(c.Server, templateID, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2Sandboxes(ctx context.Context, params *GetV2SandboxesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2SandboxesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2TemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2TemplatesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2Templates(ctx context.Context, body PostV2TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2TemplatesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2TemplatesTemplateIDWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2TemplatesTemplateIDRequestWithBody(c.Server, templateID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2TemplatesTemplateID(ctx context.Context, templateID TemplateID, body PatchV2TemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2TemplatesTemplateIDRequest(c.Server, templateID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2TemplatesTemplateIDBuildsBuildIDWithBody(ctx context.Context, templateID TemplateID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2TemplatesTemplateIDBuildsBuildIDRequestWithBody(c.Server, templateID, buildID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2TemplatesTemplateIDBuildsBuildID(ctx context.Context, templateID TemplateID, buildID BuildID, body PostV2TemplatesTemplateIDBuildsBuildIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2TemplatesTemplateIDBuildsBuildIDRequest(c.Server, templateID, buildID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV3TemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV3TemplatesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV3Templates(ctx context.Context, body PostV3TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV3TemplatesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostAccessTokensRequest calls the generic PostAccessTokens builder with application/json body
func NewPostAccessTokensRequest(server string, body PostAccessTokensJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAccessTokensRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAccessTokensRequestWithBody generates requests for PostAccessTokens with any type of body
func NewPostAccessTokensRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAccessTokensAccessTokenIDRequest generates requests for DeleteAccessTokensAccessTokenID
func NewDeleteAccessTokensAccessTokenIDRequest(server string, accessTokenID AccessTokenID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessTokenID", runtime.ParamLocationPath, accessTokenID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAdminTeamsTeamIDSandboxesKillRequest generates requests for PostAdminTeamsTeamIDSandboxesKill
func NewPostAdminTeamsTeamIDSandboxesKillRequest(server string, teamID openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamID", runtime.ParamLocationPath, teamID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/teams/%s/sandboxes/kill", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiKeysRequest generates requests for GetApiKeys
func NewGetApiKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostApiKeysRequest calls the generic PostApiKeys builder with application/json body
func NewPostApiKeysRequest(server string, body PostApiKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApiKeysRequestWithBody(server, "application/json", bodyReader)
}

// NewPostApiKeysRequestWithBody generates requests for PostApiKeys with any type of body
func NewPostApiKeysRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteApiKeysApiKeyIDRequest generates requests for DeleteApiKeysApiKeyID
func NewDeleteApiKeysApiKeyIDRequest(server string, apiKeyID ApiKeyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiKeyID", runtime.ParamLocationPath, apiKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchApiKeysApiKeyIDRequest calls the generic PatchApiKeysApiKeyID builder with application/json body
func NewPatchApiKeysApiKeyIDRequest(server string, apiKeyID ApiKeyID, body PatchApiKeysApiKeyIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApiKeysApiKeyIDRequestWithBody(server, apiKeyID, "application/json", bodyReader)
}

// NewPatchApiKeysApiKeyIDRequestWithBody generates requests for PatchApiKeysApiKeyID with any type of body
func NewPatchApiKeysApiKeyIDRequestWithBody(server string, apiKeyID ApiKeyID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiKeyID", runtime.ParamLocationPath, apiKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHealthRequest generates requests for GetHealth
func NewGetHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNodesRequest generates requests for GetNodes
func NewGetNodesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNodesNodeIDRequest generates requests for GetNodesNodeID
func NewGetNodesNodeIDRequest(server string, nodeID NodeID, params *GetNodesNodeIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "nodeID", runtime.ParamLocationPath, nodeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClusterID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clusterID", runtime.ParamLocationQuery, *params.ClusterID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostNodesNodeIDRequest calls the generic PostNodesNodeID builder with application/json body
func NewPostNodesNodeIDRequest(server string, nodeID NodeID, body PostNodesNodeIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodesNodeIDRequestWithBody(server, nodeID, "application/json", bodyReader)
}

// NewPostNodesNodeIDRequestWithBody generates requests for PostNodesNodeID with any type of body
func NewPostNodesNodeIDRequestWithBody(server string, nodeID NodeID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "nodeID", runtime.ParamLocationPath, nodeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSandboxesRequest generates requests for GetSandboxes
func NewGetSandboxesRequest(server string, params *GetSandboxesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSandboxesRequest calls the generic PostSandboxes builder with application/json body
func NewPostSandboxesRequest(server string, body PostSandboxesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSandboxesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSandboxesRequestWithBody generates requests for PostSandboxes with any type of body
func NewPostSandboxesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSandboxesMetricsRequest generates requests for GetSandboxesMetrics
func NewGetSandboxesMetricsRequest(server string, params *GetSandboxesMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sandbox_ids", runtime.ParamLocationQuery, params.SandboxIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSandboxesSandboxIDRequest generates requests for DeleteSandboxesSandboxID
func NewDeleteSandboxesSandboxIDRequest(server string, sandboxID SandboxID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSandboxesSandboxIDRequest generates requests for GetSandboxesSandboxID
func NewGetSandboxesSandboxIDRequest(server string, sandboxID SandboxID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSandboxesSandboxIDConnectRequest calls the generic PostSandboxesSandboxIDConnect builder with application/json body
func NewPostSandboxesSandboxIDConnectRequest(server string, sandboxID SandboxID, body PostSandboxesSandboxIDConnectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSandboxesSandboxIDConnectRequestWithBody(server, sandboxID, "application/json", bodyReader)
}

// NewPostSandboxesSandboxIDConnectRequestWithBody generates requests for PostSandboxesSandboxIDConnect with any type of body
func NewPostSandboxesSandboxIDConnectRequestWithBody(server string, sandboxID SandboxID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/connect", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSandboxesSandboxIDLogsRequest generates requests for GetSandboxesSandboxIDLogs
func NewGetSandboxesSandboxIDLogsRequest(server string, sandboxID SandboxID, params *GetSandboxesSandboxIDLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSandboxesSandboxIDMetricsRequest generates requests for GetSandboxesSandboxIDMetrics
func NewGetSandboxesSandboxIDMetricsRequest(server string, sandboxID SandboxID, params *GetSandboxesSandboxIDMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSandboxesSandboxIDPauseRequest generates requests for PostSandboxesSandboxIDPause
func NewPostSandboxesSandboxIDPauseRequest(server string, sandboxID SandboxID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/pause", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSandboxesSandboxIDRefreshesRequest calls the generic PostSandboxesSandboxIDRefreshes builder with application/json body
func NewPostSandboxesSandboxIDRefreshesRequest(server string, sandboxID SandboxID, body PostSandboxesSandboxIDRefreshesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSandboxesSandboxIDRefreshesRequestWithBody(server, sandboxID, "application/json", bodyReader)
}

// NewPostSandboxesSandboxIDRefreshesRequestWithBody generates requests for PostSandboxesSandboxIDRefreshes with any type of body
func NewPostSandboxesSandboxIDRefreshesRequestWithBody(server string, sandboxID SandboxID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/refreshes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSandboxesSandboxIDResumeRequest calls the generic PostSandboxesSandboxIDResume builder with application/json body
func NewPostSandboxesSandboxIDResumeRequest(server string, sandboxID SandboxID, body PostSandboxesSandboxIDResumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSandboxesSandboxIDResumeRequestWithBody(server, sandboxID, "application/json", bodyReader)
}

// NewPostSandboxesSandboxIDResumeRequestWithBody generates requests for PostSandboxesSandboxIDResume with any type of body
func NewPostSandboxesSandboxIDResumeRequestWithBody(server string, sandboxID SandboxID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/resume", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSandboxesSandboxIDTimeoutRequest calls the generic PostSandboxesSandboxIDTimeout builder with application/json body
func NewPostSandboxesSandboxIDTimeoutRequest(server string, sandboxID SandboxID, body PostSandboxesSandboxIDTimeoutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSandboxesSandboxIDTimeoutRequestWithBody(server, sandboxID, "application/json", bodyReader)
}

// NewPostSandboxesSandboxIDTimeoutRequestWithBody generates requests for PostSandboxesSandboxIDTimeout with any type of body
func NewPostSandboxesSandboxIDTimeoutRequestWithBody(server string, sandboxID SandboxID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/timeout", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamsRequest generates requests for GetTeams
func NewGetTeamsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsTeamIDMetricsRequest generates requests for GetTeamsTeamIDMetrics
func NewGetTeamsTeamIDMetricsRequest(server string, teamID TeamID, params *GetTeamsTeamIDMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamID", runtime.ParamLocationPath, teamID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsTeamIDMetricsMaxRequest generates requests for GetTeamsTeamIDMetricsMax
func NewGetTeamsTeamIDMetricsMaxRequest(server string, teamID TeamID, params *GetTeamsTeamIDMetricsMaxParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamID", runtime.ParamLocationPath, teamID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/metrics/max", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metric", runtime.ParamLocationQuery, params.Metric); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplatesRequest generates requests for GetTemplates
func NewGetTemplatesRequest(server string, params *GetTemplatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TeamID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamID", runtime.ParamLocationQuery, *params.TeamID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTemplatesRequest calls the generic PostTemplates builder with application/json body
func NewPostTemplatesRequest(server string, body PostTemplatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTemplatesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostTemplatesRequestWithBody generates requests for PostTemplates with any type of body
func NewPostTemplatesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTemplatesAliasesAliasRequest generates requests for GetTemplatesAliasesAlias
func NewGetTemplatesAliasesAliasRequest(server string, alias string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alias", runtime.ParamLocationPath, alias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/aliases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTemplatesTagsRequest calls the generic DeleteTemplatesTags builder with application/json body
func NewDeleteTemplatesTagsRequest(server string, body DeleteTemplatesTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTemplatesTagsRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteTemplatesTagsRequestWithBody generates requests for DeleteTemplatesTags with any type of body
func NewDeleteTemplatesTagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTemplatesTagsRequest calls the generic PostTemplatesTags builder with application/json body
func NewPostTemplatesTagsRequest(server string, body PostTemplatesTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTemplatesTagsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostTemplatesTagsRequestWithBody generates requests for PostTemplatesTags with any type of body
func NewPostTemplatesTagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTemplatesTemplateIDRequest generates requests for DeleteTemplatesTemplateID
func NewDeleteTemplatesTemplateIDRequest(server string, templateID TemplateID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplatesTemplateIDRequest generates requests for GetTemplatesTemplateID
func NewGetTemplatesTemplateIDRequest(server string, templateID TemplateID, params *GetTemplatesTemplateIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchTemplatesTemplateIDRequest calls the generic PatchTemplatesTemplateID builder with application/json body
func NewPatchTemplatesTemplateIDRequest(server string, templateID TemplateID, body PatchTemplatesTemplateIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchTemplatesTemplateIDRequestWithBody(server, templateID, "application/json", bodyReader)
}

// NewPatchTemplatesTemplateIDRequestWithBody generates requests for PatchTemplatesTemplateID with any type of body
func NewPatchTemplatesTemplateIDRequestWithBody(server string, templateID TemplateID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTemplatesTemplateIDRequest calls the generic PostTemplatesTemplateID builder with application/json body
func NewPostTemplatesTemplateIDRequest(server string, templateID TemplateID, body PostTemplatesTemplateIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTemplatesTemplateIDRequestWithBody(server, templateID, "application/json", bodyReader)
}

// NewPostTemplatesTemplateIDRequestWithBody generates requests for PostTemplatesTemplateID with any type of body
func NewPostTemplatesTemplateIDRequestWithBody(server string, templateID TemplateID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTemplatesTemplateIDBuildsBuildIDRequest generates requests for PostTemplatesTemplateIDBuildsBuildID
func NewPostTemplatesTemplateIDBuildsBuildIDRequest(server string, templateID TemplateID, buildID BuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplatesTemplateIDBuildsBuildIDLogsRequest generates requests for GetTemplatesTemplateIDBuildsBuildIDLogs
func NewGetTemplatesTemplateIDBuildsBuildIDLogsRequest(server string, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s/builds/%s/logs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplatesTemplateIDBuildsBuildIDStatusRequest generates requests for GetTemplatesTemplateIDBuildsBuildIDStatus
func NewGetTemplatesTemplateIDBuildsBuildIDStatusRequest(server string, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s/builds/%s/status", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LogsOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "logsOffset", runtime.ParamLocationQuery, *params.LogsOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplatesTemplateIDFilesHashRequest generates requests for GetTemplatesTemplateIDFilesHash
func NewGetTemplatesTemplateIDFilesHashRequest(server string, templateID TemplateID, hash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s/files/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2SandboxesRequest generates requests for GetV2Sandboxes
func NewGetV2SandboxesRequest(server string, params *GetV2SandboxesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2TemplatesRequest calls the generic PostV2Templates builder with application/json body
func NewPostV2TemplatesRequest(server string, body PostV2TemplatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2TemplatesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2TemplatesRequestWithBody generates requests for PostV2Templates with any type of body
func NewPostV2TemplatesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchV2TemplatesTemplateIDRequest calls the generic PatchV2TemplatesTemplateID builder with application/json body
func NewPatchV2TemplatesTemplateIDRequest(server string, templateID TemplateID, body PatchV2TemplatesTemplateIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchV2TemplatesTemplateIDRequestWithBody(server, templateID, "application/json", bodyReader)
}

// NewPatchV2TemplatesTemplateIDRequestWithBody generates requests for PatchV2TemplatesTemplateID with any type of body
func NewPatchV2TemplatesTemplateIDRequestWithBody(server string, templateID TemplateID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2TemplatesTemplateIDBuildsBuildIDRequest calls the generic PostV2TemplatesTemplateIDBuildsBuildID builder with application/json body
func NewPostV2TemplatesTemplateIDBuildsBuildIDRequest(server string, templateID TemplateID, buildID BuildID, body PostV2TemplatesTemplateIDBuildsBuildIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2TemplatesTemplateIDBuildsBuildIDRequestWithBody(server, templateID, buildID, "application/json", bodyReader)
}

// NewPostV2TemplatesTemplateIDBuildsBuildIDRequestWithBody generates requests for PostV2TemplatesTemplateIDBuildsBuildID with any type of body
func NewPostV2TemplatesTemplateIDBuildsBuildIDRequestWithBody(server string, templateID TemplateID, buildID BuildID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/templates/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV3TemplatesRequest calls the generic PostV3Templates builder with application/json body
func NewPostV3TemplatesRequest(server string, body PostV3TemplatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV3TemplatesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV3TemplatesRequestWithBody generates requests for PostV3Templates with any type of body
func NewPostV3TemplatesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostAccessTokensWithBodyWithResponse request with any body
	PostAccessTokensWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAccessTokensResponse, error)

	PostAccessTokensWithResponse(ctx context.Context, body PostAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAccessTokensResponse, error)

	// DeleteAccessTokensAccessTokenIDWithResponse request
	DeleteAccessTokensAccessTokenIDWithResponse(ctx context.Context, accessTokenID AccessTokenID, reqEditors ...RequestEditorFn) (*DeleteAccessTokensAccessTokenIDResponse, error)

	// PostAdminTeamsTeamIDSandboxesKillWithResponse request
	PostAdminTeamsTeamIDSandboxesKillWithResponse(ctx context.Context, teamID openapi_types.UUID, reqEditors ...RequestEditorFn) (*PostAdminTeamsTeamIDSandboxesKillResponse, error)

	// GetApiKeysWithResponse request
	GetApiKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApiKeysResponse, error)

	// PostApiKeysWithBodyWithResponse request with any body
	PostApiKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiKeysResponse, error)

	PostApiKeysWithResponse(ctx context.Context, body PostApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiKeysResponse, error)

	// DeleteApiKeysApiKeyIDWithResponse request
	DeleteApiKeysApiKeyIDWithResponse(ctx context.Context, apiKeyID ApiKeyID, reqEditors ...RequestEditorFn) (*DeleteApiKeysApiKeyIDResponse, error)

	// PatchApiKeysApiKeyIDWithBodyWithResponse request with any body
	PatchApiKeysApiKeyIDWithBodyWithResponse(ctx context.Context, apiKeyID ApiKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApiKeysApiKeyIDResponse, error)

	PatchApiKeysApiKeyIDWithResponse(ctx context.Context, apiKeyID ApiKeyID, body PatchApiKeysApiKeyIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApiKeysApiKeyIDResponse, error)

	// GetHealthWithResponse request
	GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error)

	// GetNodesWithResponse request
	GetNodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNodesResponse, error)

	// GetNodesNodeIDWithResponse request
	GetNodesNodeIDWithResponse(ctx context.Context, nodeID NodeID, params *GetNodesNodeIDParams, reqEditors ...RequestEditorFn) (*GetNodesNodeIDResponse, error)

	// PostNodesNodeIDWithBodyWithResponse request with any body
	PostNodesNodeIDWithBodyWithResponse(ctx context.Context, nodeID NodeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodesNodeIDResponse, error)

	PostNodesNodeIDWithResponse(ctx context.Context, nodeID NodeID, body PostNodesNodeIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodesNodeIDResponse, error)

	// GetSandboxesWithResponse request
	GetSandboxesWithResponse(ctx context.Context, params *GetSandboxesParams, reqEditors ...RequestEditorFn) (*GetSandboxesResponse, error)

	// PostSandboxesWithBodyWithResponse request with any body
	PostSandboxesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesResponse, error)

	PostSandboxesWithResponse(ctx context.Context, body PostSandboxesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesResponse, error)

	// GetSandboxesMetricsWithResponse request
	GetSandboxesMetricsWithResponse(ctx context.Context, params *GetSandboxesMetricsParams, reqEditors ...RequestEditorFn) (*GetSandboxesMetricsResponse, error)

	// DeleteSandboxesSandboxIDWithResponse request
	DeleteSandboxesSandboxIDWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*DeleteSandboxesSandboxIDResponse, error)

	// GetSandboxesSandboxIDWithResponse request
	GetSandboxesSandboxIDWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*GetSandboxesSandboxIDResponse, error)

	// PostSandboxesSandboxIDConnectWithBodyWithResponse request with any body
	PostSandboxesSandboxIDConnectWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDConnectResponse, error)

	PostSandboxesSandboxIDConnectWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDConnectResponse, error)

	// GetSandboxesSandboxIDLogsWithResponse request
	GetSandboxesSandboxIDLogsWithResponse(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDLogsParams, reqEditors ...RequestEditorFn) (*GetSandboxesSandboxIDLogsResponse, error)

	// GetSandboxesSandboxIDMetricsWithResponse request
	GetSandboxesSandboxIDMetricsWithResponse(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDMetricsParams, reqEditors ...RequestEditorFn) (*GetSandboxesSandboxIDMetricsResponse, error)

	// PostSandboxesSandboxIDPauseWithResponse request
	PostSandboxesSandboxIDPauseWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDPauseResponse, error)

	// PostSandboxesSandboxIDRefreshesWithBodyWithResponse request with any body
	PostSandboxesSandboxIDRefreshesWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDRefreshesResponse, error)

	PostSandboxesSandboxIDRefreshesWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDRefreshesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDRefreshesResponse, error)

	// PostSandboxesSandboxIDResumeWithBodyWithResponse request with any body
	PostSandboxesSandboxIDResumeWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDResumeResponse, error)

	PostSandboxesSandboxIDResumeWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDResumeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDResumeResponse, error)

	// PostSandboxesSandboxIDTimeoutWithBodyWithResponse request with any body
	PostSandboxesSandboxIDTimeoutWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDTimeoutResponse, error)

	PostSandboxesSandboxIDTimeoutWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDTimeoutResponse, error)

	// GetTeamsWithResponse request
	GetTeamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error)

	// GetTeamsTeamIDMetricsWithResponse request
	GetTeamsTeamIDMetricsWithResponse(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsParams, reqEditors ...RequestEditorFn) (*GetTeamsTeamIDMetricsResponse, error)

	// GetTeamsTeamIDMetricsMaxWithResponse request
	GetTeamsTeamIDMetricsMaxWithResponse(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsMaxParams, reqEditors ...RequestEditorFn) (*GetTeamsTeamIDMetricsMaxResponse, error)

	// GetTemplatesWithResponse request
	GetTemplatesWithResponse(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*GetTemplatesResponse, error)

	// PostTemplatesWithBodyWithResponse request with any body
	PostTemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTemplatesResponse, error)

	PostTemplatesWithResponse(ctx context.Context, body PostTemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTemplatesResponse, error)

	// GetTemplatesAliasesAliasWithResponse request
	GetTemplatesAliasesAliasWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*GetTemplatesAliasesAliasResponse, error)

	// DeleteTemplatesTagsWithBodyWithResponse request with any body
	DeleteTemplatesTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTemplatesTagsResponse, error)

	DeleteTemplatesTagsWithResponse(ctx context.Context, body DeleteTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTemplatesTagsResponse, error)

	// PostTemplatesTagsWithBodyWithResponse request with any body
	PostTemplatesTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTemplatesTagsResponse, error)

	PostTemplatesTagsWithResponse(ctx context.Context, body PostTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTemplatesTagsResponse, error)

	// DeleteTemplatesTemplateIDWithResponse request
	DeleteTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, reqEditors ...RequestEditorFn) (*DeleteTemplatesTemplateIDResponse, error)

	// GetTemplatesTemplateIDWithResponse request
	GetTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, params *GetTemplatesTemplateIDParams, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDResponse, error)

	// PatchTemplatesTemplateIDWithBodyWithResponse request with any body
	PatchTemplatesTemplateIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchTemplatesTemplateIDResponse, error)

	PatchTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, body PatchTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchTemplatesTemplateIDResponse, error)

	// PostTemplatesTemplateIDWithBodyWithResponse request with any body
	PostTemplatesTemplateIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTemplatesTemplateIDResponse, error)

	PostTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, body PostTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTemplatesTemplateIDResponse, error)

	// PostTemplatesTemplateIDBuildsBuildIDWithResponse request
	PostTemplatesTemplateIDBuildsBuildIDWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, reqEditors ...RequestEditorFn) (*PostTemplatesTemplateIDBuildsBuildIDResponse, error)

	// GetTemplatesTemplateIDBuildsBuildIDLogsWithResponse request
	GetTemplatesTemplateIDBuildsBuildIDLogsWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDLogsParams, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDBuildsBuildIDLogsResponse, error)

	// GetTemplatesTemplateIDBuildsBuildIDStatusWithResponse request
	GetTemplatesTemplateIDBuildsBuildIDStatusWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDStatusParams, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDBuildsBuildIDStatusResponse, error)

	// GetTemplatesTemplateIDFilesHashWithResponse request
	GetTemplatesTemplateIDFilesHashWithResponse(ctx context.Context, templateID TemplateID, hash string, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDFilesHashResponse, error)

	// GetV2SandboxesWithResponse request
	GetV2SandboxesWithResponse(ctx context.Context, params *GetV2SandboxesParams, reqEditors ...RequestEditorFn) (*GetV2SandboxesResponse, error)

	// PostV2TemplatesWithBodyWithResponse request with any body
	PostV2TemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2TemplatesResponse, error)

	PostV2TemplatesWithResponse(ctx context.Context, body PostV2TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2TemplatesResponse, error)

	// PatchV2TemplatesTemplateIDWithBodyWithResponse request with any body
	PatchV2TemplatesTemplateIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2TemplatesTemplateIDResponse, error)

	PatchV2TemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, body PatchV2TemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2TemplatesTemplateIDResponse, error)

	// PostV2TemplatesTemplateIDBuildsBuildIDWithBodyWithResponse request with any body
	PostV2TemplatesTemplateIDBuildsBuildIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2TemplatesTemplateIDBuildsBuildIDResponse, error)

	PostV2TemplatesTemplateIDBuildsBuildIDWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, body PostV2TemplatesTemplateIDBuildsBuildIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2TemplatesTemplateIDBuildsBuildIDResponse, error)

	// PostV3TemplatesWithBodyWithResponse request with any body
	PostV3TemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV3TemplatesResponse, error)

	PostV3TemplatesWithResponse(ctx context.Context, body PostV3TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV3TemplatesResponse, error)
}

type PostAccessTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreatedAccessToken
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostAccessTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAccessTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAccessTokensAccessTokenIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteAccessTokensAccessTokenIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccessTokensAccessTokenIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAdminTeamsTeamIDSandboxesKillResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSandboxKillResult
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostAdminTeamsTeamIDSandboxesKillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAdminTeamsTeamIDSandboxesKillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamAPIKey
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreatedTeamAPIKey
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApiKeysApiKeyIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteApiKeysApiKeyIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApiKeysApiKeyIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApiKeysApiKeyIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PatchApiKeysApiKeyIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApiKeysApiKeyIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r GetHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Node
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNodesNodeIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NodeDetail
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetNodesNodeIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNodesNodeIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodesNodeIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostNodesNodeIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodesNodeIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListedSandbox
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetSandboxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSandboxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Sandbox
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostSandboxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSandboxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxesMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxesWithMetrics
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetSandboxesMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxesMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSandboxesSandboxIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteSandboxesSandboxIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSandboxesSandboxIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxesSandboxIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxDetail
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetSandboxesSandboxIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxesSandboxIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSandboxesSandboxIDConnectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
	JSON201      *Sandbox
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostSandboxesSandboxIDConnectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSandboxesSandboxIDConnectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxesSandboxIDLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxLogs
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetSandboxesSandboxIDLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxesSandboxIDLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxesSandboxIDMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SandboxMetric
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetSandboxesSandboxIDMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxesSandboxIDMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSandboxesSandboxIDPauseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON409      *N409
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostSandboxesSandboxIDPauseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSandboxesSandboxIDPauseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSandboxesSandboxIDRefreshesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r PostSandboxesSandboxIDRefreshesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSandboxesSandboxIDRefreshesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSandboxesSandboxIDResumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Sandbox
	JSON401      *N401
	JSON404      *N404
	JSON409      *N409
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostSandboxesSandboxIDResumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSandboxesSandboxIDResumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSandboxesSandboxIDTimeoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostSandboxesSandboxIDTimeoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSandboxesSandboxIDTimeoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsTeamIDMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamMetric
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTeamsTeamIDMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsTeamIDMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsTeamIDMetricsMaxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MaxTeamMetric
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTeamsTeamIDMetricsMaxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsTeamIDMetricsMaxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Template
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TemplateLegacy
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesAliasesAliasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateAliasResponse
	JSON400      *N400
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplatesAliasesAliasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesAliasesAliasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTemplatesTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteTemplatesTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTemplatesTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTemplatesTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AssignedTemplateTags
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostTemplatesTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTemplatesTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTemplatesTemplateIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteTemplatesTemplateIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTemplatesTemplateIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesTemplateIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateWithBuilds
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplatesTemplateIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesTemplateIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchTemplatesTemplateIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PatchTemplatesTemplateIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchTemplatesTemplateIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTemplatesTemplateIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TemplateLegacy
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostTemplatesTemplateIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTemplatesTemplateIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTemplatesTemplateIDBuildsBuildIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostTemplatesTemplateIDBuildsBuildIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTemplatesTemplateIDBuildsBuildIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesTemplateIDBuildsBuildIDLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateBuildLogsResponse
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplatesTemplateIDBuildsBuildIDLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesTemplateIDBuildsBuildIDLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesTemplateIDBuildsBuildIDStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateBuildInfo
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplatesTemplateIDBuildsBuildIDStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesTemplateIDBuildsBuildIDStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesTemplateIDFilesHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TemplateBuildFileUpload
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplatesTemplateIDFilesHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesTemplateIDFilesHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2SandboxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListedSandbox
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetV2SandboxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2SandboxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2TemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TemplateLegacy
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostV2TemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2TemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchV2TemplatesTemplateIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateUpdateResponse
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PatchV2TemplatesTemplateIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchV2TemplatesTemplateIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2TemplatesTemplateIDBuildsBuildIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostV2TemplatesTemplateIDBuildsBuildIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2TemplatesTemplateIDBuildsBuildIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV3TemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TemplateRequestResponseV3
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostV3TemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV3TemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostAccessTokensWithBodyWithResponse request with arbitrary body returning *PostAccessTokensResponse
func (c *ClientWithResponses) PostAccessTokensWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAccessTokensResponse, error) {
	rsp, err := c.PostAccessTokensWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAccessTokensResponse(rsp)
}

func (c *ClientWithResponses) PostAccessTokensWithResponse(ctx context.Context, body PostAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAccessTokensResponse, error) {
	rsp, err := c.PostAccessTokens(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAccessTokensResponse(rsp)
}

// DeleteAccessTokensAccessTokenIDWithResponse request returning *DeleteAccessTokensAccessTokenIDResponse
func (c *ClientWithResponses) DeleteAccessTokensAccessTokenIDWithResponse(ctx context.Context, accessTokenID AccessTokenID, reqEditors ...RequestEditorFn) (*DeleteAccessTokensAccessTokenIDResponse, error) {
	rsp, err := c.DeleteAccessTokensAccessTokenID(ctx, accessTokenID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccessTokensAccessTokenIDResponse(rsp)
}

// PostAdminTeamsTeamIDSandboxesKillWithResponse request returning *PostAdminTeamsTeamIDSandboxesKillResponse
func (c *ClientWithResponses) PostAdminTeamsTeamIDSandboxesKillWithResponse(ctx context.Context, teamID openapi_types.UUID, reqEditors ...RequestEditorFn) (*PostAdminTeamsTeamIDSandboxesKillResponse, error) {
	rsp, err := c.PostAdminTeamsTeamIDSandboxesKill(ctx, teamID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAdminTeamsTeamIDSandboxesKillResponse(rsp)
}

// GetApiKeysWithResponse request returning *GetApiKeysResponse
func (c *ClientWithResponses) GetApiKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApiKeysResponse, error) {
	rsp, err := c.GetApiKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiKeysResponse(rsp)
}

// PostApiKeysWithBodyWithResponse request with arbitrary body returning *PostApiKeysResponse
func (c *ClientWithResponses) PostApiKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiKeysResponse, error) {
	rsp, err := c.PostApiKeysWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiKeysResponse(rsp)
}

func (c *ClientWithResponses) PostApiKeysWithResponse(ctx context.Context, body PostApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiKeysResponse, error) {
	rsp, err := c.PostApiKeys(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiKeysResponse(rsp)
}

// DeleteApiKeysApiKeyIDWithResponse request returning *DeleteApiKeysApiKeyIDResponse
func (c *ClientWithResponses) DeleteApiKeysApiKeyIDWithResponse(ctx context.Context, apiKeyID ApiKeyID, reqEditors ...RequestEditorFn) (*DeleteApiKeysApiKeyIDResponse, error) {
	rsp, err := c.DeleteApiKeysApiKeyID(ctx, apiKeyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApiKeysApiKeyIDResponse(rsp)
}

// PatchApiKeysApiKeyIDWithBodyWithResponse request with arbitrary body returning *PatchApiKeysApiKeyIDResponse
func (c *ClientWithResponses) PatchApiKeysApiKeyIDWithBodyWithResponse(ctx context.Context, apiKeyID ApiKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApiKeysApiKeyIDResponse, error) {
	rsp, err := c.PatchApiKeysApiKeyIDWithBody(ctx, apiKeyID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApiKeysApiKeyIDResponse(rsp)
}

func (c *ClientWithResponses) PatchApiKeysApiKeyIDWithResponse(ctx context.Context, apiKeyID ApiKeyID, body PatchApiKeysApiKeyIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApiKeysApiKeyIDResponse, error) {
	rsp, err := c.PatchApiKeysApiKeyID(ctx, apiKeyID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApiKeysApiKeyIDResponse(rsp)
}

// GetHealthWithResponse request returning *GetHealthResponse
func (c *ClientWithResponses) GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error) {
	rsp, err := c.GetHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthResponse(rsp)
}

// GetNodesWithResponse request returning *GetNodesResponse
func (c *ClientWithResponses) GetNodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNodesResponse, error) {
	rsp, err := c.GetNodes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNodesResponse(rsp)
}

// GetNodesNodeIDWithResponse request returning *GetNodesNodeIDResponse
func (c *ClientWithResponses) GetNodesNodeIDWithResponse(ctx context.Context, nodeID NodeID, params *GetNodesNodeIDParams, reqEditors ...RequestEditorFn) (*GetNodesNodeIDResponse, error) {
	rsp, err := c.GetNodesNodeID(ctx, nodeID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNodesNodeIDResponse(rsp)
}

// PostNodesNodeIDWithBodyWithResponse request with arbitrary body returning *PostNodesNodeIDResponse
func (c *ClientWithResponses) PostNodesNodeIDWithBodyWithResponse(ctx context.Context, nodeID NodeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodesNodeIDResponse, error) {
	rsp, err := c.PostNodesNodeIDWithBody(ctx, nodeID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodesNodeIDResponse(rsp)
}

func (c *ClientWithResponses) PostNodesNodeIDWithResponse(ctx context.Context, nodeID NodeID, body PostNodesNodeIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodesNodeIDResponse, error) {
	rsp, err := c.PostNodesNodeID(ctx, nodeID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodesNodeIDResponse(rsp)
}

// GetSandboxesWithResponse request returning *GetSandboxesResponse
func (c *ClientWithResponses) GetSandboxesWithResponse(ctx context.Context, params *GetSandboxesParams, reqEditors ...RequestEditorFn) (*GetSandboxesResponse, error) {
	rsp, err := c.GetSandboxes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxesResponse(rsp)
}

// PostSandboxesWithBodyWithResponse request with arbitrary body returning *PostSandboxesResponse
func (c *ClientWithResponses) PostSandboxesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesResponse, error) {
	rsp, err := c.PostSandboxesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesResponse(rsp)
}

func (c *ClientWithResponses) PostSandboxesWithResponse(ctx context.Context, body PostSandboxesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesResponse, error) {
	rsp, err := c.PostSandboxes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesResponse(rsp)
}

// GetSandboxesMetricsWithResponse request returning *GetSandboxesMetricsResponse
func (c *ClientWithResponses) GetSandboxesMetricsWithResponse(ctx context.Context, params *GetSandboxesMetricsParams, reqEditors ...RequestEditorFn) (*GetSandboxesMetricsResponse, error) {
	rsp, err := c.GetSandboxesMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxesMetricsResponse(rsp)
}

// DeleteSandboxesSandboxIDWithResponse request returning *DeleteSandboxesSandboxIDResponse
func (c *ClientWithResponses) DeleteSandboxesSandboxIDWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*DeleteSandboxesSandboxIDResponse, error) {
	rsp, err := c.DeleteSandboxesSandboxID(ctx, sandboxID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSandboxesSandboxIDResponse(rsp)
}

// GetSandboxesSandboxIDWithResponse request returning *GetSandboxesSandboxIDResponse
func (c *ClientWithResponses) GetSandboxesSandboxIDWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*GetSandboxesSandboxIDResponse, error) {
	rsp, err := c.GetSandboxesSandboxID(ctx, sandboxID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxesSandboxIDResponse(rsp)
}

// PostSandboxesSandboxIDConnectWithBodyWithResponse request with arbitrary body returning *PostSandboxesSandboxIDConnectResponse
func (c *ClientWithResponses) PostSandboxesSandboxIDConnectWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDConnectResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDConnectWithBody(ctx, sandboxID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDConnectResponse(rsp)
}

func (c *ClientWithResponses) PostSandboxesSandboxIDConnectWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDConnectResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDConnect(ctx, sandboxID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDConnectResponse(rsp)
}

// GetSandboxesSandboxIDLogsWithResponse request returning *GetSandboxesSandboxIDLogsResponse
func (c *ClientWithResponses) GetSandboxesSandboxIDLogsWithResponse(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDLogsParams, reqEditors ...RequestEditorFn) (*GetSandboxesSandboxIDLogsResponse, error) {
	rsp, err := c.GetSandboxesSandboxIDLogs(ctx, sandboxID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxesSandboxIDLogsResponse(rsp)
}

// GetSandboxesSandboxIDMetricsWithResponse request returning *GetSandboxesSandboxIDMetricsResponse
func (c *ClientWithResponses) GetSandboxesSandboxIDMetricsWithResponse(ctx context.Context, sandboxID SandboxID, params *GetSandboxesSandboxIDMetricsParams, reqEditors ...RequestEditorFn) (*GetSandboxesSandboxIDMetricsResponse, error) {
	rsp, err := c.GetSandboxesSandboxIDMetrics(ctx, sandboxID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxesSandboxIDMetricsResponse(rsp)
}

// PostSandboxesSandboxIDPauseWithResponse request returning *PostSandboxesSandboxIDPauseResponse
func (c *ClientWithResponses) PostSandboxesSandboxIDPauseWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDPauseResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDPause(ctx, sandboxID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDPauseResponse(rsp)
}

// PostSandboxesSandboxIDRefreshesWithBodyWithResponse request with arbitrary body returning *PostSandboxesSandboxIDRefreshesResponse
func (c *ClientWithResponses) PostSandboxesSandboxIDRefreshesWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDRefreshesResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDRefreshesWithBody(ctx, sandboxID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDRefreshesResponse(rsp)
}

func (c *ClientWithResponses) PostSandboxesSandboxIDRefreshesWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDRefreshesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDRefreshesResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDRefreshes(ctx, sandboxID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDRefreshesResponse(rsp)
}

// PostSandboxesSandboxIDResumeWithBodyWithResponse request with arbitrary body returning *PostSandboxesSandboxIDResumeResponse
func (c *ClientWithResponses) PostSandboxesSandboxIDResumeWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDResumeResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDResumeWithBody(ctx, sandboxID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDResumeResponse(rsp)
}

func (c *ClientWithResponses) PostSandboxesSandboxIDResumeWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDResumeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDResumeResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDResume(ctx, sandboxID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDResumeResponse(rsp)
}

// PostSandboxesSandboxIDTimeoutWithBodyWithResponse request with arbitrary body returning *PostSandboxesSandboxIDTimeoutResponse
func (c *ClientWithResponses) PostSandboxesSandboxIDTimeoutWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDTimeoutResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDTimeoutWithBody(ctx, sandboxID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDTimeoutResponse(rsp)
}

func (c *ClientWithResponses) PostSandboxesSandboxIDTimeoutWithResponse(ctx context.Context, sandboxID SandboxID, body PostSandboxesSandboxIDTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSandboxesSandboxIDTimeoutResponse, error) {
	rsp, err := c.PostSandboxesSandboxIDTimeout(ctx, sandboxID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSandboxesSandboxIDTimeoutResponse(rsp)
}

// GetTeamsWithResponse request returning *GetTeamsResponse
func (c *ClientWithResponses) GetTeamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error) {
	rsp, err := c.GetTeams(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsResponse(rsp)
}

// GetTeamsTeamIDMetricsWithResponse request returning *GetTeamsTeamIDMetricsResponse
func (c *ClientWithResponses) GetTeamsTeamIDMetricsWithResponse(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsParams, reqEditors ...RequestEditorFn) (*GetTeamsTeamIDMetricsResponse, error) {
	rsp, err := c.GetTeamsTeamIDMetrics(ctx, teamID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsTeamIDMetricsResponse(rsp)
}

// GetTeamsTeamIDMetricsMaxWithResponse request returning *GetTeamsTeamIDMetricsMaxResponse
func (c *ClientWithResponses) GetTeamsTeamIDMetricsMaxWithResponse(ctx context.Context, teamID TeamID, params *GetTeamsTeamIDMetricsMaxParams, reqEditors ...RequestEditorFn) (*GetTeamsTeamIDMetricsMaxResponse, error) {
	rsp, err := c.GetTeamsTeamIDMetricsMax(ctx, teamID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsTeamIDMetricsMaxResponse(rsp)
}

// GetTemplatesWithResponse request returning *GetTemplatesResponse
func (c *ClientWithResponses) GetTemplatesWithResponse(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*GetTemplatesResponse, error) {
	rsp, err := c.GetTemplates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesResponse(rsp)
}

// PostTemplatesWithBodyWithResponse request with arbitrary body returning *PostTemplatesResponse
func (c *ClientWithResponses) PostTemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTemplatesResponse, error) {
	rsp, err := c.PostTemplatesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTemplatesResponse(rsp)
}

func (c *ClientWithResponses) PostTemplatesWithResponse(ctx context.Context, body PostTemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTemplatesResponse, error) {
	rsp, err := c.PostTemplates(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTemplatesResponse(rsp)
}

// GetTemplatesAliasesAliasWithResponse request returning *GetTemplatesAliasesAliasResponse
func (c *ClientWithResponses) GetTemplatesAliasesAliasWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*GetTemplatesAliasesAliasResponse, error) {
	rsp, err := c.GetTemplatesAliasesAlias(ctx, alias, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesAliasesAliasResponse(rsp)
}

// DeleteTemplatesTagsWithBodyWithResponse request with arbitrary body returning *DeleteTemplatesTagsResponse
func (c *ClientWithResponses) DeleteTemplatesTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTemplatesTagsResponse, error) {
	rsp, err := c.DeleteTemplatesTagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTemplatesTagsResponse(rsp)
}

func (c *ClientWithResponses) DeleteTemplatesTagsWithResponse(ctx context.Context, body DeleteTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTemplatesTagsResponse, error) {
	rsp, err := c.DeleteTemplatesTags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTemplatesTagsResponse(rsp)
}

// PostTemplatesTagsWithBodyWithResponse request with arbitrary body returning *PostTemplatesTagsResponse
func (c *ClientWithResponses) PostTemplatesTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTemplatesTagsResponse, error) {
	rsp, err := c.PostTemplatesTagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTemplatesTagsResponse(rsp)
}

func (c *ClientWithResponses) PostTemplatesTagsWithResponse(ctx context.Context, body PostTemplatesTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTemplatesTagsResponse, error) {
	rsp, err := c.PostTemplatesTags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTemplatesTagsResponse(rsp)
}

// DeleteTemplatesTemplateIDWithResponse request returning *DeleteTemplatesTemplateIDResponse
func (c *ClientWithResponses) DeleteTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, reqEditors ...RequestEditorFn) (*DeleteTemplatesTemplateIDResponse, error) {
	rsp, err := c.DeleteTemplatesTemplateID(ctx, templateID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTemplatesTemplateIDResponse(rsp)
}

// GetTemplatesTemplateIDWithResponse request returning *GetTemplatesTemplateIDResponse
func (c *ClientWithResponses) GetTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, params *GetTemplatesTemplateIDParams, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDResponse, error) {
	rsp, err := c.GetTemplatesTemplateID(ctx, templateID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesTemplateIDResponse(rsp)
}

// PatchTemplatesTemplateIDWithBodyWithResponse request with arbitrary body returning *PatchTemplatesTemplateIDResponse
func (c *ClientWithResponses) PatchTemplatesTemplateIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchTemplatesTemplateIDResponse, error) {
	rsp, err := c.PatchTemplatesTemplateIDWithBody(ctx, templateID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchTemplatesTemplateIDResponse(rsp)
}

func (c *ClientWithResponses) PatchTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, body PatchTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchTemplatesTemplateIDResponse, error) {
	rsp, err := c.PatchTemplatesTemplateID(ctx, templateID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchTemplatesTemplateIDResponse(rsp)
}

// PostTemplatesTemplateIDWithBodyWithResponse request with arbitrary body returning *PostTemplatesTemplateIDResponse
func (c *ClientWithResponses) PostTemplatesTemplateIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTemplatesTemplateIDResponse, error) {
	rsp, err := c.PostTemplatesTemplateIDWithBody(ctx, templateID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTemplatesTemplateIDResponse(rsp)
}

func (c *ClientWithResponses) PostTemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, body PostTemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTemplatesTemplateIDResponse, error) {
	rsp, err := c.PostTemplatesTemplateID(ctx, templateID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTemplatesTemplateIDResponse(rsp)
}

// PostTemplatesTemplateIDBuildsBuildIDWithResponse request returning *PostTemplatesTemplateIDBuildsBuildIDResponse
func (c *ClientWithResponses) PostTemplatesTemplateIDBuildsBuildIDWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, reqEditors ...RequestEditorFn) (*PostTemplatesTemplateIDBuildsBuildIDResponse, error) {
	rsp, err := c.PostTemplatesTemplateIDBuildsBuildID(ctx, templateID, buildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTemplatesTemplateIDBuildsBuildIDResponse(rsp)
}

// GetTemplatesTemplateIDBuildsBuildIDLogsWithResponse request returning *GetTemplatesTemplateIDBuildsBuildIDLogsResponse
func (c *ClientWithResponses) GetTemplatesTemplateIDBuildsBuildIDLogsWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDLogsParams, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDBuildsBuildIDLogsResponse, error) {
	rsp, err := c.GetTemplatesTemplateIDBuildsBuildIDLogs(ctx, templateID, buildID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesTemplateIDBuildsBuildIDLogsResponse(rsp)
}

// GetTemplatesTemplateIDBuildsBuildIDStatusWithResponse request returning *GetTemplatesTemplateIDBuildsBuildIDStatusResponse
func (c *ClientWithResponses) GetTemplatesTemplateIDBuildsBuildIDStatusWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplatesTemplateIDBuildsBuildIDStatusParams, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDBuildsBuildIDStatusResponse, error) {
	rsp, err := c.GetTemplatesTemplateIDBuildsBuildIDStatus(ctx, templateID, buildID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesTemplateIDBuildsBuildIDStatusResponse(rsp)
}

// GetTemplatesTemplateIDFilesHashWithResponse request returning *GetTemplatesTemplateIDFilesHashResponse
func (c *ClientWithResponses) GetTemplatesTemplateIDFilesHashWithResponse(ctx context.Context, templateID TemplateID, hash string, reqEditors ...RequestEditorFn) (*GetTemplatesTemplateIDFilesHashResponse, error) {
	rsp, err := c.GetTemplatesTemplateIDFilesHash(ctx, templateID, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesTemplateIDFilesHashResponse(rsp)
}

// GetV2SandboxesWithResponse request returning *GetV2SandboxesResponse
func (c *ClientWithResponses) GetV2SandboxesWithResponse(ctx context.Context, params *GetV2SandboxesParams, reqEditors ...RequestEditorFn) (*GetV2SandboxesResponse, error) {
	rsp, err := c.GetV2Sandboxes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2SandboxesResponse(rsp)
}

// PostV2TemplatesWithBodyWithResponse request with arbitrary body returning *PostV2TemplatesResponse
func (c *ClientWithResponses) PostV2TemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2TemplatesResponse, error) {
	rsp, err := c.PostV2TemplatesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2TemplatesResponse(rsp)
}

func (c *ClientWithResponses) PostV2TemplatesWithResponse(ctx context.Context, body PostV2TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2TemplatesResponse, error) {
	rsp, err := c.PostV2Templates(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2TemplatesResponse(rsp)
}

// PatchV2TemplatesTemplateIDWithBodyWithResponse request with arbitrary body returning *PatchV2TemplatesTemplateIDResponse
func (c *ClientWithResponses) PatchV2TemplatesTemplateIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2TemplatesTemplateIDResponse, error) {
	rsp, err := c.PatchV2TemplatesTemplateIDWithBody(ctx, templateID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2TemplatesTemplateIDResponse(rsp)
}

func (c *ClientWithResponses) PatchV2TemplatesTemplateIDWithResponse(ctx context.Context, templateID TemplateID, body PatchV2TemplatesTemplateIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2TemplatesTemplateIDResponse, error) {
	rsp, err := c.PatchV2TemplatesTemplateID(ctx, templateID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2TemplatesTemplateIDResponse(rsp)
}

// PostV2TemplatesTemplateIDBuildsBuildIDWithBodyWithResponse request with arbitrary body returning *PostV2TemplatesTemplateIDBuildsBuildIDResponse
func (c *ClientWithResponses) PostV2TemplatesTemplateIDBuildsBuildIDWithBodyWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2TemplatesTemplateIDBuildsBuildIDResponse, error) {
	rsp, err := c.PostV2TemplatesTemplateIDBuildsBuildIDWithBody(ctx, templateID, buildID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2TemplatesTemplateIDBuildsBuildIDResponse(rsp)
}

func (c *ClientWithResponses) PostV2TemplatesTemplateIDBuildsBuildIDWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, body PostV2TemplatesTemplateIDBuildsBuildIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2TemplatesTemplateIDBuildsBuildIDResponse, error) {
	rsp, err := c.PostV2TemplatesTemplateIDBuildsBuildID(ctx, templateID, buildID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2TemplatesTemplateIDBuildsBuildIDResponse(rsp)
}

// PostV3TemplatesWithBodyWithResponse request with arbitrary body returning *PostV3TemplatesResponse
func (c *ClientWithResponses) PostV3TemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV3TemplatesResponse, error) {
	rsp, err := c.PostV3TemplatesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV3TemplatesResponse(rsp)
}

func (c *ClientWithResponses) PostV3TemplatesWithResponse(ctx context.Context, body PostV3TemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV3TemplatesResponse, error) {
	rsp, err := c.PostV3Templates(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV3TemplatesResponse(rsp)
}

// ParsePostAccessTokensResponse parses an HTTP response from a PostAccessTokensWithResponse call
func ParsePostAccessTokensResponse(rsp *http.Response) (*PostAccessTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAccessTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreatedAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAccessTokensAccessTokenIDResponse parses an HTTP response from a DeleteAccessTokensAccessTokenIDWithResponse call
func ParseDeleteAccessTokensAccessTokenIDResponse(rsp *http.Response) (*DeleteAccessTokensAccessTokenIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccessTokensAccessTokenIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAdminTeamsTeamIDSandboxesKillResponse parses an HTTP response from a PostAdminTeamsTeamIDSandboxesKillWithResponse call
func ParsePostAdminTeamsTeamIDSandboxesKillResponse(rsp *http.Response) (*PostAdminTeamsTeamIDSandboxesKillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAdminTeamsTeamIDSandboxesKillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSandboxKillResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetApiKeysResponse parses an HTTP response from a GetApiKeysWithResponse call
func ParseGetApiKeysResponse(rsp *http.Response) (*GetApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamAPIKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostApiKeysResponse parses an HTTP response from a PostApiKeysWithResponse call
func ParsePostApiKeysResponse(rsp *http.Response) (*PostApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreatedTeamAPIKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteApiKeysApiKeyIDResponse parses an HTTP response from a DeleteApiKeysApiKeyIDWithResponse call
func ParseDeleteApiKeysApiKeyIDResponse(rsp *http.Response) (*DeleteApiKeysApiKeyIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApiKeysApiKeyIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchApiKeysApiKeyIDResponse parses an HTTP response from a PatchApiKeysApiKeyIDWithResponse call
func ParsePatchApiKeysApiKeyIDResponse(rsp *http.Response) (*PatchApiKeysApiKeyIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApiKeysApiKeyIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHealthResponse parses an HTTP response from a GetHealthWithResponse call
func ParseGetHealthResponse(rsp *http.Response) (*GetHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetNodesResponse parses an HTTP response from a GetNodesWithResponse call
func ParseGetNodesResponse(rsp *http.Response) (*GetNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Node
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNodesNodeIDResponse parses an HTTP response from a GetNodesNodeIDWithResponse call
func ParseGetNodesNodeIDResponse(rsp *http.Response) (*GetNodesNodeIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNodesNodeIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NodeDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostNodesNodeIDResponse parses an HTTP response from a PostNodesNodeIDWithResponse call
func ParsePostNodesNodeIDResponse(rsp *http.Response) (*PostNodesNodeIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodesNodeIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxesResponse parses an HTTP response from a GetSandboxesWithResponse call
func ParseGetSandboxesResponse(rsp *http.Response) (*GetSandboxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListedSandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSandboxesResponse parses an HTTP response from a PostSandboxesWithResponse call
func ParsePostSandboxesResponse(rsp *http.Response) (*PostSandboxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSandboxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxesMetricsResponse parses an HTTP response from a GetSandboxesMetricsWithResponse call
func ParseGetSandboxesMetricsResponse(rsp *http.Response) (*GetSandboxesMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxesMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxesWithMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSandboxesSandboxIDResponse parses an HTTP response from a DeleteSandboxesSandboxIDWithResponse call
func ParseDeleteSandboxesSandboxIDResponse(rsp *http.Response) (*DeleteSandboxesSandboxIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSandboxesSandboxIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxesSandboxIDResponse parses an HTTP response from a GetSandboxesSandboxIDWithResponse call
func ParseGetSandboxesSandboxIDResponse(rsp *http.Response) (*GetSandboxesSandboxIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxesSandboxIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSandboxesSandboxIDConnectResponse parses an HTTP response from a PostSandboxesSandboxIDConnectWithResponse call
func ParsePostSandboxesSandboxIDConnectResponse(rsp *http.Response) (*PostSandboxesSandboxIDConnectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSandboxesSandboxIDConnectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxesSandboxIDLogsResponse parses an HTTP response from a GetSandboxesSandboxIDLogsWithResponse call
func ParseGetSandboxesSandboxIDLogsResponse(rsp *http.Response) (*GetSandboxesSandboxIDLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxesSandboxIDLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxLogs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxesSandboxIDMetricsResponse parses an HTTP response from a GetSandboxesSandboxIDMetricsWithResponse call
func ParseGetSandboxesSandboxIDMetricsResponse(rsp *http.Response) (*GetSandboxesSandboxIDMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxesSandboxIDMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SandboxMetric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSandboxesSandboxIDPauseResponse parses an HTTP response from a PostSandboxesSandboxIDPauseWithResponse call
func ParsePostSandboxesSandboxIDPauseResponse(rsp *http.Response) (*PostSandboxesSandboxIDPauseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSandboxesSandboxIDPauseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSandboxesSandboxIDRefreshesResponse parses an HTTP response from a PostSandboxesSandboxIDRefreshesWithResponse call
func ParsePostSandboxesSandboxIDRefreshesResponse(rsp *http.Response) (*PostSandboxesSandboxIDRefreshesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSandboxesSandboxIDRefreshesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostSandboxesSandboxIDResumeResponse parses an HTTP response from a PostSandboxesSandboxIDResumeWithResponse call
func ParsePostSandboxesSandboxIDResumeResponse(rsp *http.Response) (*PostSandboxesSandboxIDResumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSandboxesSandboxIDResumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSandboxesSandboxIDTimeoutResponse parses an HTTP response from a PostSandboxesSandboxIDTimeoutWithResponse call
func ParsePostSandboxesSandboxIDTimeoutResponse(rsp *http.Response) (*PostSandboxesSandboxIDTimeoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSandboxesSandboxIDTimeoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamsResponse parses an HTTP response from a GetTeamsWithResponse call
func ParseGetTeamsResponse(rsp *http.Response) (*GetTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamsTeamIDMetricsResponse parses an HTTP response from a GetTeamsTeamIDMetricsWithResponse call
func ParseGetTeamsTeamIDMetricsResponse(rsp *http.Response) (*GetTeamsTeamIDMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsTeamIDMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamMetric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamsTeamIDMetricsMaxResponse parses an HTTP response from a GetTeamsTeamIDMetricsMaxWithResponse call
func ParseGetTeamsTeamIDMetricsMaxResponse(rsp *http.Response) (*GetTeamsTeamIDMetricsMaxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsTeamIDMetricsMaxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MaxTeamMetric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplatesResponse parses an HTTP response from a GetTemplatesWithResponse call
func ParseGetTemplatesResponse(rsp *http.Response) (*GetTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTemplatesResponse parses an HTTP response from a PostTemplatesWithResponse call
func ParsePostTemplatesResponse(rsp *http.Response) (*PostTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TemplateLegacy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplatesAliasesAliasResponse parses an HTTP response from a GetTemplatesAliasesAliasWithResponse call
func ParseGetTemplatesAliasesAliasResponse(rsp *http.Response) (*GetTemplatesAliasesAliasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesAliasesAliasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateAliasResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTemplatesTagsResponse parses an HTTP response from a DeleteTemplatesTagsWithResponse call
func ParseDeleteTemplatesTagsResponse(rsp *http.Response) (*DeleteTemplatesTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTemplatesTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTemplatesTagsResponse parses an HTTP response from a PostTemplatesTagsWithResponse call
func ParsePostTemplatesTagsResponse(rsp *http.Response) (*PostTemplatesTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTemplatesTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AssignedTemplateTags
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTemplatesTemplateIDResponse parses an HTTP response from a DeleteTemplatesTemplateIDWithResponse call
func ParseDeleteTemplatesTemplateIDResponse(rsp *http.Response) (*DeleteTemplatesTemplateIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTemplatesTemplateIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplatesTemplateIDResponse parses an HTTP response from a GetTemplatesTemplateIDWithResponse call
func ParseGetTemplatesTemplateIDResponse(rsp *http.Response) (*GetTemplatesTemplateIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesTemplateIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateWithBuilds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchTemplatesTemplateIDResponse parses an HTTP response from a PatchTemplatesTemplateIDWithResponse call
func ParsePatchTemplatesTemplateIDResponse(rsp *http.Response) (*PatchTemplatesTemplateIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchTemplatesTemplateIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTemplatesTemplateIDResponse parses an HTTP response from a PostTemplatesTemplateIDWithResponse call
func ParsePostTemplatesTemplateIDResponse(rsp *http.Response) (*PostTemplatesTemplateIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTemplatesTemplateIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TemplateLegacy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTemplatesTemplateIDBuildsBuildIDResponse parses an HTTP response from a PostTemplatesTemplateIDBuildsBuildIDWithResponse call
func ParsePostTemplatesTemplateIDBuildsBuildIDResponse(rsp *http.Response) (*PostTemplatesTemplateIDBuildsBuildIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTemplatesTemplateIDBuildsBuildIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplatesTemplateIDBuildsBuildIDLogsResponse parses an HTTP response from a GetTemplatesTemplateIDBuildsBuildIDLogsWithResponse call
func ParseGetTemplatesTemplateIDBuildsBuildIDLogsResponse(rsp *http.Response) (*GetTemplatesTemplateIDBuildsBuildIDLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesTemplateIDBuildsBuildIDLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateBuildLogsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplatesTemplateIDBuildsBuildIDStatusResponse parses an HTTP response from a GetTemplatesTemplateIDBuildsBuildIDStatusWithResponse call
func ParseGetTemplatesTemplateIDBuildsBuildIDStatusResponse(rsp *http.Response) (*GetTemplatesTemplateIDBuildsBuildIDStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesTemplateIDBuildsBuildIDStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateBuildInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplatesTemplateIDFilesHashResponse parses an HTTP response from a GetTemplatesTemplateIDFilesHashWithResponse call
func ParseGetTemplatesTemplateIDFilesHashResponse(rsp *http.Response) (*GetTemplatesTemplateIDFilesHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesTemplateIDFilesHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TemplateBuildFileUpload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2SandboxesResponse parses an HTTP response from a GetV2SandboxesWithResponse call
func ParseGetV2SandboxesResponse(rsp *http.Response) (*GetV2SandboxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2SandboxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListedSandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV2TemplatesResponse parses an HTTP response from a PostV2TemplatesWithResponse call
func ParsePostV2TemplatesResponse(rsp *http.Response) (*PostV2TemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2TemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TemplateLegacy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchV2TemplatesTemplateIDResponse parses an HTTP response from a PatchV2TemplatesTemplateIDWithResponse call
func ParsePatchV2TemplatesTemplateIDResponse(rsp *http.Response) (*PatchV2TemplatesTemplateIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchV2TemplatesTemplateIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV2TemplatesTemplateIDBuildsBuildIDResponse parses an HTTP response from a PostV2TemplatesTemplateIDBuildsBuildIDWithResponse call
func ParsePostV2TemplatesTemplateIDBuildsBuildIDResponse(rsp *http.Response) (*PostV2TemplatesTemplateIDBuildsBuildIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2TemplatesTemplateIDBuildsBuildIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV3TemplatesResponse parses an HTTP response from a PostV3TemplatesWithResponse call
func ParsePostV3TemplatesResponse(rsp *http.Response) (*PostV3TemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV3TemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TemplateRequestResponseV3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /access-tokens)
	PostAccessTokens(c *gin.Context)

	// (DELETE /access-tokens/{accessTokenID})
	DeleteAccessTokensAccessTokenID(c *gin.Context, accessTokenID AccessTokenID)
	// Kill all sandboxes for a team
	// (POST /admin/teams/{teamID}/sandboxes/kill)
	PostAdminTeamsTeamIDSandboxesKill(c *gin.Context, teamID openapi_types.UUID)

	// (GET /api-keys)
	GetApiKeys(c *gin.Context)

	// (POST /api-keys)
	PostApiKeys(c *gin.Context)

	// (DELETE /api-keys/{apiKeyID})
	DeleteApiKeysApiKeyID(c *gin.Context, apiKeyID ApiKeyID)

	// (PATCH /api-keys/{apiKeyID})
	PatchApiKeysApiKeyID(c *gin.Context, apiKeyID ApiKeyID)

	// (GET /health)
	GetHealth(c *gin.Context)

	// (GET /nodes)
	GetNodes(c *gin.Context)

	// (GET /nodes/{nodeID})
	GetNodesNodeID(c *gin.Context, nodeID NodeID, params GetNodesNodeIDParams)

	// (POST /nodes/{nodeID})
	PostNodesNodeID(c *gin.Context, nodeID NodeID)

	// (GET /sandboxes)
	GetSandboxes(c *gin.Context, params GetSandboxesParams)

	// (POST /sandboxes)
	PostSandboxes(c *gin.Context)

	// (GET /sandboxes/metrics)
	GetSandboxesMetrics(c *gin.Context, params GetSandboxesMetricsParams)

	// (DELETE /sandboxes/{sandboxID})
	DeleteSandboxesSandboxID(c *gin.Context, sandboxID SandboxID)

	// (GET /sandboxes/{sandboxID})
	GetSandboxesSandboxID(c *gin.Context, sandboxID SandboxID)

	// (POST /sandboxes/{sandboxID}/connect)
	PostSandboxesSandboxIDConnect(c *gin.Context, sandboxID SandboxID)

	// (GET /sandboxes/{sandboxID}/logs)
	GetSandboxesSandboxIDLogs(c *gin.Context, sandboxID SandboxID, params GetSandboxesSandboxIDLogsParams)

	// (GET /sandboxes/{sandboxID}/metrics)
	GetSandboxesSandboxIDMetrics(c *gin.Context, sandboxID SandboxID, params GetSandboxesSandboxIDMetricsParams)

	// (POST /sandboxes/{sandboxID}/pause)
	PostSandboxesSandboxIDPause(c *gin.Context, sandboxID SandboxID)

	// (POST /sandboxes/{sandboxID}/refreshes)
	PostSandboxesSandboxIDRefreshes(c *gin.Context, sandboxID SandboxID)

	// (POST /sandboxes/{sandboxID}/resume)
	PostSandboxesSandboxIDResume(c *gin.Context, sandboxID SandboxID)

	// (POST /sandboxes/{sandboxID}/timeout)
	PostSandboxesSandboxIDTimeout(c *gin.Context, sandboxID SandboxID)

	// (GET /teams)
	GetTeams(c *gin.Context)

	// (GET /teams/{teamID}/metrics)
	GetTeamsTeamIDMetrics(c *gin.Context, teamID TeamID, params GetTeamsTeamIDMetricsParams)

	// (GET /teams/{teamID}/metrics/max)
	GetTeamsTeamIDMetricsMax(c *gin.Context, teamID TeamID, params GetTeamsTeamIDMetricsMaxParams)

	// (GET /templates)
	GetTemplates(c *gin.Context, params GetTemplatesParams)

	// (POST /templates)
	PostTemplates(c *gin.Context)

	// (GET /templates/aliases/{alias})
	GetTemplatesAliasesAlias(c *gin.Context, alias string)

	// (DELETE /templates/tags)
	DeleteTemplatesTags(c *gin.Context)

	// (POST /templates/tags)
	PostTemplatesTags(c *gin.Context)

	// (DELETE /templates/{templateID})
	DeleteTemplatesTemplateID(c *gin.Context, templateID TemplateID)

	// (GET /templates/{templateID})
	GetTemplatesTemplateID(c *gin.Context, templateID TemplateID, params GetTemplatesTemplateIDParams)

	// (PATCH /templates/{templateID})
	PatchTemplatesTemplateID(c *gin.Context, templateID TemplateID)

	// (POST /templates/{templateID})
	PostTemplatesTemplateID(c *gin.Context, templateID TemplateID)

	// (POST /templates/{templateID}/builds/{buildID})
	PostTemplatesTemplateIDBuildsBuildID(c *gin.Context, templateID TemplateID, buildID BuildID)

	// (GET /templates/{templateID}/builds/{buildID}/logs)
	GetTemplatesTemplateIDBuildsBuildIDLogs(c *gin.Context, templateID TemplateID, buildID BuildID, params GetTemplatesTemplateIDBuildsBuildIDLogsParams)

	// (GET /templates/{templateID}/builds/{buildID}/status)
	GetTemplatesTemplateIDBuildsBuildIDStatus(c *gin.Context, templateID TemplateID, buildID BuildID, params GetTemplatesTemplateIDBuildsBuildIDStatusParams)

	// (GET /templates/{templateID}/files/{hash})
	GetTemplatesTemplateIDFilesHash(c *gin.Context, templateID TemplateID, hash string)

	// (GET /v2/sandboxes)
	GetV2Sandboxes(c *gin.Context, params GetV2SandboxesParams)

	// (POST /v2/templates)
	PostV2Templates(c *gin.Context)

	// (PATCH /v2/templates/{templateID})
	PatchV2TemplatesTemplateID(c *gin.Context, templateID TemplateID)

	// (POST /v2/templates/{templateID}/builds/{buildID})
	PostV2TemplatesTemplateIDBuildsBuildID(c *gin.Context, templateID TemplateID, buildID BuildID)

	// (POST /v3/templates)
	PostV3Templates(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// PostAccessTokens operation middleware
func (siw *ServerInterfaceWrapper) PostAccessTokens(c *gin.Context) {

	c.Set(Supabase1TokenAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostAccessTokens(c)
}

// DeleteAccessTokensAccessTokenID operation middleware
func (siw *ServerInterfaceWrapper) DeleteAccessTokensAccessTokenID(c *gin.Context) {

	var err error

	// ------------- Path parameter "accessTokenID" -------------
	var accessTokenID AccessTokenID

	err = runtime.BindStyledParameterWithOptions("simple", "accessTokenID", c.Param("accessTokenID"), &accessTokenID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter accessTokenID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(Supabase1TokenAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteAccessTokensAccessTokenID(c, accessTokenID)
}

// PostAdminTeamsTeamIDSandboxesKill operation middleware
func (siw *ServerInterfaceWrapper) PostAdminTeamsTeamIDSandboxesKill(c *gin.Context) {

	var err error

	// ------------- Path parameter "teamID" -------------
	var teamID openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "teamID", c.Param("teamID"), &teamID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter teamID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AdminTokenAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostAdminTeamsTeamIDSandboxesKill(c, teamID)
}

// GetApiKeys operation middleware
func (siw *ServerInterfaceWrapper) GetApiKeys(c *gin.Context) {

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetApiKeys(c)
}

// PostApiKeys operation middleware
func (siw *ServerInterfaceWrapper) PostApiKeys(c *gin.Context) {

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostApiKeys(c)
}

// DeleteApiKeysApiKeyID operation middleware
func (siw *ServerInterfaceWrapper) DeleteApiKeysApiKeyID(c *gin.Context) {

	var err error

	// ------------- Path parameter "apiKeyID" -------------
	var apiKeyID ApiKeyID

	err = runtime.BindStyledParameterWithOptions("simple", "apiKeyID", c.Param("apiKeyID"), &apiKeyID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter apiKeyID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteApiKeysApiKeyID(c, apiKeyID)
}

// PatchApiKeysApiKeyID operation middleware
func (siw *ServerInterfaceWrapper) PatchApiKeysApiKeyID(c *gin.Context) {

	var err error

	// ------------- Path parameter "apiKeyID" -------------
	var apiKeyID ApiKeyID

	err = runtime.BindStyledParameterWithOptions("simple", "apiKeyID", c.Param("apiKeyID"), &apiKeyID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter apiKeyID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchApiKeysApiKeyID(c, apiKeyID)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// GetNodes operation middleware
func (siw *ServerInterfaceWrapper) GetNodes(c *gin.Context) {

	c.Set(AdminTokenAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetNodes(c)
}

// GetNodesNodeID operation middleware
func (siw *ServerInterfaceWrapper) GetNodesNodeID(c *gin.Context) {

	var err error

	// ------------- Path parameter "nodeID" -------------
	var nodeID NodeID

	err = runtime.BindStyledParameterWithOptions("simple", "nodeID", c.Param("nodeID"), &nodeID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nodeID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AdminTokenAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNodesNodeIDParams

	// ------------- Optional query parameter "clusterID" -------------

	err = runtime.BindQueryParameter("form", true, false, "clusterID", c.Request.URL.Query(), &params.ClusterID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter clusterID: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetNodesNodeID(c, nodeID, params)
}

// PostNodesNodeID operation middleware
func (siw *ServerInterfaceWrapper) PostNodesNodeID(c *gin.Context) {

	var err error

	// ------------- Path parameter "nodeID" -------------
	var nodeID NodeID

	err = runtime.BindStyledParameterWithOptions("simple", "nodeID", c.Param("nodeID"), &nodeID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nodeID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AdminTokenAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostNodesNodeID(c, nodeID)
}

// GetSandboxes operation middleware
func (siw *ServerInterfaceWrapper) GetSandboxes(c *gin.Context) {

	var err error

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSandboxesParams

	// ------------- Optional query parameter "metadata" -------------

	err = runtime.BindQueryParameter("form", true, false, "metadata", c.Request.URL.Query(), &params.Metadata)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter metadata: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSandboxes(c, params)
}

// PostSandboxes operation middleware
func (siw *ServerInterfaceWrapper) PostSandboxes(c *gin.Context) {

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSandboxes(c)
}

// GetSandboxesMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetSandboxesMetrics(c *gin.Context) {

	var err error

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSandboxesMetricsParams

	// ------------- Required query parameter "sandbox_ids" -------------

	if paramValue := c.Query("sandbox_ids"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument sandbox_ids is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", false, true, "sandbox_ids", c.Request.URL.Query(), &params.SandboxIds)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandbox_ids: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSandboxesMetrics(c, params)
}

// DeleteSandboxesSandboxID operation middleware
func (siw *ServerInterfaceWrapper) DeleteSandboxesSandboxID(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteSandboxesSandboxID(c, sandboxID)
}

// GetSandboxesSandboxID operation middleware
func (siw *ServerInterfaceWrapper) GetSandboxesSandboxID(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSandboxesSandboxID(c, sandboxID)
}

// PostSandboxesSandboxIDConnect operation middleware
func (siw *ServerInterfaceWrapper) PostSandboxesSandboxIDConnect(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSandboxesSandboxIDConnect(c, sandboxID)
}

// GetSandboxesSandboxIDLogs operation middleware
func (siw *ServerInterfaceWrapper) GetSandboxesSandboxIDLogs(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSandboxesSandboxIDLogsParams

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", c.Request.URL.Query(), &params.Start)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter start: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSandboxesSandboxIDLogs(c, sandboxID, params)
}

// GetSandboxesSandboxIDMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetSandboxesSandboxIDMetrics(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSandboxesSandboxIDMetricsParams

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", c.Request.URL.Query(), &params.Start)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter start: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", c.Request.URL.Query(), &params.End)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter end: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSandboxesSandboxIDMetrics(c, sandboxID, params)
}

// PostSandboxesSandboxIDPause operation middleware
func (siw *ServerInterfaceWrapper) PostSandboxesSandboxIDPause(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSandboxesSandboxIDPause(c, sandboxID)
}

// PostSandboxesSandboxIDRefreshes operation middleware
func (siw *ServerInterfaceWrapper) PostSandboxesSandboxIDRefreshes(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSandboxesSandboxIDRefreshes(c, sandboxID)
}

// PostSandboxesSandboxIDResume operation middleware
func (siw *ServerInterfaceWrapper) PostSandboxesSandboxIDResume(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSandboxesSandboxIDResume(c, sandboxID)
}

// PostSandboxesSandboxIDTimeout operation middleware
func (siw *ServerInterfaceWrapper) PostSandboxesSandboxIDTimeout(c *gin.Context) {

	var err error

	// ------------- Path parameter "sandboxID" -------------
	var sandboxID SandboxID

	err = runtime.BindStyledParameterWithOptions("simple", "sandboxID", c.Param("sandboxID"), &sandboxID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sandboxID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSandboxesSandboxIDTimeout(c, sandboxID)
}

// GetTeams operation middleware
func (siw *ServerInterfaceWrapper) GetTeams(c *gin.Context) {

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTeams(c)
}

// GetTeamsTeamIDMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetTeamsTeamIDMetrics(c *gin.Context) {

	var err error

	// ------------- Path parameter "teamID" -------------
	var teamID TeamID

	err = runtime.BindStyledParameterWithOptions("simple", "teamID", c.Param("teamID"), &teamID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter teamID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTeamsTeamIDMetricsParams

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", c.Request.URL.Query(), &params.Start)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter start: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", c.Request.URL.Query(), &params.End)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter end: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTeamsTeamIDMetrics(c, teamID, params)
}

// GetTeamsTeamIDMetricsMax operation middleware
func (siw *ServerInterfaceWrapper) GetTeamsTeamIDMetricsMax(c *gin.Context) {

	var err error

	// ------------- Path parameter "teamID" -------------
	var teamID TeamID

	err = runtime.BindStyledParameterWithOptions("simple", "teamID", c.Param("teamID"), &teamID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter teamID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTeamsTeamIDMetricsMaxParams

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", c.Request.URL.Query(), &params.Start)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter start: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", c.Request.URL.Query(), &params.End)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter end: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "metric" -------------

	if paramValue := c.Query("metric"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument metric is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "metric", c.Request.URL.Query(), &params.Metric)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter metric: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTeamsTeamIDMetricsMax(c, teamID, params)
}

// GetTemplates operation middleware
func (siw *ServerInterfaceWrapper) GetTemplates(c *gin.Context) {

	var err error

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTemplatesParams

	// ------------- Optional query parameter "teamID" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamID", c.Request.URL.Query(), &params.TeamID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter teamID: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTemplates(c, params)
}

// PostTemplates operation middleware
func (siw *ServerInterfaceWrapper) PostTemplates(c *gin.Context) {

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostTemplates(c)
}

// GetTemplatesAliasesAlias operation middleware
func (siw *ServerInterfaceWrapper) GetTemplatesAliasesAlias(c *gin.Context) {

	var err error

	// ------------- Path parameter "alias" -------------
	var alias string

	err = runtime.BindStyledParameterWithOptions("simple", "alias", c.Param("alias"), &alias, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter alias: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTemplatesAliasesAlias(c, alias)
}

// DeleteTemplatesTags operation middleware
func (siw *ServerInterfaceWrapper) DeleteTemplatesTags(c *gin.Context) {

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteTemplatesTags(c)
}

// PostTemplatesTags operation middleware
func (siw *ServerInterfaceWrapper) PostTemplatesTags(c *gin.Context) {

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostTemplatesTags(c)
}

// DeleteTemplatesTemplateID operation middleware
func (siw *ServerInterfaceWrapper) DeleteTemplatesTemplateID(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteTemplatesTemplateID(c, templateID)
}

// GetTemplatesTemplateID operation middleware
func (siw *ServerInterfaceWrapper) GetTemplatesTemplateID(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTemplatesTemplateIDParams

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", c.Request.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nextToken: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTemplatesTemplateID(c, templateID, params)
}

// PatchTemplatesTemplateID operation middleware
func (siw *ServerInterfaceWrapper) PatchTemplatesTemplateID(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchTemplatesTemplateID(c, templateID)
}

// PostTemplatesTemplateID operation middleware
func (siw *ServerInterfaceWrapper) PostTemplatesTemplateID(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostTemplatesTemplateID(c, templateID)
}

// PostTemplatesTemplateIDBuildsBuildID operation middleware
func (siw *ServerInterfaceWrapper) PostTemplatesTemplateIDBuildsBuildID(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "buildID" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "buildID", c.Param("buildID"), &buildID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter buildID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostTemplatesTemplateIDBuildsBuildID(c, templateID, buildID)
}

// GetTemplatesTemplateIDBuildsBuildIDLogs operation middleware
func (siw *ServerInterfaceWrapper) GetTemplatesTemplateIDBuildsBuildIDLogs(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "buildID" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "buildID", c.Param("buildID"), &buildID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter buildID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTemplatesTemplateIDBuildsBuildIDLogsParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", c.Request.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter cursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", c.Request.URL.Query(), &params.Direction)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter direction: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "level" -------------

	err = runtime.BindQueryParameter("form", true, false, "level", c.Request.URL.Query(), &params.Level)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter level: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "source" -------------

	err = runtime.BindQueryParameter("form", true, false, "source", c.Request.URL.Query(), &params.Source)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter source: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTemplatesTemplateIDBuildsBuildIDLogs(c, templateID, buildID, params)
}

// GetTemplatesTemplateIDBuildsBuildIDStatus operation middleware
func (siw *ServerInterfaceWrapper) GetTemplatesTemplateIDBuildsBuildIDStatus(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "buildID" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "buildID", c.Param("buildID"), &buildID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter buildID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTemplatesTemplateIDBuildsBuildIDStatusParams

	// ------------- Optional query parameter "logsOffset" -------------

	err = runtime.BindQueryParameter("form", true, false, "logsOffset", c.Request.URL.Query(), &params.LogsOffset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter logsOffset: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "level" -------------

	err = runtime.BindQueryParameter("form", true, false, "level", c.Request.URL.Query(), &params.Level)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter level: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTemplatesTemplateIDBuildsBuildIDStatus(c, templateID, buildID, params)
}

// GetTemplatesTemplateIDFilesHash operation middleware
func (siw *ServerInterfaceWrapper) GetTemplatesTemplateIDFilesHash(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "hash" -------------
	var hash string

	err = runtime.BindStyledParameterWithOptions("simple", "hash", c.Param("hash"), &hash, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter hash: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTemplatesTemplateIDFilesHash(c, templateID, hash)
}

// GetV2Sandboxes operation middleware
func (siw *ServerInterfaceWrapper) GetV2Sandboxes(c *gin.Context) {

	var err error

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetV2SandboxesParams

	// ------------- Optional query parameter "metadata" -------------

	err = runtime.BindQueryParameter("form", true, false, "metadata", c.Request.URL.Query(), &params.Metadata)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter metadata: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", false, false, "state", c.Request.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter state: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", c.Request.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nextToken: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetV2Sandboxes(c, params)
}

// PostV2Templates operation middleware
func (siw *ServerInterfaceWrapper) PostV2Templates(c *gin.Context) {

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostV2Templates(c)
}

// PatchV2TemplatesTemplateID operation middleware
func (siw *ServerInterfaceWrapper) PatchV2TemplatesTemplateID(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(AccessTokenAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchV2TemplatesTemplateID(c, templateID)
}

// PostV2TemplatesTemplateIDBuildsBuildID operation middleware
func (siw *ServerInterfaceWrapper) PostV2TemplatesTemplateIDBuildsBuildID(c *gin.Context) {

	var err error

	// ------------- Path parameter "templateID" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "templateID", c.Param("templateID"), &templateID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter templateID: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "buildID" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "buildID", c.Param("buildID"), &buildID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter buildID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostV2TemplatesTemplateIDBuildsBuildID(c, templateID, buildID)
}

// PostV3Templates operation middleware
func (siw *ServerInterfaceWrapper) PostV3Templates(c *gin.Context) {

	c.Set(ApiKeyAuthScopes, []string{})

	c.Set(Supabase1TokenAuthScopes, []string{})

	c.Set(Supabase2TeamAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostV3Templates(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/access-tokens", wrapper.PostAccessTokens)
	router.DELETE(options.BaseURL+"/access-tokens/:accessTokenID", wrapper.DeleteAccessTokensAccessTokenID)
	router.POST(options.BaseURL+"/admin/teams/:teamID/sandboxes/kill", wrapper.PostAdminTeamsTeamIDSandboxesKill)
	router.GET(options.BaseURL+"/api-keys", wrapper.GetApiKeys)
	router.POST(options.BaseURL+"/api-keys", wrapper.PostApiKeys)
	router.DELETE(options.BaseURL+"/api-keys/:apiKeyID", wrapper.DeleteApiKeysApiKeyID)
	router.PATCH(options.BaseURL+"/api-keys/:apiKeyID", wrapper.PatchApiKeysApiKeyID)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.GET(options.BaseURL+"/nodes", wrapper.GetNodes)
	router.GET(options.BaseURL+"/nodes/:nodeID", wrapper.GetNodesNodeID)
	router.POST(options.BaseURL+"/nodes/:nodeID", wrapper.PostNodesNodeID)
	router.GET(options.BaseURL+"/sandboxes", wrapper.GetSandboxes)
	router.POST(options.BaseURL+"/sandboxes", wrapper.PostSandboxes)
	router.GET(options.BaseURL+"/sandboxes/metrics", wrapper.GetSandboxesMetrics)
	router.DELETE(options.BaseURL+"/sandboxes/:sandboxID", wrapper.DeleteSandboxesSandboxID)
	router.GET(options.BaseURL+"/sandboxes/:sandboxID", wrapper.GetSandboxesSandboxID)
	router.POST(options.BaseURL+"/sandboxes/:sandboxID/connect", wrapper.PostSandboxesSandboxIDConnect)
	router.GET(options.BaseURL+"/sandboxes/:sandboxID/logs", wrapper.GetSandboxesSandboxIDLogs)
	router.GET(options.BaseURL+"/sandboxes/:sandboxID/metrics", wrapper.GetSandboxesSandboxIDMetrics)
	router.POST(options.BaseURL+"/sandboxes/:sandboxID/pause", wrapper.PostSandboxesSandboxIDPause)
	router.POST(options.BaseURL+"/sandboxes/:sandboxID/refreshes", wrapper.PostSandboxesSandboxIDRefreshes)
	router.POST(options.BaseURL+"/sandboxes/:sandboxID/resume", wrapper.PostSandboxesSandboxIDResume)
	router.POST(options.BaseURL+"/sandboxes/:sandboxID/timeout", wrapper.PostSandboxesSandboxIDTimeout)
	router.GET(options.BaseURL+"/teams", wrapper.GetTeams)
	router.GET(options.BaseURL+"/teams/:teamID/metrics", wrapper.GetTeamsTeamIDMetrics)
	router.GET(options.BaseURL+"/teams/:teamID/metrics/max", wrapper.GetTeamsTeamIDMetricsMax)
	router.GET(options.BaseURL+"/templates", wrapper.GetTemplates)
	router.POST(options.BaseURL+"/templates", wrapper.PostTemplates)
	router.GET(options.BaseURL+"/templates/aliases/:alias", wrapper.GetTemplatesAliasesAlias)
	router.DELETE(options.BaseURL+"/templates/tags", wrapper.DeleteTemplatesTags)
	router.POST(options.BaseURL+"/templates/tags", wrapper.PostTemplatesTags)
	router.DELETE(options.BaseURL+"/templates/:templateID", wrapper.DeleteTemplatesTemplateID)
	router.GET(options.BaseURL+"/templates/:templateID", wrapper.GetTemplatesTemplateID)
	router.PATCH(options.BaseURL+"/templates/:templateID", wrapper.PatchTemplatesTemplateID)
	router.POST(options.BaseURL+"/templates/:templateID", wrapper.PostTemplatesTemplateID)
	router.POST(options.BaseURL+"/templates/:templateID/builds/:buildID", wrapper.PostTemplatesTemplateIDBuildsBuildID)
	router.GET(options.BaseURL+"/templates/:templateID/builds/:buildID/logs", wrapper.GetTemplatesTemplateIDBuildsBuildIDLogs)
	router.GET(options.BaseURL+"/templates/:templateID/builds/:buildID/status", wrapper.GetTemplatesTemplateIDBuildsBuildIDStatus)
	router.GET(options.BaseURL+"/templates/:templateID/files/:hash", wrapper.GetTemplatesTemplateIDFilesHash)
	router.GET(options.BaseURL+"/v2/sandboxes", wrapper.GetV2Sandboxes)
	router.POST(options.BaseURL+"/v2/templates", wrapper.PostV2Templates)
	router.PATCH(options.BaseURL+"/v2/templates/:templateID", wrapper.PatchV2TemplatesTemplateID)
	router.POST(options.BaseURL+"/v2/templates/:templateID/builds/:buildID", wrapper.PostV2TemplatesTemplateIDBuildsBuildID)
	router.POST(options.BaseURL+"/v3/templates", wrapper.PostV3Templates)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9W28cN7LwXyH6+x4SYCzJl12cNbAPsmxntZEcQZfkAIkRUN01M1z1LSRb0qyh/37A",
	"ItnN7mbfRqORbAt5iDXNa1WxqlhVrPoShFmSZymkUgRvvwQ55TQBCRz/omEIQpxnV5Aevlc/sDR4G+RU",
	"LoNZkNIEgreNNrOAw18F4xAFbyUvYBaIcAkJVZ3lKlcdhOQsXQR3d7OA5uxnWHUPbT9PG/WyYHHUOaj9",
	"Om3MNIugc0jzcdqIOV2wlEqWpUcsYVI1ikCEnOXqt+BtcExvWVIkJC2SS+AkmxMmIRFEZoSDLHhKcuAk",
	"pwsIZnpVfxXAV9WyYhzXXUUEc1rEMnj7cm9vFswznlAZvA1YKl+/CmZBomc0nxOWmr9mdvkslbAA3lj/",
	"J7iViP/2Hg4KLjKuliwk5ZLIJZCYCUnmPEs6lp2Ww/UDUNA0usxuO7FSfZ+GGAk06RzUfJw6YpLHVELP",
	"qGWDKSPfqcYiz1IBeFzf7O2p/4VZKiFFiqJ5HrMQsbT7H5Ehhqrx/j+HefA2+H+7FQ/Y1V/F7gfOM67n",
	"qKP0HY2IWiIIGdzNgjd7Lx9+zv1CLiGVZlQCup2a/PXDT/4x45csiiDVM755+Bk/ZZLMsyKN9Iz/ePgZ",
	"D7J0HrMQMfq3bVDRGfBr4BaTd5bKkYz3fzs7hQUTkq9QJPEsBy6ZpnF6I/ZR4ijJELU5zv5vZ0Q3ID/D",
	"ihy+J/OMkw8Hp4TWiCiYNY/TTI2tJs5S/7D6G7lZAgfkZGpUblZKmCBxFlIJUcfQZxBykOXi/XPoRu4O",
	"xi9f/9Ac9XyVgxIe5UJbA0GquPzvao3B55mHf1Uc6Xf9ddZEg3eDLkCrcbPL/4AmtP0oYemZ5tI/szg+",
	"BYHCqYnyOWUxRAdZkXqk5KdSOhp+D4LIJZVE91Ki54rFcdCWYbNAfZg0sChwc/MijldE9w68wtGFmDvL",
	"rLaZzwoIQrBFem4EwDldiFPDXFtwkHQhPPilC9QJKA6k/qVI00oUJWOV1uARH+XCKed0hX9TvgDpm0L9",
	"Xo5JWEr+QNH1VtLFHwExisQg6ejhZ3oj1eYhcrff3rejz9XXdRgpOp4zjSa1bWyqQJGFTB1FcsPkUn0R",
	"QHBWR+spCuY9qn4w26XiMHa6NaDcggkuym5RAeWd+vdRtviQehlgDNcQD/Hdo2xxhO3uZkECQiglsbWl",
	"o2xBzEdiub0HHkJC3u58JiFXhFBBPecZMi0OMYLeUGKcLQjgVnywZgkISRPPBOf2kwW2O1CJxIhKeKFG",
	"Gaa+cqoKJDMDzRLsZ5LKQpwCNVKuAXqNFPNXqUz//nnmgSzolk1wCJyBcD2FQzd96KyThOfkduL42ODX",
	"noP6/DMSFpxDKuMV4ZBnXLJ0QbI01mIHpbPpMZEyHBY8iBm7eIWFg5OLDn58cHJBwoyDwKXhVjRfDnw3",
	"mZ67y0xpOymE0ogeD6NlCWSF9NNkVkhF9wLCLI0EXmRwNQaSRHUmdC6Bk5slC5fuUolYZkUcEbjNGYfe",
	"he8NyhW7Sp9oPeCgiG6/upu3dxmaNnLg7OkLPpFqFIKdtNow5gzOAhaN4dvuHGN4dELF1dChqWY5puKK",
	"pYv3ICmLheqv710tkU8T6FhRm3P5L7znSyBaPTDgHRiogVPcLS7OzmD2OnPQ9blC8DnQZP/k0KiT6+F3",
	"/+SQXMFqOmrNBO9wbhrHv8yDt7/340St90IoYv48C9IijullDPqiO5pWzHrHkMmVT80+pTfkmsYFtAds",
	"DRBTIS8EeNZ1RIU563LJRAnEGypIIZDpeYFY3/OjUHbndn20qBsaEjSEWafE9xCDhFEK7PDaHIVqpF5m",
	"1d8Il7G+ImYPnVVN3zNxdQySs9CjkUZwzULPVt7j78SO1VzAnMUgVkJCcu69qn0svxPVl/wAO4udGYFb",
	"+WZGbufiRy8rVOLyJGM+mXmsvpFcfbQQjhii0sPPJI3frST4YKy+EZHTEHX/S2zlHj+Wyr+/8V6x1Fno",
	"GFWdq3UGbWoP1f5nFjEtULsLqe3VovqM/ReO33kwysQVEey/0NQ61JqP2bupMnwWfEivf6XGvB5FTM1D",
	"45MGeblL+JBeM56liVIurilnin34lKD2af6QXke/Ahdei4b5YOkC0uuI8CJNlQZo9PrOsWeBNuy0ZU4W",
	"eegaGxP85gFXG0Sd2qyedYhxmYlctfIjz5LDhC7ANSxFTI2dsJRKvZeE5rkaUJuZuriva56aBYsw72r4",
	"08GJ05CXM3e0hhQ4jcsedzML29UnYyVWu76bBVkKI0Stu8y7WX9bd6WDbZvrVPB1B2gRhQCuTuV+GKqj",
	"+m/ho8Yz3YaYRuTfZ798Qhr/6eBkC6YvhcWxpi/PdnwqeBNOLbDkVIibjHt0ixPzRcm1QlSsh1fUtHEI",
	"lGN/9gxeCOB+4X1hvoxfqh+o5QyzCi4+qHaqPi3wKp0Fol+VonfCYc5uPXDG31FfUyxP9yDXdcao7z0Z",
	"71IRnXnOirl3Hv37PefJ+zeBF25moSNaQxID6Na4qAofQbqQS4+Wi7/3L7FLMJsF12eYefDig6FiKkdM",
	"SIg6b+k0ZtRnqFM/j9Enw5hBKq1dMeegjfdGMR+6heje3nHzojRh9DHS0tRxN1OiyFFB+no5ysqdOr2d",
	"9ztys4SaGCc3LI49pofeOx7UVYheX4/TFIV4kvHV8IaObTvsI2lE5aBbydDEsW3e9AYPIa9HsUE/NUyB",
	"KhXEdBoNVSEVTY7b5Bm2bXmRh7ZYGuvRQKUtUUzUVm7uccMs2vVOu1718gS5YHMOgEMENRK3dGsBUScz",
	"PPrWfu2xLqpNtfBoxVgEl8UCAwvmWTALbihHIYd6o0+yHWUL8Z5xCKVXSS4/OUZo418yprxLMNEYCEi7",
	"jHnGbyhXv1zS8Ar/2Zp9Fty+UO1fXFMUfUJ1rK3nYzlK7ed35ZBmA2dZwX3XUf37xKUrbGecoujOFUoE",
	"OgbGL1/Peu4MU/164gx4NwuOabhkKRwqZLXvEnmxz8MlkxDKgoPfIkydFnajqdb/fYz5I01YvPIPNcdv",
	"IwY5ziIfZaoxEvVp7BCfvBpVNUzqGEb8YzUvPuUGnXU25pu14KoRcXsONNEGDw/nA5qQBD8aT4LjTGnb",
	"zh2PTr9Ybfl4zBxT3DyOE+ki9SlIvZMofUx106a8H6xVX7A0BAJ5Fi5/bNxZOwwdqOT47cEmrKpudDQh",
	"NBDZ5Zg794JdQ0rUwPyaOm5rHQXW69Wqw8EuCdEb5j32hlZwxvHBCQmzdM4WBdcRN21rQ4chs9LUjx35",
	"3/RJqS/rGFRevvofH+w/wU2vp+O+1n6fqfCznrdHO42zmz8RjynIP/UEPm01zm5KEMisXMkSiO28Q35T",
	"SocAqRrMaSxgRpgkl7Ck12BlegJEaSI5hGy+YumCRJCufimwz94O/re7Z6ksBXmT8SuD5Z1qy5dZFgNF",
	"BY4WMjuhhYCas1NP347PyhKqbpVxvCK56lRXNbQ/DPUS47XqmvEUROHDlpriBcePJM9iFmoCwrmiKkRj",
	"h/ySMNxzxISiT3XjtR133GCX1H/Vhco8N6DsYjOltOrD1avjhvk91VuDsJE9P+nWB4hdVDgh9IrQM/yd",
	"0DgmxvAcZklSpDbSDpl9S1t2UDZNKbWnqN/O73pfbbzq33yiQ6E5Ztde26zh5Dv3dbJW+zMnvs/ltjnn",
	"S8VjjEW1oRvFhZDAx0HdNPaqIlnijT0+wN/tABkPlyAkRztppyPwo7XDDMRRmXsHRgeMdSPoLmc6/Aqm",
	"zCLKPuNmGueD7FLtkrpC28sTnKaaN1hfU18vRQ7WLVULS59uwUizhEadOzFgnBAcZ50HWeqCqAbzDnu/",
	"KG+6GIAyPKdpSM7s5I1T7p9F220PUyFpGno5lrVCM9OmMqgNYt5EyYxAn44xQp1xpG+m//w1OYd9jID+",
	"2/amZw7zKJfdwHdFju2jVz/uHcir9lbymPrhsKxNm289DI6GS4gw7slz2o+YQOakW+n4M0FY1KC98ZGP",
	"z/z0mZ9uhZ9CDzUPsdJRoYJ1o7mH1J/Z4Ag2qPmcy4OGGaGP45Vc1Mf7nPCS5vuPyFopRMvAoi6WSJcH",
	"Jxd957ZsR8rIyZHiuOypL+od4Rv7GHhRn0mbe6fGiLgOE1/gSfUArooBna5khHlxAjwEr2qhAK4GLzBY",
	"NtftdITwmLEjJq6ELxxI6kcIBpc6qJaGS4zC2U2q6Jyxp9uNSvKGASv4nw+G8qSawNZBlu510R3W88kZ",
	"23o81w7uqRF7B2XWUNteoMcf4QDI4s6eybOSf7XdDoVocL/Kd04jdaWLOGWpto2HOsRY/1GkS6CxXK5G",
	"WtGrhZyakatf3ldzVD8euLNVP19U89a2d7Ck6WJzt8rBMMzpQqFBBmYAtQttH+rxCtetVv1CfEN2q0e2",
	"WNzNgq/OSR5lCWUekf+OCiD6o/PQrrSPcjqfs5AwYeyk7DIeFVUL6XUzGL4BEDfIHdkW8ur0OqpbxDbr",
	"I9+U03p7ruFZYHDQC038ubL2KVAafKWLco5rRknOs9vVzjAG1/BIN13K5oh0XTjve1AafOcBuMy3EK+y",
	"9WO/hfCYJ8hXnmNvnmNv1o69MXs/yhb+J6Pab14PAyA0jUjMUmhdV/FH7zjqS9+700d6G4oLrsOh4yXu",
	"nIGxTnYF8nfZHSsv+dZf8z4WVHH97stbA706pMXwo9v6rYwXGMQS6eimFosZdaluItpzsY4z39ujo03M",
	"OfgyCeeeuXBwYHbscO1xz0lsj0F+XJvEGxZ07AbSjGUI3daeT207z7j3ImFeqPv+SdjxbLjPqjOPMzd1",
	"gQ2z0TwTDQVdRpQInwZ1vl/qNqGojv5HhfjaqNNo0muU6V1qj6mnd1D/Ko8HjDvdQ36fwWETQrYc8e0Q",
	"dYULB9UOHbnE6vCGehSIP0LpF98zd+uQwBYQkYPD96fkMs7CK0EyTg5PCI0ijlZwrc4uOCq5Wk3fIfum",
	"X9WKxjd0JYikV0AU1iECBcPsGrge2G29M8l1h4s8KS5jFp7rBdTsMD7KOtNBUoTVOCC5OD0STmxsddXQ",
	"GRGQwdXfz/gDp0zgVTdcI0jZZLBOAkpCxZV5hvuvTHiWYkGwzITEBylGTcVL0CVUVxUMDTIAMjGLwisr",
	"WqpNTYeeGsdtPGD4HAjfU/titUr3/29MLjsf69Y8b10yctyNR0nBu5Zxshxfnb1zoInnrGEmQ8/10Dwb",
	"t+ZAqXr7siiI95agm0P8tgS5hKq7vWmYE9AY0iHTMa+x/aupMuQN34R8I7TuOCannnkAZoDl7tpC9jnX",
	"QaeR/btPVWCox5suY0PB7WGWmjQvZ93u/PMlOC7Lqovj328c9xEqrhtlc+plqN58ZdoygIlCtfYySvV9",
	"VtOG1DQPHXhwZCkPuUCLZ0FiDNGNN+7qZ7vNQvjjjMZxD9N7gHX4zpJem16/sXn7Leb2AAz42XTTe6RN",
	"MynSBm+OiKm6EU7xOdVZjjtpE7LNKZbr5AQ0edDU4davOPr8BZdVurEhHmpR4GQoW9duPyAnKwtrDXqV",
	"sfKRhOX6z2PXtaAr1J7l9CadDCwkivvJ1TWs9yZ2wCdMW8eO/ICtcxrCLh5ik8BRb6j8Fv046XzmeAUb",
	"0k9tBklBdHt18cHblXPbulx5dEdHcRUKL+tygiZmeowVa9n8feehyKM1Tp0mJN11TQOs6zyo8p6P8BEY",
	"ZLoMw92Ge8SbZ6WGnxrbrp/HWSlALPXWmaIrfFB+nJpU155MGlsjvU3RRB+izG7c/SPnv39i1DHXiAeV",
	"KlpAriNSti8B5ixlYjltV7bP6G2tw+rFfZSG0ayo2tT9+VDFeso4206+4uFNrZPwkcVwkccZ9ZyJnIPw",
	"xni6zGDOYmQENMbQPWI62deRGPjrPf8F92jsFzx2ghZw7MqKWOA6Mf/rIJzs2lsb9j+QX+P4t60GY1Pa",
	"4jq0l02UXreN5a+t/GsjFjBJLeFlLt/BBdaS/973oG1DUnjOld9ZWFvjUbbokaWTMLF5UvD5Pls76Eww",
	"ee9ox3VCobLwCrg69R5/XvnNMfl0T7+ONEAGdpB47AEYO0zCJYRXGGtEU0woBrcQFjqJe00vqoLQOpkF",
	"mpO8c6HNY0OzbNi67OCni5B+ffU0SGkd/LvQmhoTOAp+GhCdoHvdC7oRZqEmMHfI+7LbDHPKYR4UlgoJ",
	"NNp5TFiPz1+7Qw5oSlgaxkUEhBJJF9q2HGZxlhIBOcVnTDrFK/kjSFYvbN8/AnUzqf309vrlH8GPO+Rw",
	"jiMxYYeOMBGEddpJm3JaWNcmzksFyXl2zSLtrze/C4Isd2d6ql1/pYnyQE+oN7F52m2SKTIm3/meZ2XK",
	"pL7MFq7WeLPMYqsYVwoeDoQ8jxcp4bCgPIpBlHTdrUzObVJSD69TP9ucilQQSi6paAuRbiY69yU87aPz",
	"doZUM4prAG46Tswq7rHOb098CQn5YH0I++JTte2br3WmxmiiZxJyr2bVctH7dNeBp0+tpVmPPf6tXfY3",
	"lJm3SPZlVHcCNruEI1jQcDXgZXj2KWxc53j2CHyjHoFne/yzPX49e7yr6xs139oLOtX9LfuBH56XTnGo",
	"PVE/WY8WT8tqZhtQ4rdp6CoPQtt5VJbuqOlBvYXL6tu2FczaKRf4oE1sny+KRPHi6mWvmn0KILFkxb+o",
	"8KThVr9aCGKzMvjamal9B5h+xVFDbeRu05+OvnvVvuzwLk4vkOd1GgC3dbjuPEvqsqg+tmvek1mufk5+",
	"Y3JZZVp6fObekyLHZHryGFMn3ZC0P9WXB2or2vBjqpLPgSLPiumo+AOfiO3SPoc1Ts1xNKtcI4Mm3Ggr",
	"sD34E9No2gyoTK7OFCvQczkPt/cLXf3iEigH/tFCUNPan9KtRo80hs2q2ZdS5mVF49qAWOx9CTTC5qbc",
	"+/++wIYvzuvphk3cuxoH/zU0xsnhi59dGFT9z4qcXlIBL8esxTbuXo5t8QoxN3a02qm0gylUMOPNlkwq",
	"RhV8ePVOIdRJofU22Nt5ubOHxY5ySGnOgrfB6529nT18ECKXiL9djZ4XiB4tu7xvXXStREJJCjfNTM+K",
	"9vAlwGEUvA1OMiEdqhCmGj8I+S6LVhurit7IV914UWIsHLXK/q82WGXfUxvUV3K/VfUTolr9a6f4v2+2",
	"cvm7qlFVVr6/rWrknla0Evmo+ffPd5/tDef3oE4IeN7rxLH7hVbbPXx/p4kEKwZ6snap3wlN+2lFN3Op",
	"Zd+dAgmV0wQkcNFp7Kqa7NYWiEavBgW8GcguofdzPyS90bMMtX3zKAhVPHNXCXux+0W7ju52y7cOu1jl",
	"vZMH/MziWLiP2dwSevgWjmFaauRZHqaAjF1NfY4Tl2H/P+va8g1Uex6Y6FyE6k/FvyqOWT5+qjOAmXOY",
	"h+L326SytzFm0VGj38Mwztq18StYP006bIprTYOiSBKKdfrUhj00Q0uN01KrGsdSac5eXMEKEeEtpo9X",
	"GTUoPtYzioxoUd1PILUWoIXQPdA78mZU6mTtC2Q/rm0NGc+mHllEeDWXBqOx6FLq6Qj1wd2fn1M4SHsQ",
	"zcHF1KMoDs0FeJhd7ZnlE9MbphGFe6R3v2gtdqT+0E8rRn3Q1LJvxp2uNNiO4/SFGnK+dn1h8ummMvTY",
	"VvWddAhdJ6rzhrG1efbQul+P4hB7A4RibvrfCaGoE6/TpnaK8H/hZx2b4hPc+nswBtDGkq0zmZXwnQZd",
	"RPJumkUwQuvQzTyL/mQ+bEbXGOfjx+ImWEB4fY1Db2hrQsWvM/o0QVzY7hediPyuEzM/gdT5mE3JQj9i",
	"Ptl05tM4jsmCfjebks8Xbyl/FYDPt801pZYs/UncTJzqEaPppczd/BVdR5qk1ammYlJnIspoLWrTVLeV",
	"1E2Q1AOJsFaW6jsjwwZ1G4NbCwF0zOAQX4PkGs9Wauls+nm9LSPhFjVosRc3g0GvGaNMHIesQXugZUbm",
	"LLYxkdU12YY1FwL4P+ll+Eext/fq7zTP/5nzLMJY5g80XKJ6QdNIl0YUJCmEJJdALk6PCKRhFgEGfPsY",
	"Upmu1OVHm+Y/E8VZo/bG/eRaG3lIjHtjiHFvi/LQcVX8/lkJmrWVsHoipYHLuM1JhSlWG361NsNzifyB",
	"7uUl2rd7Ka9N2+aIbqbc7tv4d0JUNfa561QI6majbuUOHTQ2jpkeV9Vb+njqQZYk9IV5DgIRieulgMjh",
	"ewwPX0BtJcEsgNs8xsqAJqTHxyLNIH+ySPTal7td9wm9PdQfX+7tNZjZLChS9lcBpgHS+YMqfN5sb/dj",
	"qfpNTlIVVPlOj8KXMrN0r2VL28OdbH0+k1aJpjMnW/U0FbPKcz3SrNVgdNb78PS1vocSnp03zUpwXq4I",
	"3tm6edgDIXDjHGGdW6CoCqR9N2TReeZ3TbWibvfpKcJOlMQT6Sx++kWiW8ZGmIrMtXeJuvpytEPOz49U",
	"E4zjglsJqVHwexS2kghNjaN70+LmlT+zskkK4N5jKIA23YVNrno3eyxV1FDE1lTRb/Tc2mQNnezewtyk",
	"hRjB6490y7XP2Mz7tlJpXdJTXkAQuaTSiTgvmTRLScLimJlsjh1WAHzS6TdJ2njN/mLfLSMHvVWtnQSe",
	"favsWFXMdPnHalVVWbA9pUhPq++1BRGKWF9HgGrKej6N6jQOXSjdA1lV9xxxJjsvk/c4lmXCVH0kq1cr",
	"lJd1ihUJ8msaz5zydDNsqpOFV4lYH/B8+oYFTGTrHq8RW4M0Wm9j05b8eRvhOo2U5OvaGd2DvIVb8Dd6",
	"7nNb9s2vO2NVuEaa+zEKr64mt+27s1bfa4oZWuhDmjqq/ENi/s3eP8a0/cdXRiUc5hzEEkTfLQub1I6l",
	"viYp/YlJYbK46xqiI8notJz3cW5O9fcdUaEX7AmbMl8abNjCoVK+riCXhGIV1Yp7Y+L3W82VX/9d6Vj9",
	"cqWZC2Okk7HBRjVkt2RReAIUrM5+nXz7nwTqYr1r8D7d8Qne9Rvlh5+us6f7hv3MtSfQvFPa2c+zz0C6",
	"lVubhZ13yLm/xCi5tazLcWGyKpOYId4dckDjGK/PSyaUkrbMIpIUsWR5DObtYnYN/IYzaZ4xnp8fzXSZ",
	"eRywELo7EFuIwqnSJiqtX7XCYvRKwCRARWEymtqtWd491mJ3XhazfXy5UyvR3XxXqTZXiZIKHy68TOqn",
	"TsHULhw76m7frjmhVvl5I/JJGNIsy+ia0b83rR2fDI17j+G9kJ+bD9sMJcHXk/eMINEb2p6nsvmctg+N",
	"tegm9ZuDqup11xiLiuuhd16D+7GoX2+ta08xb7WejSnfljHFKQ51L0uKrApJPbAZ5fWYtq+fDEMePOC7",
	"Cb3tPeRIQ8Y07zvwNhWODtGxFDmODRzT22dO8OQ5wayj+LDM1CHkDK6hRiUYUWqCpTriRzlmueiOi7KZ",
	"LatqX3+KdrmvPxEZf3Is+LXdEPhjeuvyrmdetWlepSNKR+mOtqmX5VQfG2zGR5nli/Cugzg6GfLnbeus",
	"JgL33nqrhdcjRtlN0mZH0FW1qXpwc78BrfH2uCfC2SWyhzB8eQswjDJ/vdr4Gkyu4A4rWFW5hoYh5NJ6",
	"K55cZOcDUliNfe2aRE67X/Af3U/RDjDZNps76aWYXBqlSicAg1umC0B3czmTBw7/18Hx6ikwqGnZLYk7",
	"8o7bjtuUuf6SZEP8TbF4nWDEJpxcmdVPJs3x8vSrM9x0U3CVyrT3zX1lF6ULa8frlMy6T0m253TxULyz",
	"PpOaaBIDfdORxLX7Af+z+17Tk80I6zfd75s6FnTxg/gRC1u08+D2CNoHJBi9srUJ5uWGFwKRuxSv3KWL",
	"KqfwMz3202OdtX2pki+OTSvSoQY2GVotqeNE80bZdXwUSS0n5SaSi3w96nz/5dBJWtuDPVeF2hDqZoOt",
	"c7pgKa7hE9xKkwxwSrcjDHXdisblpCmeaOpwlVkmhUHIV/mGq3GNrFLa9N8jTZKb7hukGuhBOMfD3UTr",
	"qcDXznTTyvvbme3m6T8NfBpGi1PQV3CajjRZfB309vVaPr4ta4arMO1qVr77xVSIuJsSnaarfrnFvEbR",
	"qJZB76qSFA8on23hC4+AfeXnZZoGllRon9N3SALDr6IaZT+6HkcN4X6tp1Jr4n+7z6rCggv0nH1N76p8",
	"oVc2JPjlcESw3xkTMQ6h1PWRxrFqRRXvy16dA8dwDfGUQY+wgwe0Z1nBQxiF/TnPki6XMo4yaZd64i3Z",
	"W9ulq9e7BDhH/mmaG/xMdCtW1n62WpVDH8tYuzLaDTHWM1vN/HFY62EawW1Vpsjw2ZJwOk8X3i+bZWl8",
	"Rz9biF/mcwEdvGzyA9FvhtuuzRS3xoEOFUmvxXme2U0vu8GyZrtfllQs+3Nl0pQUeZzRiMQsvbJWNcqx",
	"MBpRGKcsdQ4sXYH+NlbH+1jWYbsnA/K4Opd62LGezlbdt1HOzpcPQ/oKLhcI+a77p4uXmyVwXRla/6ir",
	"jmtMfANOga0fm+tXUzI/9iYp+/XVt5zzsSUMP+rFVgu9XJEsBZJxkmRc5wtFSIzKqSa1XF/vvfaZNIKg",
	"WRNNyBWWQlIy9Wuy2z8nyHzMhy3Xr+oxipuPKvv11WPElf366qnbVw0kvrdkmh6h1O3I7q+30O+Kcuju",
	"23ZGPcgiug0kz96uTVD3gNdhqo/BS+yP52V4YB6PEJnE4Z+Wk+MBuenrLnG+pvB+/SjC+/VjCW+zAMv/",
	"7EKe5Xg/5eE8/NpyloLHpqKteLu7S3O2A68ud2ieB84IX6rHKtVbjS+NxNP1H/Fhjft3rcSj+8HW4nF+",
	"w2nvPt/9XwAAAP//2U5Xc6/4AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
